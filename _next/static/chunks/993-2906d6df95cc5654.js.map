{"version":3,"file":"static/chunks/993-2906d6df95cc5654.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@radix-ui/react-direction/dist/index.mjs","webpack://_N_E/./node_modules/@radix-ui/react-arrow/dist/index.mjs","webpack://_N_E/./node_modules/@radix-ui/react-use-size/dist/index.mjs","webpack://_N_E/../src/popper.tsx","webpack://_N_E/../src/roving-focus-group.tsx","webpack://_N_E/./node_modules/@radix-ui/react-menu/node_modules/@radix-ui/react-slot/dist/index.mjs","webpack://_N_E/../src/menu.tsx","webpack://_N_E/../src/dropdown-menu.tsx","webpack://_N_E/./node_modules/@swc/helpers/esm/_class_apply_descriptor_get.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_class_extract_field_descriptor.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_class_private_field_get.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_check_private_redeclaration.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_class_private_field_init.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_class_apply_descriptor_set.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_class_private_field_set.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_super_prop_base.js","webpack://_N_E/./node_modules/@swc/helpers/esm/_get.js","webpack://_N_E/./node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot/dist/index.mjs","webpack://_N_E/../src/collection-legacy.tsx","webpack://_N_E/../src/collection.tsx","webpack://_N_E/../src/ordered-dictionary.ts"],"sourcesContent":["// packages/react/direction/src/direction.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar DirectionContext = React.createContext(void 0);\nvar DirectionProvider = (props) => {\n  const { dir, children } = props;\n  return /* @__PURE__ */ jsx(DirectionContext.Provider, { value: dir, children });\n};\nfunction useDirection(localDir) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || \"ltr\";\n}\nvar Provider = DirectionProvider;\nexport {\n  DirectionProvider,\n  Provider,\n  useDirection\n};\n//# sourceMappingURL=index.mjs.map\n","// src/arrow.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NAME = \"Arrow\";\nvar Arrow = React.forwardRef((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return /* @__PURE__ */ jsx(\n    Primitive.svg,\n    {\n      ...arrowProps,\n      ref: forwardedRef,\n      width,\n      height,\n      viewBox: \"0 0 30 10\",\n      preserveAspectRatio: \"none\",\n      children: props.asChild ? children : /* @__PURE__ */ jsx(\"polygon\", { points: \"0,0 30,0 15,10\" })\n    }\n  );\n});\nArrow.displayName = NAME;\nvar Root = Arrow;\nexport {\n  Arrow,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-size/src/use-size.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nfunction useSize(element) {\n  const [size, setSize] = React.useState(void 0);\n  useLayoutEffect(() => {\n    if (element) {\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n        if (!entries.length) {\n          return;\n        }\n        const entry = entries[0];\n        let width;\n        let height;\n        if (\"borderBoxSize\" in entry) {\n          const borderSizeEntry = entry[\"borderBoxSize\"];\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize[\"inlineSize\"];\n          height = borderSize[\"blockSize\"];\n        } else {\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n        setSize({ width, height });\n      });\n      resizeObserver.observe(element, { box: \"border-box\" });\n      return () => resizeObserver.unobserve(element);\n    } else {\n      setSize(void 0);\n    }\n  }, [element]);\n  return size;\n}\nexport {\n  useSize\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    const anchorRef = React.useRef<Measurable | null>(null);\n    React.useEffect(() => {\n      const previousAnchor = anchorRef.current;\n      anchorRef.current = virtualRef?.current || ref.current;\n      if (previousAnchor !== anchorRef.current) {\n        // Consumer can anchor the popper to something that isn't\n        // a DOM node e.g. pointer position, so we override the\n        // `anchorRef` with their virtual ref in this case.\n        context.onAnchorChange(anchorRef.current);\n      }\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ComponentRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends Omit<PrimitiveSpanProps, 'children'> {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { hasTabStop: boolean; isCurrentTabStop: boolean }) => React.ReactNode);\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        >\n          {typeof children === 'function'\n            ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null })\n            : children}\n        </Primitive.span>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n","// src/slot.tsx\nimport * as React from \"react\";\nimport { composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { Fragment as Fragment2, jsx } from \"react/jsx-runtime\";\n// @__NO_SIDE_EFFECTS__\nfunction createSlot(ownerName) {\n  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);\n  const Slot2 = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n    if (slottable) {\n      const newElement = slottable.props.children;\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement) ? newElement.props.children : null;\n        } else {\n          return child;\n        }\n      });\n      return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });\n    }\n    return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });\n  });\n  Slot2.displayName = `${ownerName}.Slot`;\n  return Slot2;\n}\nvar Slot = /* @__PURE__ */ createSlot(\"Slot\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlotClone(ownerName) {\n  const SlotClone = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props2 = mergeProps(slotProps, children.props);\n      if (children.type !== React.Fragment) {\n        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props2);\n    }\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\nvar SLOTTABLE_IDENTIFIER = Symbol(\"radix.slottable\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlottable(ownerName) {\n  const Slottable2 = ({ children }) => {\n    return /* @__PURE__ */ jsx(Fragment2, { children });\n  };\n  Slottable2.displayName = `${ownerName}.Slottable`;\n  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable2;\n}\nvar Slottable = /* @__PURE__ */ createSlottable(\"Slottable\");\nfunction isSlottable(child) {\n  return React.isValidElement(child) && typeof child.type === \"function\" && \"__radixId\" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;\n}\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = { ...childProps };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n  return { ...slotProps, ...overrideProps };\n}\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nexport {\n  Slot as Root,\n  Slot,\n  Slottable,\n  createSlot,\n  createSlottable\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { createSlot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ComponentRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ComponentRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst Slot = createSlot('MenuContent.ScrollLock');\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus({ preventScroll: true });\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n                preventScrollOnEntryFocus\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ComponentRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ComponentRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus({ preventScroll: true });\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ComponentRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ComponentRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ComponentRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ComponentRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0]! : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const ii = polygon[i]!;\n    const jj = polygon[j]!;\n    const xi = ii.x;\n    const yi = ii.y;\n    const xj = jj.x;\n    const yj = jj.y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as MenuPrimitive from '@radix-ui/react-menu';\nimport { createMenuScope } from '@radix-ui/react-menu';\nimport { useId } from '@radix-ui/react-id';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst DROPDOWN_MENU_NAME = 'DropdownMenu';\n\ntype ScopedProps<P> = P & { __scopeDropdownMenu?: Scope };\nconst [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(\n  DROPDOWN_MENU_NAME,\n  [createMenuScope]\n);\nconst useMenuScope = createMenuScope();\n\ntype DropdownMenuContextValue = {\n  triggerId: string;\n  triggerRef: React.RefObject<HTMLButtonElement | null>;\n  contentId: string;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal: boolean;\n};\n\nconst [DropdownMenuProvider, useDropdownMenuContext] =\n  createDropdownMenuContext<DropdownMenuContextValue>(DROPDOWN_MENU_NAME);\n\ninterface DropdownMenuProps {\n  children?: React.ReactNode;\n  dir?: Direction;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  modal?: boolean;\n}\n\nconst DropdownMenu: React.FC<DropdownMenuProps> = (props: ScopedProps<DropdownMenuProps>) => {\n  const {\n    __scopeDropdownMenu,\n    children,\n    dir,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    modal = true,\n  } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: DROPDOWN_MENU_NAME,\n  });\n\n  return (\n    <DropdownMenuProvider\n      scope={__scopeDropdownMenu}\n      triggerId={useId()}\n      triggerRef={triggerRef}\n      contentId={useId()}\n      open={open}\n      onOpenChange={setOpen}\n      onOpenToggle={React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen])}\n      modal={modal}\n    >\n      <MenuPrimitive.Root {...menuScope} open={open} onOpenChange={setOpen} dir={dir} modal={modal}>\n        {children}\n      </MenuPrimitive.Root>\n    </DropdownMenuProvider>\n  );\n};\n\nDropdownMenu.displayName = DROPDOWN_MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'DropdownMenuTrigger';\n\ntype DropdownMenuTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface DropdownMenuTriggerProps extends PrimitiveButtonProps {}\n\nconst DropdownMenuTrigger = React.forwardRef<DropdownMenuTriggerElement, DropdownMenuTriggerProps>(\n  (props: ScopedProps<DropdownMenuTriggerProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;\n    const context = useDropdownMenuContext(TRIGGER_NAME, __scopeDropdownMenu);\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return (\n      <MenuPrimitive.Anchor asChild {...menuScope}>\n        <Primitive.button\n          type=\"button\"\n          id={context.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={context.open ? context.contentId : undefined}\n          data-state={context.open ? 'open' : 'closed'}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          {...triggerProps}\n          ref={composeRefs(forwardedRef, context.triggerRef)}\n          onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click)\n            if (!disabled && event.button === 0 && event.ctrlKey === false) {\n              context.onOpenToggle();\n              // prevent trigger focusing when opening\n              // this allows the content to be given focus without competition\n              if (!context.open) event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (disabled) return;\n            if (['Enter', ' '].includes(event.key)) context.onOpenToggle();\n            if (event.key === 'ArrowDown') context.onOpenChange(true);\n            // prevent keydown from scrolling window / first focused item to execute\n            // that keydown (inadvertently closing the menu)\n            if (['Enter', ' ', 'ArrowDown'].includes(event.key)) event.preventDefault();\n          })}\n        />\n      </MenuPrimitive.Anchor>\n    );\n  }\n);\n\nDropdownMenuTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'DropdownMenuPortal';\n\ntype MenuPortalProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Portal>;\ninterface DropdownMenuPortalProps extends MenuPortalProps {}\n\nconst DropdownMenuPortal: React.FC<DropdownMenuPortalProps> = (\n  props: ScopedProps<DropdownMenuPortalProps>\n) => {\n  const { __scopeDropdownMenu, ...portalProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.Portal {...menuScope} {...portalProps} />;\n};\n\nDropdownMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'DropdownMenuContent';\n\ntype DropdownMenuContentElement = React.ComponentRef<typeof MenuPrimitive.Content>;\ntype MenuContentProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Content>;\ninterface DropdownMenuContentProps extends Omit<MenuContentProps, 'onEntryFocus'> {}\n\nconst DropdownMenuContent = React.forwardRef<DropdownMenuContentElement, DropdownMenuContentProps>(\n  (props: ScopedProps<DropdownMenuContentProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...contentProps } = props;\n    const context = useDropdownMenuContext(CONTENT_NAME, __scopeDropdownMenu);\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    const hasInteractedOutsideRef = React.useRef(false);\n\n    return (\n      <MenuPrimitive.Content\n        id={context.contentId}\n        aria-labelledby={context.triggerId}\n        {...menuScope}\n        {...contentProps}\n        ref={forwardedRef}\n        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n          hasInteractedOutsideRef.current = false;\n          // Always prevent auto focus because we either focus manually or want user agent focus\n          event.preventDefault();\n        })}\n        onInteractOutside={composeEventHandlers(props.onInteractOutside, (event) => {\n          const originalEvent = event.detail.originalEvent as PointerEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;\n        })}\n        style={{\n          ...props.style,\n          // re-namespace exposed content custom properties\n          ...{\n            '--radix-dropdown-menu-content-transform-origin':\n              'var(--radix-popper-transform-origin)',\n            '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',\n            '--radix-dropdown-menu-content-available-height':\n              'var(--radix-popper-available-height)',\n            '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',\n            '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',\n          },\n        }}\n      />\n    );\n  }\n);\n\nDropdownMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'DropdownMenuGroup';\n\ntype DropdownMenuGroupElement = React.ComponentRef<typeof MenuPrimitive.Group>;\ntype MenuGroupProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Group>;\ninterface DropdownMenuGroupProps extends MenuGroupProps {}\n\nconst DropdownMenuGroup = React.forwardRef<DropdownMenuGroupElement, DropdownMenuGroupProps>(\n  (props: ScopedProps<DropdownMenuGroupProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...groupProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Group {...menuScope} {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'DropdownMenuLabel';\n\ntype DropdownMenuLabelElement = React.ComponentRef<typeof MenuPrimitive.Label>;\ntype MenuLabelProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Label>;\ninterface DropdownMenuLabelProps extends MenuLabelProps {}\n\nconst DropdownMenuLabel = React.forwardRef<DropdownMenuLabelElement, DropdownMenuLabelProps>(\n  (props: ScopedProps<DropdownMenuLabelProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...labelProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Label {...menuScope} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'DropdownMenuItem';\n\ntype DropdownMenuItemElement = React.ComponentRef<typeof MenuPrimitive.Item>;\ntype MenuItemProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Item>;\ninterface DropdownMenuItemProps extends MenuItemProps {}\n\nconst DropdownMenuItem = React.forwardRef<DropdownMenuItemElement, DropdownMenuItemProps>(\n  (props: ScopedProps<DropdownMenuItemProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...itemProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Item {...menuScope} {...itemProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'DropdownMenuCheckboxItem';\n\ntype DropdownMenuCheckboxItemElement = React.ComponentRef<typeof MenuPrimitive.CheckboxItem>;\ntype MenuCheckboxItemProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.CheckboxItem>;\ninterface DropdownMenuCheckboxItemProps extends MenuCheckboxItemProps {}\n\nconst DropdownMenuCheckboxItem = React.forwardRef<\n  DropdownMenuCheckboxItemElement,\n  DropdownMenuCheckboxItemProps\n>((props: ScopedProps<DropdownMenuCheckboxItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...checkboxItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.CheckboxItem {...menuScope} {...checkboxItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'DropdownMenuRadioGroup';\n\ntype DropdownMenuRadioGroupElement = React.ComponentRef<typeof MenuPrimitive.RadioGroup>;\ntype MenuRadioGroupProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioGroup>;\ninterface DropdownMenuRadioGroupProps extends MenuRadioGroupProps {}\n\nconst DropdownMenuRadioGroup = React.forwardRef<\n  DropdownMenuRadioGroupElement,\n  DropdownMenuRadioGroupProps\n>((props: ScopedProps<DropdownMenuRadioGroupProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioGroupProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.RadioGroup {...menuScope} {...radioGroupProps} ref={forwardedRef} />;\n});\n\nDropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'DropdownMenuRadioItem';\n\ntype DropdownMenuRadioItemElement = React.ComponentRef<typeof MenuPrimitive.RadioItem>;\ntype MenuRadioItemProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.RadioItem>;\ninterface DropdownMenuRadioItemProps extends MenuRadioItemProps {}\n\nconst DropdownMenuRadioItem = React.forwardRef<\n  DropdownMenuRadioItemElement,\n  DropdownMenuRadioItemProps\n>((props: ScopedProps<DropdownMenuRadioItemProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...radioItemProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.RadioItem {...menuScope} {...radioItemProps} ref={forwardedRef} />;\n});\n\nDropdownMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'DropdownMenuItemIndicator';\n\ntype DropdownMenuItemIndicatorElement = React.ComponentRef<typeof MenuPrimitive.ItemIndicator>;\ntype MenuItemIndicatorProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.ItemIndicator>;\ninterface DropdownMenuItemIndicatorProps extends MenuItemIndicatorProps {}\n\nconst DropdownMenuItemIndicator = React.forwardRef<\n  DropdownMenuItemIndicatorElement,\n  DropdownMenuItemIndicatorProps\n>((props: ScopedProps<DropdownMenuItemIndicatorProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.ItemIndicator {...menuScope} {...itemIndicatorProps} ref={forwardedRef} />;\n});\n\nDropdownMenuItemIndicator.displayName = INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'DropdownMenuSeparator';\n\ntype DropdownMenuSeparatorElement = React.ComponentRef<typeof MenuPrimitive.Separator>;\ntype MenuSeparatorProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Separator>;\ninterface DropdownMenuSeparatorProps extends MenuSeparatorProps {}\n\nconst DropdownMenuSeparator = React.forwardRef<\n  DropdownMenuSeparatorElement,\n  DropdownMenuSeparatorProps\n>((props: ScopedProps<DropdownMenuSeparatorProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...separatorProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.Separator {...menuScope} {...separatorProps} ref={forwardedRef} />;\n});\n\nDropdownMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'DropdownMenuArrow';\n\ntype DropdownMenuArrowElement = React.ComponentRef<typeof MenuPrimitive.Arrow>;\ntype MenuArrowProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.Arrow>;\ninterface DropdownMenuArrowProps extends MenuArrowProps {}\n\nconst DropdownMenuArrow = React.forwardRef<DropdownMenuArrowElement, DropdownMenuArrowProps>(\n  (props: ScopedProps<DropdownMenuArrowProps>, forwardedRef) => {\n    const { __scopeDropdownMenu, ...arrowProps } = props;\n    const menuScope = useMenuScope(__scopeDropdownMenu);\n    return <MenuPrimitive.Arrow {...menuScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nDropdownMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSub\n * -----------------------------------------------------------------------------------------------*/\n\ninterface DropdownMenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst DropdownMenuSub: React.FC<DropdownMenuSubProps> = (\n  props: ScopedProps<DropdownMenuSubProps>\n) => {\n  const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: 'DropdownMenuSub',\n  });\n\n  return (\n    <MenuPrimitive.Sub {...menuScope} open={open} onOpenChange={setOpen}>\n      {children}\n    </MenuPrimitive.Sub>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'DropdownMenuSubTrigger';\n\ntype DropdownMenuSubTriggerElement = React.ComponentRef<typeof MenuPrimitive.SubTrigger>;\ntype MenuSubTriggerProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.SubTrigger>;\ninterface DropdownMenuSubTriggerProps extends MenuSubTriggerProps {}\n\nconst DropdownMenuSubTrigger = React.forwardRef<\n  DropdownMenuSubTriggerElement,\n  DropdownMenuSubTriggerProps\n>((props: ScopedProps<DropdownMenuSubTriggerProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subTriggerProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n  return <MenuPrimitive.SubTrigger {...menuScope} {...subTriggerProps} ref={forwardedRef} />;\n});\n\nDropdownMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DropdownMenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'DropdownMenuSubContent';\n\ntype DropdownMenuSubContentElement = React.ComponentRef<typeof MenuPrimitive.Content>;\ntype MenuSubContentProps = React.ComponentPropsWithoutRef<typeof MenuPrimitive.SubContent>;\ninterface DropdownMenuSubContentProps extends MenuSubContentProps {}\n\nconst DropdownMenuSubContent = React.forwardRef<\n  DropdownMenuSubContentElement,\n  DropdownMenuSubContentProps\n>((props: ScopedProps<DropdownMenuSubContentProps>, forwardedRef) => {\n  const { __scopeDropdownMenu, ...subContentProps } = props;\n  const menuScope = useMenuScope(__scopeDropdownMenu);\n\n  return (\n    <MenuPrimitive.SubContent\n      {...menuScope}\n      {...subContentProps}\n      ref={forwardedRef}\n      style={{\n        ...props.style,\n        // re-namespace exposed content custom properties\n        ...{\n          '--radix-dropdown-menu-content-transform-origin': 'var(--radix-popper-transform-origin)',\n          '--radix-dropdown-menu-content-available-width': 'var(--radix-popper-available-width)',\n          '--radix-dropdown-menu-content-available-height': 'var(--radix-popper-available-height)',\n          '--radix-dropdown-menu-trigger-width': 'var(--radix-popper-anchor-width)',\n          '--radix-dropdown-menu-trigger-height': 'var(--radix-popper-anchor-height)',\n        },\n      }}\n    />\n  );\n});\n\nDropdownMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = DropdownMenu;\nconst Trigger = DropdownMenuTrigger;\nconst Portal = DropdownMenuPortal;\nconst Content = DropdownMenuContent;\nconst Group = DropdownMenuGroup;\nconst Label = DropdownMenuLabel;\nconst Item = DropdownMenuItem;\nconst CheckboxItem = DropdownMenuCheckboxItem;\nconst RadioGroup = DropdownMenuRadioGroup;\nconst RadioItem = DropdownMenuRadioItem;\nconst ItemIndicator = DropdownMenuItemIndicator;\nconst Separator = DropdownMenuSeparator;\nconst Arrow = DropdownMenuArrow;\nconst Sub = DropdownMenuSub;\nconst SubTrigger = DropdownMenuSubTrigger;\nconst SubContent = DropdownMenuSubContent;\n\nexport {\n  createDropdownMenuScope,\n  //\n  DropdownMenu,\n  DropdownMenuTrigger,\n  DropdownMenuPortal,\n  DropdownMenuContent,\n  DropdownMenuGroup,\n  DropdownMenuLabel,\n  DropdownMenuItem,\n  DropdownMenuCheckboxItem,\n  DropdownMenuRadioGroup,\n  DropdownMenuRadioItem,\n  DropdownMenuItemIndicator,\n  DropdownMenuSeparator,\n  DropdownMenuArrow,\n  DropdownMenuSub,\n  DropdownMenuSubTrigger,\n  DropdownMenuSubContent,\n  //\n  Root,\n  Trigger,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  DropdownMenuProps,\n  DropdownMenuTriggerProps,\n  DropdownMenuPortalProps,\n  DropdownMenuContentProps,\n  DropdownMenuGroupProps,\n  DropdownMenuLabelProps,\n  DropdownMenuItemProps,\n  DropdownMenuCheckboxItemProps,\n  DropdownMenuRadioGroupProps,\n  DropdownMenuRadioItemProps,\n  DropdownMenuItemIndicatorProps,\n  DropdownMenuSeparatorProps,\n  DropdownMenuArrowProps,\n  DropdownMenuSubProps,\n  DropdownMenuSubTriggerProps,\n  DropdownMenuSubContentProps,\n};\n","function _class_apply_descriptor_get(receiver, descriptor) {\n    if (descriptor.get) return descriptor.get.call(receiver);\n\n    return descriptor.value;\n}\nexport { _class_apply_descriptor_get as _ };\n","function _class_extract_field_descriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n\n    return privateMap.get(receiver);\n}\nexport { _class_extract_field_descriptor as _ };\n","import { _ as _class_apply_descriptor_get } from \"./_class_apply_descriptor_get.js\";\nimport { _ as _class_extract_field_descriptor } from \"./_class_extract_field_descriptor.js\";\n\nfunction _class_private_field_get(receiver, privateMap) {\n    var descriptor = _class_extract_field_descriptor(receiver, privateMap, \"get\");\n    return _class_apply_descriptor_get(receiver, descriptor);\n}\nexport { _class_private_field_get as _ };\n","function _check_private_redeclaration(obj, privateCollection) {\n    if (privateCollection.has(obj)) {\n        throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n    }\n}\nexport { _check_private_redeclaration as _ };\n","import { _ as _check_private_redeclaration } from \"./_check_private_redeclaration.js\";\n\nfunction _class_private_field_init(obj, privateMap, value) {\n    _check_private_redeclaration(obj, privateMap);\n    privateMap.set(obj, value);\n}\nexport { _class_private_field_init as _ };\n","function _class_apply_descriptor_set(receiver, descriptor, value) {\n    if (descriptor.set) descriptor.set.call(receiver, value);\n    else {\n        if (!descriptor.writable) {\n            // This should only throw in strict mode, but class bodies are\n            // always strict and private fields can only be used inside\n            // class bodies.\n            throw new TypeError(\"attempted to set read only private field\");\n        }\n        descriptor.value = value;\n    }\n}\nexport { _class_apply_descriptor_set as _ };\n","import { _ as _class_apply_descriptor_set } from \"./_class_apply_descriptor_set.js\";\nimport { _ as _class_extract_field_descriptor } from \"./_class_extract_field_descriptor.js\";\n\nfunction _class_private_field_set(receiver, privateMap, value) {\n    var descriptor = _class_extract_field_descriptor(receiver, privateMap, \"set\");\n    _class_apply_descriptor_set(receiver, descriptor, value);\n    return value;\n}\nexport { _class_private_field_set as _ };\n","import { _ as _get_prototype_of } from \"./_get_prototype_of.js\";\n\nfunction _super_prop_base(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n        object = _get_prototype_of(object);\n        if (object === null) break;\n    }\n\n    return object;\n}\nexport { _super_prop_base as _ };\n","import { _ as _super_prop_base } from \"./_super_prop_base.js\";\n\nfunction _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) _get = Reflect.get;\n    else {\n        _get = function get(target, property, receiver) {\n            var base = _super_prop_base(target, property);\n\n            if (!base) return;\n\n            var desc = Object.getOwnPropertyDescriptor(base, property);\n\n            if (desc.get) return desc.get.call(receiver || target);\n\n            return desc.value;\n        };\n    }\n\n    return _get(target, property, receiver || target);\n}\nexport { _get as _ };\n","// src/slot.tsx\nimport * as React from \"react\";\nimport { composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { Fragment as Fragment2, jsx } from \"react/jsx-runtime\";\n// @__NO_SIDE_EFFECTS__\nfunction createSlot(ownerName) {\n  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);\n  const Slot2 = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n    if (slottable) {\n      const newElement = slottable.props.children;\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement) ? newElement.props.children : null;\n        } else {\n          return child;\n        }\n      });\n      return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });\n    }\n    return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });\n  });\n  Slot2.displayName = `${ownerName}.Slot`;\n  return Slot2;\n}\nvar Slot = /* @__PURE__ */ createSlot(\"Slot\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlotClone(ownerName) {\n  const SlotClone = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props2 = mergeProps(slotProps, children.props);\n      if (children.type !== React.Fragment) {\n        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props2);\n    }\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\nvar SLOTTABLE_IDENTIFIER = Symbol(\"radix.slottable\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlottable(ownerName) {\n  const Slottable2 = ({ children }) => {\n    return /* @__PURE__ */ jsx(Fragment2, { children });\n  };\n  Slottable2.displayName = `${ownerName}.Slottable`;\n  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable2;\n}\nvar Slottable = /* @__PURE__ */ createSlottable(\"Slottable\");\nfunction isSlottable(child) {\n  return React.isValidElement(child) && typeof child.type === \"function\" && \"__radixId\" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;\n}\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = { ...childProps };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n  return { ...slotProps, ...overrideProps };\n}\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nexport {\n  Slot as Root,\n  Slot,\n  Slottable,\n  createSlot,\n  createSlottable\n};\n//# sourceMappingURL=index.mjs.map\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}></CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\nimport type { EntryOf } from './ordered-dictionary';\nimport { OrderedDict } from './ordered-dictionary';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\ninterface BaseItemData {\n  id?: string;\n}\n\ntype ItemDataWithElement<\n  ItemData extends BaseItemData,\n  ItemElement extends HTMLElement,\n> = ItemData & {\n  element: ItemElement;\n};\n\ntype ItemMap<ItemElement extends HTMLElement, ItemData extends BaseItemData> = OrderedDict<\n  ItemElement,\n  ItemDataWithElement<ItemData, ItemElement>\n>;\n\nfunction createCollection<\n  ItemElement extends HTMLElement,\n  ItemData extends BaseItemData = BaseItemData,\n>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionElement: CollectionElement | null;\n    collectionRef: React.Ref<CollectionElement | null>;\n    collectionRefObject: React.RefObject<CollectionElement | null>;\n    itemMap: ItemMap<ItemElement, ItemData>;\n    setItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>;\n  };\n\n  const [CollectionContextProvider, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    {\n      collectionElement: null,\n      collectionRef: { current: null },\n      collectionRefObject: { current: null },\n      itemMap: new OrderedDict(),\n      setItemMap: () => void 0,\n    }\n  );\n\n  type CollectionState = [\n    ItemMap: ItemMap<ItemElement, ItemData>,\n    SetItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>,\n  ];\n\n  const CollectionProvider: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state?: CollectionState;\n  }> = ({ state, ...props }) => {\n    return state ? (\n      <CollectionProviderImpl {...props} state={state} />\n    ) : (\n      <CollectionInit {...props} />\n    );\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  const CollectionInit: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n  }> = (props) => {\n    const state = useInitCollection();\n    return <CollectionProviderImpl {...props} state={state} />;\n  };\n  CollectionInit.displayName = PROVIDER_NAME + 'Init';\n\n  const CollectionProviderImpl: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state: CollectionState;\n  }> = (props) => {\n    const { scope, children, state } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const [collectionElement, setCollectionElement] = React.useState<CollectionElement | null>(\n      null\n    );\n    const composeRefs = useComposedRefs(ref, setCollectionElement);\n    const [itemMap, setItemMap] = state;\n\n    React.useEffect(() => {\n      if (!collectionElement) return;\n\n      const observer = getChildListObserver(() => {\n        // setItemMap((map) => {\n        //   const copy = new OrderedDict(map).toSorted(([, a], [, b]) =>\n        //     !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1\n        //   );\n        //   // check if the order has changed\n        //   let index = -1;\n        //   for (const entry of copy) {\n        //     index++;\n        //     const key = map.keyAt(index)!;\n        //     const [copyKey] = entry;\n        //     if (key !== copyKey) {\n        //       // order has changed!\n        //       return copy;\n        //     }\n        //   }\n        //   return map;\n        // });\n      });\n      observer.observe(collectionElement, {\n        childList: true,\n        subtree: true,\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [collectionElement]);\n\n    return (\n      <CollectionContextProvider\n        scope={scope}\n        itemMap={itemMap}\n        setItemMap={setItemMap}\n        collectionRef={composeRefs}\n        collectionRefObject={ref}\n        collectionElement={collectionElement}\n      >\n        {children}\n      </CollectionContextProvider>\n    );\n  };\n\n  CollectionProviderImpl.displayName = PROVIDER_NAME + 'Impl';\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const [element, setElement] = React.useState<ItemElement | null>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref, setElement);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      const { setItemMap } = context;\n\n      const itemDataRef = React.useRef(itemData);\n      if (!shallowEqual(itemDataRef.current, itemData)) {\n        itemDataRef.current = itemData;\n      }\n      const memoizedItemData = itemDataRef.current;\n\n      React.useEffect(() => {\n        const itemData = memoizedItemData;\n        setItemMap((map) => {\n          if (!element) {\n            return map;\n          }\n\n          if (!map.has(element)) {\n            map.set(element, { ...(itemData as unknown as ItemData), element });\n            return map.toSorted(sortByDocumentPosition);\n          }\n\n          return map\n            .set(element, { ...(itemData as unknown as ItemData), element })\n            .toSorted(sortByDocumentPosition);\n        });\n\n        return () => {\n          setItemMap((map) => {\n            if (!element || !map.has(element)) {\n              return map;\n            }\n            map.delete(element);\n            return new OrderedDict(map);\n          });\n        };\n      }, [element, memoizedItemData, setItemMap]);\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs as any}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useInitCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useInitCollection() {\n    return React.useState<ItemMap<ItemElement, ItemData>>(new OrderedDict());\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const { itemMap } = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    return itemMap;\n  }\n\n  const functions = {\n    createCollectionScope,\n    useCollection,\n    useInitCollection,\n  };\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    functions,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n\nfunction shallowEqual(a: any, b: any) {\n  if (a === b) return true;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a == null || b == null) return false;\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (a[key] !== b[key]) return false;\n  }\n  return true;\n}\n\nfunction isElementPreceding(a: Element, b: Element) {\n  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);\n}\n\nfunction sortByDocumentPosition<E extends HTMLElement, T extends BaseItemData>(\n  a: EntryOf<ItemMap<E, T>>,\n  b: EntryOf<ItemMap<E, T>>\n) {\n  return !a[1].element || !b[1].element\n    ? 0\n    : isElementPreceding(a[1].element, b[1].element)\n      ? -1\n      : 1;\n}\n\nfunction getChildListObserver(callback: () => void) {\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'childList') {\n        callback();\n        return;\n      }\n    }\n  });\n\n  return observer;\n}\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n"],"names":["Root","Portal","Content","Group","Label","Item","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator","Sub","SubTrigger","SubContent"],"sourceRoot":"","ignoreList":[0,1,2,5,8,9,10,11,12,13,14,15,16,17]}