{"version":3,"file":"static/chunks/3251-2c2c3114c7c60846.js","mappings":"oQAOaA,qCAAAA,KAAN,IAAMA,EAMLC,EAAAA,OAAAA,QALN,MAA6B,EAKvBA,CACgB,CAHA,GAEhBA,kSCSD,SAASC,IAEZ,MAAM,qBAEL,CAFSC,MACP,+GADG,+DAEN,EAOJ,yFAXgBD,qCAAAA,KAFEE,EAjBX,OAiBWA,8BAA8B,GAAC,qgBCpBb,SAAvBC,SAAAA,GAyBGC,WAzBoB,uBAyBc,mBAAlCA,WAzBT,yBACO,oDAAGC,CAAAA,CAAAA,EAAAA,CAAAA,SAAAA,CAAAA,EAAyC,CAAE,mBAExD,GADA,CACI,CADC,aAAIA,GAAAA,EACJC,IAAI,CAAG,4CAHHH,OAAgCF,QAyBtC,SAASG,EACdG,CAAc,EAEd,MAAO,CAAC,CACNA,CAAAA,GAAAA,CAAAA,KAAAA,IAAAA,EAAAA,YACA,GAAOA,CAAAA,EAAAA,CAAAA,GAAU,UACjBA,EAAAA,CAAAA,CAAAA,EAAiBJ,EAAAA,CAAAA,CAAsB,qYC5B9BK,qCAAAA,KAAN,IAAMA,EAAqB,CAChCC,KAAM,WAAO,CACf,ucC2I+B,SAAbC,SAAAA,GA7BAC,CA6Ba,kBA7BM,mBAAnBA,oBAUgB,SAAhBC,SAAAA,OAAgB,eAnDH,SAAlBC,SAAAA,SAAkB,SA2BJ,SAAdC,SAAAA,KAAc,qBA7CQ,SAAtBC,SAAAA,aAAsB,UAoCH,SAAnBC,SAAAA,UAAmB,EAtDX,SAARC,QAAQ,CAARA,YATQ,SAARC,QAAQ,CAARA,0BAsDsB,SAAtBC,SAAAA,GApCAC,UAoCsB,WApCD,mBAArBA,wBAkBoB,SAApBC,SAAAA,KA1Cb,IAAMC,EAAkB,WACtB,MAAM,qBAEL,CAFK,MACJ,sEADI,+DAEN,EACF,EAEaJ,EAOPI,EAEOL,EAOPK,EAEOF,EAOPE,CAxBJC,CA0BWR,EAOPO,CAxBJC,CA0BWF,CAnC4B,CA0CnCC,EAzCA,CAIC,CA8CDA,EAzCA,CAIC,CA8CDA,EAEON,EAOPM,EAnDJC,EA4DID,EAOYX,CA1DhBY,CATuC,CAkBvCA,EAjBI,CAIC,CAIkC,EASA,CARnC,CAIC,CAKD,CAiBJA,CASAA,CAbK,IAIkC,CASA,EARnC,CAsBC,CATA,SAiBWZ,sEAAAA,OAUAC,EAAAA,SAAAA,CAAAA,OAAAA,EAMf,SANeA,CAMf,aAIA,yBAKA,+BAfeA,OAmBAF,EAAAA,SAAAA,CAAAA,IAAAA,WAAAA,sGAAAA,qZC7IFZ,qCAAAA,SAAAA,EAAiBS,CAAc,EAC7C,GAAIiB,CAAAA,EAAAA,EAAAA,iBAAAA,EAAkBjB,IAAUkB,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBlB,GAClD,KAD0D,CACpDA,EAGJA,EAAAA,CAAAA,CAAAA,EAAiBN,QAAS,UAAWM,GACvCT,EAAiBS,EAD6B,KAClB,CAEhC,aAXoC,WACF,udCcK,SAAvBmB,SAAAA,cAAuB,IAST,SAAdC,SAAAA,KAAc,mBAvBH,YACA,OAWvBC,EAA4C,KAEzC,SAASF,EAAwBG,CAAsB,EAC5D,GAAID,MAAmB,GACrB,MAAM,qBAEL,CAFK,MACJ,2EADI,+DAEN,GAEFA,EAASC,EACX,CAEO,SAASF,EACdG,CAAiC,EAEjC,MAAM,MAAoBC,OAAK,CAACC,QAAQ,CAAeF,EAAYG,KAAK,KAAjEA,EAAAA,CAAAA,CAAAA,EAAAA,CAAOC,EAAYH,CAAAA,CAAAA,EAAAA,CAyB1B,EAzBuB,KAqBrBH,EAAW,SAACC,CAAAA,SACVC,EAAYF,QAAQ,CAACC,EAAQK,IAG1BC,CAAAA,EAAAA,EAAAA,UAAAA,EAAWF,GAASG,CAAAA,EAAAA,EAAAA,GAAAA,EAAIH,GAASA,CAC1C","sources":["webpack://_N_E/../../../src/client/components/unstable-rethrow.ts","webpack://_N_E/../../../src/client/components/unauthorized.ts","webpack://_N_E/../../../src/client/components/unrecognized-action-error.ts","webpack://_N_E/../../../src/client/components/unresolved-thenable.ts","webpack://_N_E/../../../src/client/components/segment-cache.ts","webpack://_N_E/../../../src/client/components/unstable-rethrow.browser.ts","webpack://_N_E/../../../src/client/components/use-action-queue.ts"],"sourcesContent":["/**\n * This function should be used to rethrow internal Next.js errors so that they can be handled by the framework.\n * When wrapping an API that uses errors to interrupt control flow, you should use this function before you do any error handling.\n * This function will rethrow the error if it is a Next.js error so it can be handled, otherwise it will do nothing.\n *\n * Read more: [Next.js Docs: `unstable_rethrow`](https://nextjs.org/docs/app/api-reference/functions/unstable_rethrow)\n */\nexport const unstable_rethrow =\n  typeof window === 'undefined'\n    ? (\n        require('./unstable-rethrow.server') as typeof import('./unstable-rethrow.server')\n      ).unstable_rethrow\n    : (\n        require('./unstable-rethrow.browser') as typeof import('./unstable-rethrow.browser')\n      ).unstable_rethrow\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `unauthorized` docs\n/**\n * @experimental\n * This function allows you to render the [unauthorized.js file](https://nextjs.org/docs/app/api-reference/file-conventions/unauthorized)\n * within a route segment as well as inject a tag.\n *\n * `unauthorized()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n *\n * Read more: [Next.js Docs: `unauthorized`](https://nextjs.org/docs/app/api-reference/functions/unauthorized)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};401`\n\nexport function unauthorized(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`unauthorized()\\` is experimental and only allowed to be used when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","export class UnrecognizedActionError extends Error {\n  constructor(...args: ConstructorParameters<typeof Error>) {\n    super(...args)\n    this.name = 'UnrecognizedActionError'\n  }\n}\n\n/**\n * Check whether a server action call failed because the server action was not recognized by the server.\n * This can happen if the client and the server are not from the same deployment.\n *\n * Example usage:\n * ```ts\n * try {\n *   await myServerAction();\n * } catch (err) {\n *   if (unstable_isUnrecognizedActionError(err)) {\n *     // The client is from a different deployment than the server.\n *     // Reloading the page will fix this mismatch.\n *     window.alert(\"Please refresh the page and try again\");\n *     return;\n *   }\n * }\n * ```\n * */\nexport function unstable_isUnrecognizedActionError(\n  error: unknown\n): error is UnrecognizedActionError {\n  return !!(\n    error &&\n    typeof error === 'object' &&\n    error instanceof UnrecognizedActionError\n  )\n}\n","/**\n * Create a \"Thenable\" that does not resolve. This is used to suspend indefinitely when data is not available yet.\n */\nexport const unresolvedThenable = {\n  then: () => {},\n} as PromiseLike<void>\n","/**\n * Entry point to the Segment Cache implementation.\n *\n * All code related to the Segment Cache lives `segment-cache-impl` directory.\n * Callers access it through this indirection.\n *\n * This is to ensure the code is dead code eliminated from the bundle if the\n * flag is disabled.\n *\n * TODO: This is super tedious. Since experimental flags are an essential part\n * of our workflow, we should establish a better pattern for dead code\n * elimination. Ideally it would be done at the bundler level, like how React's\n * build process works. In the React repo, you don't even need to add any extra\n * configuration per experiment â€” if the code is not reachable, it gets stripped\n * from the build automatically by Rollup. Or, shorter term, we could stub out\n * experimental modules at build time by updating the build config, i.e. a more\n * automated version of what I'm doing manually in this file.\n */\n\nexport type { NavigationResult } from './segment-cache-impl/navigation'\nexport type { PrefetchTask } from './segment-cache-impl/scheduler'\nexport type { NormalizedSearch } from './segment-cache-impl/cache-key'\n\nconst notEnabled: any = () => {\n  throw new Error(\n    'Segment Cache experiment is not enabled. This is a bug in Next.js.'\n  )\n}\n\nexport const prefetch: typeof import('./segment-cache-impl/prefetch').prefetch =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/prefetch') as typeof import('./segment-cache-impl/prefetch')\n        ).prefetch(...args)\n      }\n    : notEnabled\n\nexport const navigate: typeof import('./segment-cache-impl/navigation').navigate =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/navigation') as typeof import('./segment-cache-impl/navigation')\n        ).navigate(...args)\n      }\n    : notEnabled\n\nexport const revalidateEntireCache: typeof import('./segment-cache-impl/cache').revalidateEntireCache =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')\n        ).revalidateEntireCache(...args)\n      }\n    : notEnabled\n\nexport const getCurrentCacheVersion: typeof import('./segment-cache-impl/cache').getCurrentCacheVersion =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/cache') as typeof import('./segment-cache-impl/cache')\n        ).getCurrentCacheVersion(...args)\n      }\n    : notEnabled\n\nexport const schedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').schedulePrefetchTask =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).schedulePrefetchTask(...args)\n      }\n    : notEnabled\n\nexport const cancelPrefetchTask: typeof import('./segment-cache-impl/scheduler').cancelPrefetchTask =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).cancelPrefetchTask(...args)\n      }\n    : notEnabled\n\nexport const reschedulePrefetchTask: typeof import('./segment-cache-impl/scheduler').reschedulePrefetchTask =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).reschedulePrefetchTask(...args)\n      }\n    : notEnabled\n\nexport const isPrefetchTaskDirty: typeof import('./segment-cache-impl/scheduler').isPrefetchTaskDirty =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/scheduler') as typeof import('./segment-cache-impl/scheduler')\n        ).isPrefetchTaskDirty(...args)\n      }\n    : notEnabled\n\nexport const createCacheKey: typeof import('./segment-cache-impl/cache-key').createCacheKey =\n  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? function (...args) {\n        return (\n          require('./segment-cache-impl/cache-key') as typeof import('./segment-cache-impl/cache-key')\n        ).createCacheKey(...args)\n      }\n    : notEnabled\n\n/**\n * Below are public constants. They're small enough that we don't need to\n * DCE them.\n */\n\nexport const enum NavigationResultTag {\n  MPA,\n  Success,\n  NoOp,\n  Async,\n}\n\n/**\n * The priority of the prefetch task. Higher numbers are higher priority.\n */\nexport const enum PrefetchPriority {\n  /**\n   * Assigned to the most recently hovered/touched link. Special network\n   * bandwidth is reserved for this task only. There's only ever one Intent-\n   * priority task at a time; when a new Intent task is scheduled, the previous\n   * one is bumped down to Default.\n   */\n  Intent = 2,\n  /**\n   * The default priority for prefetch tasks.\n   */\n  Default = 1,\n  /**\n   * Assigned to tasks when they spawn non-blocking background work, like\n   * revalidating a partially cached entry to see if more data is available.\n   */\n  Background = 0,\n}\n\nexport const enum FetchStrategy {\n  // Deliberately ordered so we can easily compare two segments\n  // and determine if one segment is \"more specific\" than another\n  // (i.e. if it's likely that it contains more data)\n  LoadingBoundary = 0,\n  PPR = 1,\n  PPRRuntime = 2,\n  Full = 3,\n}\n\n/**\n * A subset of fetch strategies used for prefetch tasks.\n * A prefetch task can't know if it should use `PPR` or `LoadingBoundary`\n * until we complete the initial tree prefetch request, so we use `PPR` to signal both cases\n * and adjust it based on the route when actually fetching.\n * */\nexport type PrefetchTaskFetchStrategy =\n  | FetchStrategy.PPR\n  | FetchStrategy.PPRRuntime\n  | FetchStrategy.Full\n","import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isNextRouterError } from './is-next-router-error'\n\nexport function unstable_rethrow(error: unknown): void {\n  if (isNextRouterError(error) || isBailoutToCSRError(error)) {\n    throw error\n  }\n\n  if (error instanceof Error && 'cause' in error) {\n    unstable_rethrow(error.cause)\n  }\n}\n","import type { Dispatch } from 'react'\nimport React, { use } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport type { AppRouterActionQueue } from './app-router-instance'\nimport type {\n  AppRouterState,\n  ReducerActions,\n  ReducerState,\n} from './router-reducer/router-reducer-types'\n\n// The app router state lives outside of React, so we can import the dispatch\n// method directly wherever we need it, rather than passing it around via props\n// or context.\nlet dispatch: Dispatch<ReducerActions> | null = null\n\nexport function dispatchAppRouterAction(action: ReducerActions) {\n  if (dispatch === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  dispatch(action)\n}\n\nexport function useActionQueue(\n  actionQueue: AppRouterActionQueue\n): AppRouterState {\n  const [state, setState] = React.useState<ReducerState>(actionQueue.state)\n\n  // Because of a known issue that requires to decode Flight streams inside the\n  // render phase, we have to be a bit clever and assign the dispatch method to\n  // a module-level variable upon initialization. The useState hook in this\n  // module only exists to synchronize state that lives outside of React.\n  // Ideally, what we'd do instead is pass the state as a prop to root.render;\n  // this is conceptually how we're modeling the app router state, despite the\n  // weird implementation details.\n  if (process.env.NODE_ENV !== 'production') {\n    const { useAppDevRenderingIndicator } =\n      require('../../next-devtools/userspace/use-app-dev-rendering-indicator') as typeof import('../../next-devtools/userspace/use-app-dev-rendering-indicator')\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const appDevRenderingIndicator = useAppDevRenderingIndicator()\n\n    dispatch = (action: ReducerActions) => {\n      appDevRenderingIndicator(() => {\n        actionQueue.dispatch(action, setState)\n      })\n    }\n  } else {\n    dispatch = (action: ReducerActions) =>\n      actionQueue.dispatch(action, setState)\n  }\n\n  return isThenable(state) ? use(state) : state\n}\n"],"names":["unstable_rethrow","require","unauthorized","Error","HTTP_ERROR_FALLBACK_ERROR_CODE","UnrecognizedActionError","unstable_isUnrecognizedActionError","args","name","error","unresolvedThenable","then","FetchStrategy","NavigationResultTag","PrefetchPriority","cancelPrefetchTask","createCacheKey","getCurrentCacheVersion","isPrefetchTaskDirty","navigate","prefetch","reschedulePrefetchTask","revalidateEntireCache","schedulePrefetchTask","notEnabled","process","isNextRouterError","isBailoutToCSRError","dispatchAppRouterAction","useActionQueue","dispatch","action","actionQueue","React","useState","state","setState","isThenable","use"],"sourceRoot":"","ignoreList":[]}