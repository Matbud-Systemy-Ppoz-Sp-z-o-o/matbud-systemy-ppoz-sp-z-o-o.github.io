{"version":3,"file":"static/chunks/207-abc0792b26e05048.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts","webpack://_N_E/../../../../src/client/components/router-reducer/handle-mutable.ts","webpack://_N_E/../../../../src/client/components/router-reducer/aliased-prefetch-navigations.ts","webpack://_N_E/../../../../src/client/components/router-reducer/create-href-from-url.ts","webpack://_N_E/../../../../src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts","webpack://_N_E/../../../../src/client/components/router-reducer/fetch-server-response.ts","webpack://_N_E/../../../../src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","webpack://_N_E/../../../../src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts","webpack://_N_E/../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts","webpack://_N_E/../../../../src/client/components/router-reducer/create-initial-router-state.ts","webpack://_N_E/../../../../src/client/components/router-reducer/create-router-cache-key.ts","webpack://_N_E/../../../../src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts","webpack://_N_E/../../../../src/client/components/router-reducer/apply-flight-data.ts","webpack://_N_E/../../../../src/client/components/router-reducer/compute-changed-path.ts","webpack://_N_E/../../../../src/client/components/router-reducer/invalidate-cache-by-router-state.ts","webpack://_N_E/../../../../src/client/components/router-reducer/handle-segment-mismatch.ts","webpack://_N_E/../../../src/client/components/render-from-template-context.tsx"],"sourcesContent":["import type { FlightSegmentPath } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.\n */\nexport function clearCacheNodeDataForSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n\n  const [parallelRouteKey, segment] = flightSegmentPath\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  // In case of last segment start off the fetch at this level and don't copy further down.\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      })\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      })\n    }\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  return clearCacheNodeDataForSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: isNotUndefined(mutable.canonicalUrl)\n      ? mutable.canonicalUrl === state.canonicalUrl\n        ? state.canonicalUrl\n        : mutable.canonicalUrl\n      : state.canonicalUrl,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    prefetchCache: mutable.prefetchCache\n      ? mutable.prefetchCache\n      : state.prefetchCache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n  }\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { createEmptyCacheNode } from '../app-router'\nimport { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'\nimport { handleMutable } from './handle-mutable'\nimport { generateSegmentsFromPatch } from './reducers/navigate-reducer'\nimport type { Mutable, ReadonlyReducerState } from './router-reducer-types'\n\n/**\n * This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added\n * to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.\n * This function takes the aliased entry and only applies the loading state to the updated cache node.\n * We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a\n * more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.\n */\nexport function handleAliasedPrefetchEntry(\n  navigatedAt: number,\n  state: ReadonlyReducerState,\n  flightData: string | NormalizedFlightData[],\n  url: URL,\n  mutable: Mutable\n) {\n  let currentTree = state.tree\n  let currentCache = state.cache\n  const href = createHrefFromUrl(url)\n  let applied\n  let scrollableSegments: FlightSegmentPath[] = []\n\n  if (typeof flightData === 'string') {\n    return false\n  }\n\n  for (const normalizedFlightData of flightData) {\n    // If the segment doesn't have a loading component, we don't need to do anything.\n    if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {\n      continue\n    }\n\n    let treePatch = normalizedFlightData.tree\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    const { seedData, isRootRender, pathToSegment } = normalizedFlightData\n    // TODO-APP: remove ''\n    const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]\n\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    let newTree = applyRouterStatePatchToTree(\n      flightSegmentPathWithLeadingEmpty,\n      currentTree,\n      treePatch,\n      href\n    )\n\n    const newCache = createEmptyCacheNode()\n\n    // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the\n    // loading state and not the actual parallel route seed data.\n    if (isRootRender && seedData) {\n      // Fill in the cache with the new loading / rsc data\n      const rsc = seedData[1]\n      const loading = seedData[3]\n      newCache.loading = loading\n      newCache.rsc = rsc\n\n      // Construct a new tree and apply the aliased loading state for each parallel route\n      fillNewTreeWithOnlyLoadingSegments(\n        navigatedAt,\n        newCache,\n        currentCache,\n        treePatch,\n        seedData\n      )\n    } else {\n      // Copy rsc for the root node of the cache.\n      newCache.rsc = currentCache.rsc\n      newCache.prefetchRsc = currentCache.prefetchRsc\n      newCache.loading = currentCache.loading\n      newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n      // copy the loading state only into the leaf node (the part that changed)\n      fillCacheWithNewSubTreeDataButOnlyLoading(\n        navigatedAt,\n        newCache,\n        currentCache,\n        normalizedFlightData\n      )\n    }\n\n    // If we don't have an updated tree, there's no reason to update the cache, as the tree\n    // dictates what cache nodes to render.\n    if (newTree) {\n      currentTree = newTree\n      currentCache = newCache\n      applied = true\n    }\n\n    for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n      const scrollableSegmentPath = [\n        ...normalizedFlightData.pathToSegment,\n        ...subSegment,\n      ]\n      // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n      if (\n        scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n        DEFAULT_SEGMENT_KEY\n      ) {\n        scrollableSegments.push(scrollableSegmentPath)\n      }\n    }\n  }\n\n  if (!applied) {\n    return false\n  }\n\n  mutable.patchedTree = currentTree\n  mutable.cache = currentCache\n  mutable.canonicalUrl = href\n  mutable.hashFragment = url.hash\n  mutable.scrollableSegments = scrollableSegments\n\n  return handleMutable(state, mutable)\n}\n\nfunction hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {\n  if (!seedData) return false\n\n  const parallelRoutes = seedData[2]\n  const loading = seedData[3]\n\n  if (loading) {\n    return true\n  }\n\n  for (const key in parallelRoutes) {\n    if (hasLoadingComponentInSeedData(parallelRoutes[key])) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction fillNewTreeWithOnlyLoadingSegments(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null\n) {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    return\n  }\n\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const rsc = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        // copy the layout but null the page segment as that's not meant to be used\n        rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillNewTreeWithOnlyLoadingSegments(\n      navigatedAt,\n      newCacheNode,\n      existingCache,\n      parallelRouteState,\n      parallelSeedData\n    )\n  }\n}\n\n/**\n * Add search params to the page segments in the flight router state\n * Page segments that are associated with search params have a page segment key\n * followed by a query string. This function will add those params to the page segment.\n * This is useful if we return an aliased prefetch entry (ie, won't have search params)\n * but the canonical router URL has search params.\n */\nexport function addSearchParamsToPageSegments(\n  flightRouterState: FlightRouterState,\n  searchParams: Record<string, string | string[] | undefined>\n): FlightRouterState {\n  const [segment, parallelRoutes, ...rest] = flightRouterState\n\n  // If it's a page segment, modify the segment by adding search params\n  if (segment.includes(PAGE_SEGMENT_KEY)) {\n    const newSegment = addSearchParamsIfPageSegment(segment, searchParams)\n    return [newSegment, parallelRoutes, ...rest]\n  }\n\n  // Otherwise, recurse through the parallel routes and return a new tree\n  const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}\n\n  for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {\n    updatedParallelRoutes[key] = addSearchParamsToPageSegments(\n      parallelRoute,\n      searchParams\n    )\n  }\n\n  return [segment, updatedParallelRoutes, ...rest]\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n} from './router-reducer-types'\n\nexport function fillLazyItemsTillLeafWithHead(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode,\n  prefetchEntry: PrefetchCacheEntry | undefined\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        const hasReusablePrefetch =\n          prefetchEntry?.kind === 'auto' &&\n          prefetchEntry.status === PrefetchCacheEntryStatus.reusable\n\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[1]\n          const loading = parallelSeedData[3]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior â€” no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            navigatedAt,\n          }\n        } else if (hasReusablePrefetch && existingCacheNode) {\n          // No new data was sent from the server, but the existing cache node\n          // was prefetched, so we should reuse that.\n          newCacheNode = {\n            lazyData: existingCacheNode.lazyData,\n            rsc: existingCacheNode.rsc,\n            // This is a PPR-only field. Unlike the previous branch, since we're\n            // just cloning the existing cache node, we might as well keep the\n            // PPR value, if it exists.\n            prefetchRsc: existingCacheNode.prefetchRsc,\n            head: existingCacheNode.head,\n            prefetchHead: existingCacheNode.prefetchHead,\n            parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n            loading: existingCacheNode.loading,\n          } as CacheNode\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n            navigatedAt,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          navigatedAt,\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head,\n          prefetchEntry\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head,\n      prefetchEntry\n    )\n  }\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport { urlToUrlWithoutFlightMarker } from '../../route-params'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\nexport type FetchServerResponseResult = {\n  flightData: NormalizedFlightData[] | string\n  canonicalUrl: URL | undefined\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n}\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return {\n    flightData: urlToUrlWithoutFlightMarker(\n      new URL(url, location.origin)\n    ).toString(),\n    canonicalUrl: undefined,\n    couldBeIntercepted: false,\n    prerendered: false,\n    postponed: false,\n    staleTime: -1,\n  }\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    const res = await createFetch(\n      url,\n      headers,\n      fetchPriority,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const flightStream = postponed\n      ? createUnclosingPrefetchStream(res.body)\n      : res.body\n    const response = await (createFromNextReadableStream(\n      flightStream\n    ) as Promise<NavigationFlightResponse>)\n\n    if (getAppBuildId() !== response.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    return {\n      flightData: normalizeFlightData(response.f),\n      canonicalUrl: canonicalUrl,\n      couldBeIntercepted: interception,\n      prerendered: response.S,\n      postponed,\n      staleTime,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return {\n      flightData: url.toString(),\n      canonicalUrl: undefined,\n      couldBeIntercepted: false,\n      prerendered: false,\n      postponed: false,\n      staleTime: -1,\n    }\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n}\n\nexport async function createFetch(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  signal?: AbortSignal\n): Promise<RSCResponse> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let browserResponse = await fetch(fetchUrl, fetchOptions)\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid â€” when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      browserResponse = await fetch(fetchUrl, fetchOptions)\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<unknown> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { Segment } from '../../../server/app-render/types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry: PrefetchCacheEntry | undefined,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const incomingSegment = cacheNodeSeedData[0]\n        const rsc = cacheNodeSeedData[1]\n        const loading = cacheNodeSeedData[3]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc:\n            fillLazyItems || incomingSegment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n          navigatedAt,\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            prefetchEntry\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(\n    navigatedAt,\n    newCache,\n    existingCache,\n    flightData,\n    prefetchEntry,\n    true\n  )\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(\n    navigatedAt,\n    newCache,\n    existingCache,\n    flightData,\n    prefetchEntry,\n    false\n  )\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightDataPath } from '../../../server/app-render/types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\nimport {\n  createSeededPrefetchCacheEntry,\n  STATIC_STALETIME_MS,\n} from './prefetch-cache-utils'\nimport { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n  couldBeIntercepted: boolean\n  postponed: boolean\n  prerendered: boolean\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialParallelRoutes,\n  location,\n  couldBeIntercepted,\n  postponed,\n  prerendered,\n}: InitialRouterStateParameters) {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n  const rsc = initialSeedData?.[1]\n  const loading = initialSeedData?.[3] ?? null\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: initialParallelRoutes,\n    loading,\n    navigatedAt,\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  const prefetchCache = new Map<string, PrefetchCacheEntry>()\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead,\n      undefined\n    )\n  }\n\n  const initialState = {\n    tree: initialTree,\n    cache,\n    prefetchCache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n  }\n\n  if (process.env.NODE_ENV !== 'development' && location) {\n    // Seed the prefetch cache with this page's data.\n    // This is to prevent needlessly re-prefetching a page that is already reusable,\n    // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n    // We don't currently do this in development because links aren't prefetched in development\n    // so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page\n    // was loaded first.\n    const url = new URL(\n      `${location.pathname}${location.search}`,\n      location.origin\n    )\n\n    createSeededPrefetchCacheEntry({\n      url,\n      data: {\n        flightData: [normalizedFlightData],\n        canonicalUrl: undefined,\n        couldBeIntercepted: !!couldBeIntercepted,\n        prerendered,\n        postponed,\n        // TODO: The initial RSC payload includes both static and dynamic data\n        // in the same response, even if PPR is enabled. So if there's any\n        // dynamic data at all, we can't set a stale time. In the future we may\n        // add a way to split a single Flight stream into static and dynamic\n        // parts. But in the meantime we should at least make this work for\n        // fully static pages.\n        staleTime:\n          // In the old router, there was only a single configurable staleTime (experimental.staleTimes)\n          // As an abundance of caution, this will only set the initial staleTime to the configured value\n          // if we're not leveraging the segment cache, which has its own prefetching semantics.\n          prerendered && !process.env.__NEXT_CLIENT_SEGMENT_CACHE\n            ? STATIC_STALETIME_MS\n            : -1,\n      },\n      tree: initialState.tree,\n      prefetchCache: initialState.prefetchCache,\n      nextUrl: initialState.nextUrl,\n      kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,\n    })\n  }\n\n  return initialState\n}\n","import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightSegmentPath } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\n\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\nexport function invalidateCacheBelowFlightSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n  const [parallelRouteKey, segment] = flightSegmentPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  // In case of last entry don't copy further down.\n  if (isLastEntry) {\n    childSegmentMap.delete(cacheKey)\n    return\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  invalidateCacheBelowFlightSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  navigatedAt: number,\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[1]\n    const loading = seedData[3]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior â€” no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head,\n      prefetchEntry\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(\n      navigatedAt,\n      cache,\n      existingCache,\n      flightData,\n      prefetchEntry\n    )\n  }\n\n  return true\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../server/app-render/types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightRouterState } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n"],"names":["clearCacheNodeDataForSegmentPath","newCache","existingCache","flightSegmentPath","isLastEntry","length","parallelRouteKey","segment","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","lazyData","rsc","prefetchRsc","head","prefetchHead","loading","navigatedAt","getNextFlightSegmentPath","handleMutable","isNotUndefined","value","state","mutable","shouldScroll","nextUrl","patchedTree","changedPath","computeChangedPath","tree","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","prefetchCache","addSearchParamsToPageSegments","handleAliasedPrefetchEntry","flightData","url","currentTree","currentCache","href","createHrefFromUrl","applied","normalizedFlightData","hasLoadingComponentInSeedData","seedData","key","treePatch","Object","fromEntries","searchParams","isRootRender","pathToSegment","flightSegmentPathWithLeadingEmpty","newTree","applyRouterStatePatchToTree","createEmptyCacheNode","fillNewTreeWithOnlyLoadingSegments","routerState","cacheNodeSeedData","isLastSegment","keys","parallelRouteState","segmentForParallelRoute","parallelSeedData","undefined","newCacheNode","includes","PAGE_SEGMENT_KEY","existingParallelRoutes","fillCacheWithNewSubTreeDataButOnlyLoading","generateSegmentsFromPatch","subSegment","scrollableSegmentPath","DEFAULT_SEGMENT_KEY","push","hash","flightRouterState","rest","addSearchParamsIfPageSegment","updatedParallelRoutes","entries","parallelRoute","includeHash","pathname","search","fillLazyItemsTillLeafWithHead","prefetchEntry","existingParallelRoutesCacheNode","hasReusablePrefetch","kind","status","PrefetchCacheEntryStatus","reusable","parallelRouteCacheNode","existingCacheNode","seedNode","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","doMpaNavigation","urlToUrlWithoutFlightMarker","URL","location","origin","toString","couldBeIntercepted","prerendered","postponed","staleTime","abortController","AbortController","options","prefetchKind","res","fetchPriority","contentType","interception","staleTimeHeaderSeconds","isFlightResponse","response","err","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","PrefetchKind","AUTO","NEXT_ROUTER_PREFETCH_HEADER","NEXT_URL","TEMPORARY","endsWith","signal","responseUrl","redirected","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","parseInt","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","process","env","reader","getReader","flightStream","ReadableStream","pull","read","done","controller","enqueue","getAppBuildId","b","normalizeFlightData","f","S","aborted","fetchOptions","fetchUrl","browserResponse","MAX_REDIRECTS","n","rscResponse","credentials","priority","setCacheBustingSearchParam","fetch","NEXT_RSC_UNION_QUERY","delete","callServer","findSourceMapURL","window","addEventListener","abort","isNavigatingToNewRootLayout","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","values","nextTreeChild","fillCacheWithNewSubTreeData","fillCacheHelper","fillLazyItems","segmentPath","i","incomingSegment","invalidateCacheByRouterState","path","parallelRoutePatch","refetch","isRootLayout","applyPatch","addRefreshMarkerToActiveParallelSegments","currentSegment","matchSegment","lastSegment","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","newParallelRoutes","createInitialRouterState","initialSeedData","extractPathFromFlightRouterState","initialFlightData","initialCanonicalUrlParts","initialCanonicalUrl","join","getFlightDataPartsFromPath","initialHead","size","initialState","createSeededPrefetchCacheEntry","data","STATIC_STALETIME_MS","FULL","withoutSearchParameters","invalidateCacheBelowFlightSegmentPath","applyFlightData","getSelectedParams","params","isDynamicParameter","segmentValue","split","segmentToPathname","normalizeSegments","segments","reduce","acc","isGroupSegment","INTERCEPTION_ROUTE_MARKERS","some","m","childrenPath","children","childPath","treeA","treeB","computeChangedPathImpl","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","handleSegmentMismatch","action","handleExternalUrl","RenderFromTemplateContext","useContext","TemplateContext"],"sourceRoot":"","ignoreList":[]}