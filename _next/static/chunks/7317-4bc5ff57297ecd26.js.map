{"version":3,"file":"static/chunks/7317-4bc5ff57297ecd26.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/ppr-navigations.ts"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  HeadData,\n  LoadingModuleData,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './prefetch-cache-utils'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched — due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server — for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment — a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation — but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[1]\n    loading = prefetchData[3]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[4]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for — everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    ({ flightData }: FetchServerResponseResult) => {\n      if (typeof flightData === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[2]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety — it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[2]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[1]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: SPANavigationTask, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n"],"names":["abortTask","listenForDynamicRequest","startPPRNavigation","updateCacheNodeOnPopstateRestoration","oldCacheNode","routerState","routerStateChildren","oldParallelRoutes","parallelRoutes","newParallelRoutes","Map","parallelRouteKey","routerStateChild","segmentChild","segmentKeyChild","createRouterCacheKey","oldSegmentMapChild","get","undefined","oldCacheNodeChild","newCacheNodeChild","newSegmentMapChild","set","rsc","shouldUsePrefetch","isDeferredRsc","status","lazyData","head","prefetchHead","prefetchRsc","loading","navigatedAt","MPA_NAVIGATION_TASK","route","node","dynamicRequestTree","children","oldRouterState","newRouterState","prefetchData","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","updateCacheNodeOnNavigation","didFindRootLayout","segmentPath","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","isRootLayout","prefetchParallelRoutes","patchedRouterStateChildren","taskChildren","needsDynamicRequest","dynamicRequestTreeChildren","newRouterStateChild","oldRouterStateChild","prefetchDataChild","newSegmentChild","newSegmentPathChild","concat","newSegmentKeyChild","oldSegmentChild","taskChild","DEFAULT_SEGMENT_KEY","spawnReusedTask","reusedRouterState","beginRenderingNewRouteTree","Object","keys","length","matchSegment","taskChildRoute","dynamicRequestTreeChild","newCacheNode","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","isNavigatingToNewRootLayout","createCacheNodeOnNavigation","cacheNodeNavigatedAt","isLeafSegment","DYNAMIC_STALETIME_MS","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","push","existingSegmentMapChild","segmentPathChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","task","responsePromise","then","flightData","normalizedFlightData","serverRouterState","tree","seedData","dynamicHead","dynamicData","writeDynamicDataIntoPendingTask","rootTask","i","segment","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","cacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","resolve","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","error","values","reject","DEFERRED","Symbol","value","tag","pendingRsc","Promise","res","rej","fulfilledRsc","rejectedRsc","reason"],"sourceRoot":"","ignoreList":[]}