{"version":3,"file":"static/chunks/8296-050f0dcd5743470b.js","mappings":"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","sources":["webpack://_N_E/../../src/client/app-next.ts","webpack://_N_E/../../../src/client/components/app-router-instance.ts","webpack://_N_E/../../../src/client/components/client-page.tsx","webpack://_N_E/../../../src/client/components/app-router-headers.ts","webpack://_N_E/../../../src/client/components/app-router-announcer.tsx","webpack://_N_E/../../../src/client/components/forbidden.ts","webpack://_N_E/../../../src/client/components/links.ts","webpack://_N_E/../../../../src/client/components/http-access-fallback/error-boundary.tsx","webpack://_N_E/../../src/client/assign-location.ts","webpack://_N_E/../../../src/client/components/is-next-router-error.ts","webpack://_N_E/../../../src/client/components/handle-isr-error.tsx","webpack://_N_E/../../../../src/client/components/http-access-fallback/http-access-fallback.ts","webpack://_N_E/../../../../src/client/components/builtin/global-error.tsx","webpack://_N_E/../../../src/client/components/app-router.tsx","webpack://_N_E/../../../../src/client/components/errors/graceful-degrade-boundary.tsx","webpack://_N_E/../../../src/client/components/client-segment.tsx","webpack://_N_E/../../src/client/app-webpack.ts","webpack://_N_E/../../../src/client/components/error-boundary.tsx","webpack://_N_E/../../../../src/client/components/errors/root-error-boundary.tsx","webpack://_N_E/../../../src/client/components/bfcache.ts","webpack://_N_E/../../../src/client/components/layout-router.tsx"],"sourcesContent":["// This import must go first because it needs to patch webpack chunk loading\n// before React patches chunk loading.\nimport './app-webpack'\nimport { appBootstrap } from './app-bootstrap'\n\nconst instrumentationHooks =\n  // eslint-disable-next-line @next/internal/typechecked-require -- not a module\n  require('../lib/require-instrumentation-client')\n\nappBootstrap(() => {\n  const { hydrate } = require('./app-index') as typeof import('./app-index')\n  // Include app-router and layout-router in the main chunk\n  // eslint-disable-next-line @next/internal/typechecked-require -- Why not relative imports?\n  require('next/dist/client/components/app-router')\n  // eslint-disable-next-line @next/internal/typechecked-require -- Why not relative imports?\n  require('next/dist/client/components/layout-router')\n  hydrate(instrumentationHooks)\n})\n","import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  ACTION_PREFETCH,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  prefetch as prefetchWithSegmentCache,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { createPrefetchURL, isExternalURL } from './app-router'\nimport { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { FlightRouterState } from '../../server/app-render/types'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    } else {\n      // No more actions are pending, check if a refresh is needed\n      if (actionQueue.needsRefresh) {\n        actionQueue.needsRefresh = false\n        actionQueue.dispatch(\n          {\n            type: ACTION_REFRESH,\n            origin: window.location.origin,\n          },\n          setState\n        )\n      }\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    // if the pending action was a server action, mark the queue as needing a refresh once events are processed\n    if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {\n      actionQueue.needsRefresh = true\n    }\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n    allowAliasing: true,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  tree: FlightRouterState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    tree,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch: process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? // Unlike the old implementation, the Segment Cache doesn't store its\n      // data in the router reducer state; it writes into a global mutable\n      // cache. So we don't need to dispatch an action.\n      (href: string, options?: PrefetchOptions) => {\n        const actionQueue = getAppRouterActionQueue()\n        const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n        // This will be possible when we update its API to not take a PrefetchKind.\n        let fetchStrategy: PrefetchTaskFetchStrategy\n        switch (prefetchKind) {\n          case PrefetchKind.AUTO: {\n            // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n            fetchStrategy = FetchStrategy.PPR\n            break\n          }\n          case PrefetchKind.FULL: {\n            fetchStrategy = FetchStrategy.Full\n            break\n          }\n          case PrefetchKind.TEMPORARY: {\n            // This concept doesn't exist in the segment cache implementation.\n            return\n          }\n          default: {\n            prefetchKind satisfies never\n            // Despite typescript thinking that this can't happen,\n            // we might get an unexpected value from user code.\n            // We don't know what they want, but we know they want a prefetch,\n            // so use the default.\n            fetchStrategy = FetchStrategy.PPR\n          }\n        }\n\n        prefetchWithSegmentCache(\n          href,\n          actionQueue.state.nextUrl,\n          actionQueue.state.tree,\n          fetchStrategy,\n          options?.onInvalidate ?? null\n        )\n      }\n    : (href: string, options?: PrefetchOptions) => {\n        // Use the old prefetch implementation.\n        const actionQueue = getAppRouterActionQueue()\n        const url = createPrefetchURL(href)\n        if (url !== null) {\n          // The prefetch reducer doesn't actually update any state or\n          // trigger a rerender. It just writes to a mutable cache. So we\n          // shouldn't bother calling setState/dispatch; we can just re-run\n          // the reducer directly using the current state.\n          // TODO: Refactor this away from a \"reducer\" so it's\n          // less confusing.\n          prefetchReducer(actionQueue.state, {\n            type: ACTION_PREFETCH,\n            url,\n            kind: options?.kind ?? PrefetchKind.FULL,\n          })\n        }\n      },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n        origin: window.location.origin,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n          origin: window.location.origin,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\n","import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../server/app-render/types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","import type { FlightRouterState } from '../../server/app-render/types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { getCurrentAppRouterState } from './app-router-instance'\nimport { createPrefetchURL } from './app-router'\nimport {\n  FetchStrategy,\n  isPrefetchTaskDirty,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache'\nimport { createCacheKey } from './segment-cache'\nimport {\n  type PrefetchTask,\n  PrefetchPriority,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n} from './segment-cache'\nimport { startTransition } from 'react'\nimport { PrefetchKind } from './router-reducer/router-reducer-types'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  try {\n    return createPrefetchURL(href)\n  } catch {\n    // createPrefetchURL sometimes throws an error if an invalid URL is\n    // provided, though I'm not sure if it's actually necessary.\n    // TODO: Consider removing the throw from the inner function, or change it\n    // to reportError. Or maybe the error isn't even necessary for automatic\n    // prefetches, just navigations.\n    const reportErrorFn =\n      typeof reportError === 'function' ? reportError : console.error\n    reportErrorFn(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  const existingPrefetchTask = instance.prefetchTask\n\n  if (!instance.isVisible) {\n    // Cancel any in-progress prefetch task. (If it already finished then this\n    // is a no-op.)\n    if (existingPrefetchTask !== null) {\n      cancelPrefetchTask(existingPrefetchTask)\n    }\n    // We don't need to reset the prefetchTask to null upon cancellation; an\n    // old task object can be rescheduled with reschedulePrefetchTask. This is a\n    // micro-optimization but also makes the code simpler (don't need to\n    // worry about whether an old task object is stale).\n    return\n  }\n\n  if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // The old prefetch implementation does not have different priority levels.\n    // Just schedule a new prefetch task.\n    prefetchWithOldCacheImplementation(instance)\n    return\n  }\n\n  const appRouterState = getCurrentAppRouterState()\n  if (appRouterState !== null) {\n    const treeAtTimeOfPrefetch = appRouterState.tree\n    if (existingPrefetchTask === null) {\n      // Initiate a prefetch task.\n      const nextUrl = appRouterState.nextUrl\n      const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n      instance.prefetchTask = scheduleSegmentPrefetchTask(\n        cacheKey,\n        treeAtTimeOfPrefetch,\n        instance.fetchStrategy,\n        priority,\n        null\n      )\n    } else {\n      // We already have an old task object that we can reschedule. This is\n      // effectively the same as canceling the old task and creating a new one.\n      reschedulePrefetchTask(\n        existingPrefetchTask,\n        treeAtTimeOfPrefetch,\n        instance.fetchStrategy,\n        priority\n      )\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n\nfunction prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {\n  // This is the path used when the Segment Cache is not enabled.\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  const doPrefetch = async () => {\n    // note that `appRouter.prefetch()` is currently sync,\n    // so we have to wrap this call in an async function to be able to catch() errors below.\n\n    let prefetchKind: PrefetchKind\n    switch (instance.fetchStrategy) {\n      case FetchStrategy.PPR: {\n        prefetchKind = PrefetchKind.AUTO\n        break\n      }\n      case FetchStrategy.Full: {\n        prefetchKind = PrefetchKind.FULL\n        break\n      }\n      case FetchStrategy.PPRRuntime: {\n        // We can only get here if Client Segment Cache is off, and in that case\n        // it shouldn't be possible for a link to request a runtime prefetch.\n        throw new InvariantError(\n          'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'\n        )\n      }\n      default: {\n        instance.fetchStrategy satisfies never\n        // Unreachable, but otherwise typescript will consider the variable unassigned\n        prefetchKind = undefined!\n      }\n    }\n\n    return instance.router.prefetch(instance.prefetchHref, {\n      kind: prefetchKind,\n    })\n  }\n\n  // Prefetch the page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n  doPrefetch().catch((err) => {\n    if (process.env.NODE_ENV !== 'production') {\n      // rethrow to show invalid URL errors\n      throw err\n    }\n  })\n}\n","'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  children: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n","import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isRevalidate || store?.isStaticGeneration) {\n      console.error(error)\n      throw error\n    }\n  }\n\n  return null\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n","'use client'\n\nimport React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-context.shared-runtime'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type { AppRouterState } from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport type { FlightRouterState } from '../../server/app-render/types'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl } = appRouterState\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: tree,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n      pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n    }\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nexport function createEmptyCacheNode(): CacheNode {\n  return {\n    lazyData: null,\n    rsc: null,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    parallelRoutes: new Map(),\n    loading: null,\n    navigatedAt: -1,\n  }\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  assetPrefix,\n  globalError,\n}: {\n  actionQueue: AppRouterActionQueue\n  assetPrefix: string\n  globalError: GlobalErrorState\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const { cache, prefetchCache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        prefetchCache,\n        tree,\n      }\n    }, [cache, prefetchCache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const tree: FlightRouterState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          tree,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader assetPrefix={assetPrefix} globalError={globalError}>\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <PathParamsContext.Provider value={pathParams}>\n        <PathnameContext.Provider value={pathname}>\n          <SearchParamsContext.Provider value={searchParams}>\n            <GlobalLayoutRouterContext.Provider\n              value={globalLayoutRouterContext}\n            >\n              {/* TODO: We should be able to remove this context. useRouter\n                  should import from app-router-instance instead. It's only\n                  necessary because useRouter is shared between Pages and\n                  App Router. We should fork that module, then remove this\n                  context provider. */}\n              <AppRouterContext.Provider value={publicAppRouterInstance}>\n                <LayoutRouterContext.Provider value={layoutRouterContext}>\n                  {content}\n                </LayoutRouterContext.Provider>\n              </AppRouterContext.Provider>\n            </GlobalLayoutRouterContext.Provider>\n          </SearchParamsContext.Provider>\n        </PathnameContext.Provider>\n      </PathParamsContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  assetPrefix,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  assetPrefix: string\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      assetPrefix={assetPrefix}\n      globalError={globalErrorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n","'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","// Override chunk URL mapping in the webpack runtime\n// https://github.com/webpack/webpack/blob/2738eebc7880835d88c727d364ad37f3ec557593/lib/RuntimeGlobals.js#L204\n\nimport { getDeploymentIdQueryOrEmptyString } from '../build/deployment-id'\nimport { encodeURIPath } from '../shared/lib/encode-uri-path'\n\ndeclare const __webpack_require__: any\n\n// If we have a deployment ID, we need to append it to the webpack chunk names\n// I am keeping the process check explicit so this can be statically optimized\nif (process.env.NEXT_DEPLOYMENT_ID) {\n  const suffix = getDeploymentIdQueryOrEmptyString()\n  // eslint-disable-next-line no-undef\n  const getChunkScriptFilename = __webpack_require__.u\n  // eslint-disable-next-line no-undef\n  __webpack_require__.u = (...args: any[]) =>\n    // We encode the chunk filename because our static server matches against and encoded\n    // filename path.\n    encodeURIPath(getChunkScriptFilename(...args)) + suffix\n\n  // eslint-disable-next-line no-undef\n  const getChunkCssFilename = __webpack_require__.k\n  // eslint-disable-next-line no-undef\n  __webpack_require__.k = (...args: any[]) =>\n    getChunkCssFilename(...args) + suffix\n\n  // eslint-disable-next-line no-undef\n  const getMiniCssFilename = __webpack_require__.miniCssF\n  // eslint-disable-next-line no-undef\n  __webpack_require__.miniCssF = (...args: any[]) =>\n    getMiniCssFilename(...args) + suffix\n} else {\n  // eslint-disable-next-line no-undef\n  const getChunkScriptFilename = __webpack_require__.u\n  // eslint-disable-next-line no-undef\n  __webpack_require__.u = (...args: any[]) =>\n    // We encode the chunk filename because our static server matches against and encoded\n    // filename path.\n    encodeURIPath(getChunkScriptFilename(...args))\n\n  // We don't need to override __webpack_require__.k because we don't modify\n  // the css chunk name when not using deployment id suffixes\n\n  // WE don't need to override __webpack_require__.miniCssF because we don't modify\n  // the mini css chunk name when not using deployment id suffixes\n}\n\nexport {}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n","import type { FlightRouterState } from '../../server/app-render/types'\nimport { useState } from 'react'\n\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1\n\nexport type RouterBFCacheEntry = {\n  tree: FlightRouterState\n  stateKey: string\n  // The entries form a linked list, sorted in order of most recently active.\n  next: RouterBFCacheEntry | null\n}\n\n/**\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n * tracks the last N param values that the router rendered for N.\n *\n * The result of this hook precisely determines the number and order of\n * trees that are rendered in parallel at their segment level.\n *\n * The purpose of this cache is to we can preserve the React and DOM state of\n * some number of inactive trees, by rendering them in an <Activity> boundary.\n * That means it would not make sense for the the lifetime of the cache to be\n * any longer than the lifetime of the React tree; e.g. if the hook were\n * unmounted, then the React tree would be, too. So, we use React state to\n * manage it.\n *\n * Note that we don't store the RSC data for the cache entries in this hook \n * the data for inactive segments is stored in the parent CacheNode, which\n * *does* have a longer lifetime than the React tree. This hook only determines\n * which of those trees should have their *state* preserved, by <Activity>.\n */\nexport function useRouterBFCache(\n  activeTree: FlightRouterState,\n  activeStateKey: string\n): RouterBFCacheEntry {\n  // The currently active entry. The entries form a linked list, sorted in\n  // order of most recently active. This allows us to reuse parts of the list\n  // without cloning, unless there's a reordering or removal.\n  // TODO: Once we start tracking back/forward history at each route level,\n  // we should use the history order instead. In other words, when traversing\n  // to an existing entry as a result of a popstate event, we should maintain\n  // the existing order instead of moving it to the front of the list. I think\n  // an initial implementation of this could be to pass an incrementing id\n  // to history.pushState/replaceState, then use that here for ordering.\n  const [prevActiveEntry, setPrevActiveEntry] = useState<RouterBFCacheEntry>(\n    () => {\n      const initialEntry: RouterBFCacheEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null,\n      }\n      return initialEntry\n    }\n  )\n\n  if (prevActiveEntry.tree === activeTree) {\n    // Fast path. The active tree hasn't changed, so we can reuse the\n    // existing state.\n    return prevActiveEntry\n  }\n\n  // The route tree changed. Note that this doesn't mean that the tree changed\n  // *at this level*  the change may be due to a child route. Either way, we\n  // need to either add or update the router tree in the bfcache.\n  //\n  // The rest of the code looks more complicated than it actually is because we\n  // can't mutate the state in place; we have to copy-on-write.\n\n  // Create a new entry for the active cache key. This is the head of the new\n  // linked list.\n  const newActiveEntry: RouterBFCacheEntry = {\n    tree: activeTree,\n    stateKey: activeStateKey,\n    next: null,\n  }\n\n  // We need to append the old list onto the new list. If the head of the new\n  // list was already present in the cache, then we'll need to clone everything\n  // that came before it. Then we can reuse the rest.\n  let n = 1\n  let oldEntry: RouterBFCacheEntry | null = prevActiveEntry\n  let clonedEntry: RouterBFCacheEntry = newActiveEntry\n  while (oldEntry !== null && n < MAX_BF_CACHE_ENTRIES) {\n    if (oldEntry.stateKey === activeStateKey) {\n      // Fast path. This entry in the old list that corresponds to the key that\n      // is now active. We've already placed a clone of this entry at the front\n      // of the new list. We can reuse the rest of the old list without cloning.\n      // NOTE: We don't need to worry about eviction in this case because we\n      // haven't increased the size of the cache, and we assume the max size\n      // is constant across renders. If we were to change it to a dynamic limit,\n      // then the implementation would need to account for that.\n      clonedEntry.next = oldEntry.next\n      break\n    } else {\n      // Clone the entry and append it to the list.\n      n++\n      const entry: RouterBFCacheEntry = {\n        tree: oldEntry.tree,\n        stateKey: oldEntry.stateKey,\n        next: null,\n      }\n      clonedEntry.next = entry\n      clonedEntry = entry\n    }\n    oldEntry = oldEntry.next\n  }\n\n  setPrevActiveEntry(newActiveEntry)\n  return newActiveEntry\n}\n","'use client'\n\nimport type {\n  CacheNode,\n  LazyCacheNode,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../server/app-render/types'\nimport type { ErrorComponent } from './error-boundary'\nimport {\n  ACTION_SERVER_PATCH,\n  type FocusAndScrollRef,\n} from './router-reducer/router-reducer-types'\n\nimport React, {\n  useContext,\n  use,\n  startTransition,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { fetchServerResponse } from './router-reducer/fetch-server-response'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nconst Activity = process.env.__NEXT_ROUTER_BF_CACHE\n  ? (require('react') as typeof import('react')).unstable_Activity\n  : null!\n\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\nfunction walkAddRefetch(\n  segmentPathToWalk: FlightSegmentPath | undefined,\n  treeToRecreate: FlightRouterState\n): FlightRouterState {\n  if (segmentPathToWalk) {\n    const [segment, parallelRouteKey] = segmentPathToWalk\n    const isLast = segmentPathToWalk.length === 2\n\n    if (matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          const subTree = walkAddRefetch(\n            undefined,\n            treeToRecreate[1][parallelRouteKey]\n          )\n          return [\n            treeToRecreate[0],\n            {\n              ...treeToRecreate[1],\n              [parallelRouteKey]: [\n                subTree[0],\n                subTree[1],\n                subTree[2],\n                'refetch',\n              ],\n            },\n          ]\n        }\n\n        return [\n          treeToRecreate[0],\n          {\n            ...treeToRecreate[1],\n            [parallelRouteKey]: walkAddRefetch(\n              segmentPathToWalk.slice(2),\n              treeToRecreate[1][parallelRouteKey]\n            ),\n          },\n        ]\n      }\n    }\n  }\n\n  return treeToRecreate\n}\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',\n        element\n      )\n    }\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      disableSmoothScrollDuringRouteTransition(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  cacheNode,\n  url,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  cacheNode: CacheNode\n  url: string\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const { tree: fullTree } = context\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  const resolvedRsc: React.ReactNode =\n    typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'\n      ? use(rsc)\n      : rsc\n\n  if (!resolvedRsc) {\n    // The data for this segment is not available, and there's no pending\n    // navigation that will be able to fulfill it. We need to fetch more from\n    // the server and patch the cache.\n\n    // Check if there's already a pending request.\n    let lazyData = cacheNode.lazyData\n    if (lazyData === null) {\n      /**\n       * Router state with refetch marker added\n       */\n      // TODO-APP: remove ''\n      const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n      const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n      const navigatedAt = Date.now()\n      cacheNode.lazyData = lazyData = fetchServerResponse(\n        new URL(url, location.origin),\n        {\n          flightRouterState: refetchTree,\n          nextUrl: includeNextUrl ? context.nextUrl : null,\n        }\n      ).then((serverResponse) => {\n        startTransition(() => {\n          dispatchAppRouterAction({\n            type: ACTION_SERVER_PATCH,\n            previousTree: fullTree,\n            serverResponse,\n            navigatedAt,\n          })\n        })\n\n        return serverResponse\n      })\n\n      // Suspend while waiting for lazyData to resolve\n      use(lazyData)\n    }\n    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n    use(unresolvedThenable) as never\n  }\n\n  // If we get to this point, then we know we have something we can render.\n  const subtree = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n      }}\n    >\n      {resolvedRsc}\n    </LayoutRouterContext.Provider>\n  )\n  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n  return subtree\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  loading,\n  children,\n}: {\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server  which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  segmentViewBoundaries,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  segmentViewBoundaries?: React.ReactNode\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const { parentTree, parentCacheNode, parentSegmentPath, url } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React  it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  const activeSegment = activeTree[0]\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment  we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n    const cacheKey = createRouterCacheKey(segment)\n\n    // Read segment path from the parallel router cache node.\n    let cacheNode = segmentMap.get(cacheKey)\n    if (cacheNode === undefined) {\n      // When data is not available during rendering client-side we need to fetch\n      // it from the server.\n      const newLazyCacheNode: LazyCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n\n      // Flight data fetch kicked off during render and put into the cache.\n      cacheNode = newLazyCacheNode\n      segmentMap.set(cacheKey, newLazyCacheNode)\n    }\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    let segmentBoundaryTriggerNode: React.ReactNode = null\n    let segmentViewStateNode: React.ReactNode = null\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER\n    ) {\n      const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      const pagePrefix = normalizeAppPath(url)\n      segmentViewStateNode = (\n        <SegmentViewStateNode key={pagePrefix} page={pagePrefix} />\n      )\n\n      segmentBoundaryTriggerNode = (\n        <>\n          <SegmentBoundaryTriggerNode />\n        </>\n      )\n    }\n\n    // TODO: The loading module data for a segment is stored on the parent, then\n    // applied to each of that parent segment's parallel route slots. In the\n    // simple case where there's only one parallel route (the `children` slot),\n    // this is no different from if the loading module data where stored on the\n    // child directly. But I'm not sure this actually makes sense when there are\n    // multiple parallel routes. It's not a huge issue because you always have\n    // the option to define a narrower loading boundary for a particular slot. But\n    // this sort of smells like an implementation accident to me.\n    const loadingModuleData = parentCacheNode.loading\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundary\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary loading={loadingModuleData}>\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                    />\n                    {segmentBoundaryTriggerNode}\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundary>\n            {segmentViewStateNode}\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentStateProvider } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      child = (\n        <SegmentStateProvider key={stateKey}>\n          {child}\n          {segmentViewBoundaries}\n        </SegmentStateProvider>\n      )\n    }\n\n    if (process.env.__NEXT_ROUTER_BF_CACHE) {\n      child = (\n        <Activity\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n"],"names":["instrumentationHooks","appBootstrap","require","hydrate","createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","origin","window","location","payload","handleResult","nextState","discarded","state","resolve","prevState","actionResult","isThenable","then","err","reject","globalActionQueue","initialState","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","ACTION_SERVER_ACTION","reducer","onRouterTransitionStart","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","allowAliasing","tree","back","history","forward","prefetch","process","options","getAppRouterActionQueue","Error","createPrefetchURL","prefetchReducer","ACTION_PREFETCH","kind","PrefetchKind","FULL","replace","scroll","push","refresh","hmrRefresh","router","ClientPageRoot","Component","searchParams","params","promises","clientSearchParams","createRenderSearchParamsFromClient","clientParams","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","AppRouterAnnouncer","ANNOUNCER_TYPE","useState","portalNode","setPortalNode","useEffect","getAnnouncerNode","announcer","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","ariaLive","id","ANNOUNCER_ID","role","attachShadow","mode","appendChild","body","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","undefined","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal","forbidden","HTTP_ERROR_FALLBACK_ERROR_CODE","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","link","setOptimisticLinkStatus","prefetchable","WeakMap","Map","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","entries","entry","isVisible","intersectionRatio","target","rootMargin","observeVisibility","element","instance","existingInstance","get","set","observe","coercePrefetchableUrl","reportErrorFn","reportError","console","error","fetchStrategy","prefetchEnabled","prefetchURL","prefetchTask","prefetchHref","delete","cancelPrefetchTask","unobserve","add","rescheduleLinkPrefetch","PrefetchPriority","Default","unstable_upgradeToDynamicPrefetch","Intent","priority","existingPrefetchTask","doPrefetch","prefetchKind","FetchStrategy","PPR","AUTO","Full","PPRRuntime","InvariantError","catch","nextUrl","task","isPrefetchTaskDirty","cacheKey","createCacheKey","scheduleSegmentPrefetchTask","HTTPAccessFallbackBoundary","props","triggeredStatus","previousPathname","pathname","componentDidCatch","render","notFound","unauthorized","children","errorComponents","HTTPAccessErrorStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","isNotFound","isForbidden","isUnauthorized","meta","name","content","getDerivedStateFromError","isHTTPAccessFallbackError","getAccessFallbackHTTPStatus","httpStatus","getDerivedStateFromProps","HTTPAccessFallbackErrorBoundary","React","useUntrackedPathname","missingSlots","useContext","MissingSlotContext","hasErrorFallback","assignLocation","startsWith","urlBase","endsWith","isNextRouterError","isRedirectError","HandleISRError","workAsyncStorage","store","getStore","isRevalidate","isStaticGeneration","getAccessFallbackErrorTypeByStatus","ALLOWED_CODES","Object","values","digest","split","prefix","has","Number","status","styles","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","html","head","div","h2","hostname","p","createEmptyCacheNode","AppRouter","globalMutable","isBot","navigator","userAgent","_","HistoryUpdater","appRouterState","useInsertionEffect","pushRef","canonicalUrl","historyState","preserveCustomHistoryState","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","createHrefFromUrl","pushState","replaceState","lazyData","rsc","prefetchRsc","prefetchHead","parallelRoutes","loading","navigatedAt","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","useDeferredValue","Router","assetPrefix","globalError","useActionQueue","useMemo","hasBasePath","removeBasePath","handlePageShow","event","persisted","pendingMpaPath","addEventListener","removeEventListener","handleUnhandledRedirect","reason","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","RedirectType","mpaNavigation","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","_unused","_N","onPopState","reload","cache","focusAndScrollRef","matchingHead","findHeadInCache","pathParams","getSelectedParams","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","RedirectBoundary","RootLayoutBoundary","RootErrorBoundary","errorComponent","errorStyles","RuntimeStyles","PathParamsContext","Provider","value","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","runtimeStyleChanged","forceUpdate","renderedStylesSize","size","changed","c","map","i","rel","precedence","dplId","globalThis","_N_E_STYLE_LOAD","len","cb","GracefulDegradeBoundary","hasError","rootHtml","htmlAttributes","htmlRef","createRef","componentDidMount","htmlNode","forEach","key","setAttribute","documentElement","innerHTML","getDomNodeAttributes","result","node","attributes","length","attr","ref","suppressHydrationWarning","dangerouslySetInnerHTML","__html","ClientSegmentRoot","slots","promise","createRenderParamsFromClient","getChunkScriptFilename","__webpack_require__","u","args","encodeURIPath","ErrorBoundary","ErrorBoundaryHandler","isBotUserAgent","reset","errorScripts","this","useRouterBFCache","activeTree","activeStateKey","stateKey","prevActiveEntry","setPrevActiveEntry","newActiveEntry","n","oldEntry","clonedEntry","MAX_BF_CACHE_ENTRIES","OuterLayoutRouter","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","ReactDOM","rectProperties","topOfElementInViewport","viewportHeight","rect","getBoundingClientRect","top","InnerScrollAndFocusHandler","handlePotentialScroll","segmentPath","apply","segmentPaths","some","scrollRefSegmentPath","every","segment","index","matchSegment","domNode","hashFragment","getHashFragmentDomNode","getElementById","findDOMNode","Element","HTMLElement","shouldSkipElement","includes","getComputedStyle","position","item","nextElementSibling","disableSmoothScrollDuringRouteTransition","scrollIntoView","htmlElement","clientHeight","scrollTop","dontForceLayout","onlyHashChange","focus","componentDidUpdate","ScrollAndFocusHandler","context","InnerLayoutRouter","cacheNode","fullTree","resolvedRsc","use","refetchTree","walkAddRefetch","segmentPathToWalk","treeToRecreate","parallelRouteKey","isLast","hasOwnProperty","subTree","slice","includeNextUrl","hasInterceptionRouteInCurrentTree","Date","now","fetchServerResponse","flightRouterState","serverResponse","ACTION_SERVER_PATCH","previousTree","subtree","LoadingBoundary","loadingModuleData","promiseForLoading","loadingRsc","loadingStyles","loadingScripts","Suspense","fallback","parallelRouterKey","templateStyles","templateScripts","template","segmentViewBoundaries","parentParallelRoutes","segmentMap","parentTreeSegment","concat","activeSegment","createRouterCacheKey","bfcacheEntry","newLazyCacheNode","child","TemplateContext"],"sourceRoot":"","ignoreList":[]}