{"version":3,"file":"static/chunks/3216.b573595309fa846b.js","mappings":"yIACO,OAEP,mBACA,EACA,qBACA,KAAkB,eAAa,WAC/B,cACA,EAEA,2BACA,EACA,8BACA,cACA,EAEA,uBACA,EACA,WACA,UACA,QACA,eACA,cACA,eACA,GAEA,qBACA,EACA,oBACA,OACA,eACA,GAEA,kBACA,EACA,iBACA,QACA,eACA,GAGA,iBACA,qBACA,cACA,CAAK,CACL,oBACA,8BACA,2BACA,cACA,CAAK,CACL,wBACA,WACA,CAAK,CACL,sBACA,UAEA,yBACA,yDACA,GACA,SACA,aACA,cAUA,gBAPA,CACA,yBACA,OACA,WACA,WACA,eACA,EAGA,CAAK,CACL,qBACA,QACA,CAAK,CACL,mBACA,OAEA,cACA,iBACA,yCACA,oCACA,iBACA,CACA,CAAK,CACL,gBACA,0BACA,0CACA,oBACA,WACA,MACA,CACA,CACA,oCACA,CAAK,CACL,wBACA,6CACA,oBACA,WAGA,uCAEA,CAAK,CACL,qBACA,sCACA,YAAwB,WAAkB,IAC1C,kBACA,kBAGA,CAAK,CAEL,iBACA,gBAEA,iBACA,aAEA,iBACA,aAEA,eACA,QAGA,cACA,UAEA,mBACA,eAEA,sBACA,QAEA,yBACA,OAEA,2BACA,OAEA,+BACA,WAEA,+BACA,WAGA,cACA,qBAEA,iBACA,wBAEA,sBACA,6BAEA,iBACA,kDAGA,+BACA,sBACA,CAAK,CACL,6BACA,qBAEA,kCACA,sBAAoC,6BACpC,CAAK,gDEpKL,uBDAO,SACP,eACA,eACA,aACA,YAEA,mBACA,iBACA,wBACA,yBACA,sBACA,qBAfA,MAgBA,cACA,oBACA,yBACA,YAEA,qBACA,CAEA,UACA,oEACA,CACA,aACA,uCAEA,cACA,SAAgB,kBAAoB,KACpC,MACA,MACA,OACA,OACA,YACA,UACA,WACA,SACA,cACA,WACA,CACA,CACA,QACA,8DACA,+BACA,8CAEA,CACA,UACA,oCACA,yBAEA,qBAEA,kCACA,uCACA,GAAgB,QAAe,IAK/B,OAHA,WAEA,eACuB,QAAyB,KAEhD,MAEA,0BAEA,OADA,sBACmB,IAAC,KAIpB,OADA,UAAkB,GAAG,yBACrB,CACA,CACA,sBACA,qCAEA,kBACA,6BACA,wCACA,4BACA,iCACA,WACA,mBACA,uBAEA,CACA,WACA,mBACA,aAGA,YAEA,sBACA,uBACA,CACA,0BACA,8EACA,qBACA,CACA,gBAEA,sCAEA,OADA,0CACA,GAEA,KACA,wCAEA,YAAwB,WAAoB,IAE5C,GADA,wCACA,gBACA,SAGA,QACA,CACA,QACA,iBACA,uBAEA,OADA,0CACmB,IAAC,KAEpB,8BACA,WAAwB,IAAC,iBAAmB,IAAC,YAC7C,CACA,UAQA,GAPA,WAEA,aACA,cACA,YACA,4BAEA,2BAEA,OADA,0CACmB,IAAC,KAEpB,4CAEA,IAAmB,IAAC,kBACpB,cACA,wBACmB,IAAC,YAIpB,IAAmB,IAAC,aACpB,cACA,uBAEA,YACA,wBACA,eACA,iBAGA,wBACY,QAAW,KACvB,8BAKA,kCACA,aACA,IAAmB,IAAC,YACpB,IAAmB,IAAC,kBACpB,gBAEA,uCAEA,EACA,CACA,kCACY,QAAkB,IAC9B,UAAsB,GAAG,gCAER,QAAoB,KACrC,UAAsB,GAAG,2BAEzB,CACA,WAEA,IADA,YACA,0BACA,oCACA,UAEA,cACA,CACA,uCC3LA,YACA,mBACA,uBACA,yBACA,iCACA,6BACA,2BACA,mCACA,2BACA,qDACA,iDACA,kDACA,wDACA,oDACA,oDACA,gEACA,4DACA,4DACA,4DACA,sEACA,kDACA,4DACA,sEACA,gFACA,4EACA,4EACA,0EACA,gEACA,0EACA,oFACA,8FACA,sEACA,sDACA,wCACA,oDACA,wDACA,sEACA,sEACA,4DACA,oEACA,wDACA,sCACA,0DACA,sCACA,gDACA,0BACA,wDACA,kEACA,4EACA,sFACA,4CACA,kCACA,4CACA,0BACA,kDACA,oCACA,gDACA,oEACA,4EACA,0FACA,0FACA,0EACA,sGACA,oEACA,4EACA,0FACA,0FACA,0EACA,sCACA,sCACA,sDACA,8CACA,kDACA,iDACA,CAAC,UAAsB,EAEhB,OACP,YACA,gBACA,kBACA,0BACA,sBACA,+BASA,cACA,UAAiB,IAAC,qBAA0B,IAAC,gBAC7C,CAIA,cACA,UAHiB,IAAC,mBAAwB,IAAC,gBAG3C,IACA,CACA,cACA,gBAZiB,IAAC,UAYlB,GAZoC,IAAC,SAiBrC,cACA,WAAkB,IAAC,YAAiB,IAAC,gBAAqB,IAAC,iBAAsB,IAAC,WAElF,cACA,iBAAsC,IAAC,cAAmB,IAAC,mBAqBpD,QACP,iBACA,eACA,eACA,eAEA,eAOA,sBACA,yBACA,eACA,kBACA,wBACA,sBACA,8BACA,gCACA,uBACA,kBAA6B,kBAC7B,sBAAgC,EAAY,GAC5C,OAD4C,aAC5C,6BACA,uBAAiC,IAAa,CAAC,IAAc,SAG7D,8CACA,mDACA,CAAS,gBACT,CACA,6CACA,UAA8B,GAAG,2CACjC,CAAiB,CACjB,+CACA,UAA8B,GAAG,wFACjC,CAAiB,CACjB,sCACA,MA1DA,YACA,OAAiB,IAAC,MAClB,OAAe,GAAG,wBAElB,aACA,OAAe,GAAG,uCAElB,GAAa,QAAW,IACxB,OAAe,GAAG,6BAElB,GAAa,QAAoB,IACjC,OAAe,GAAG,gCAElB,GAAa,QAAkB,SAAmB,IAAC,iBACnD,OAAe,GAAG,2BAElB,WACA,EAyCA,EACA,IACA,cACA,CAAiB,EAEjB,OACA,CAEA,YACA,OACA,mFACA,CAEA,6BACA,oCAGA,CACA,iCACA,iCACA,uCACA,WACA,UACA,YACA,EATA,IAUA,CACA,kBACA,iBAGA,IADA,eACA,4BACA,6BACA,qBACA,4BACA,kBAEA,CACA,eACA,CAEA,QACA,cACA,CACA,UACA,gBACA,yCAEA,iBAEA,cAEA,uBACA,aACA,aAEA,CACA,aACA,eACA,6BACA,uBACA,aACA,YAEA,CACA,0BACA,eACA,4CACA,sBACA,CAEA,2BACA,oCACA,sDACA,6BACA,eACA,GAGA,CAEA,WAEA,OADA,6BACA,2BACA,CACA,cACA,8BACA,YAAwB,IAAW,IACnC,2BAEA,CACA,mCACA,sCAEA,4BACA,GAGA,CAEA,uBACA,mBACA,KAAkB,GAAS,WAC3B,WACA,MAAmB,QAAM,SACzB,eACA,kBACA,SACA,mCACA,CACA,CACA,qBACA,mBACA,KAAkB,GAAS,SAC3B,WACA,MAAmB,QAAM,SACzB,eACA,kBACA,SACA,mCACA,CACA,CACA,uBACA,mBACA,KAAkB,GAAS,SAC3B,QACA,mCACA,CACA,CACA,uBACA,mBACA,KAAkB,GAAS,SAC3B,OACA,eACA,cACA,cACA,8BAEA,CACA,2BACA,4BACA,OACA,QACA,8BAEA,CAEA,eACA,kBACA,OACA,QACA,EACA,+CACA,CACA,qBACA,EACA,EACA,+BACY,OAAY,2BACxB,+BACA,mCACA,8DACA,6CAEA,yBAIA,UAAsB,GAAG,oBAEzB,CACA,kBACA,uBACA,oDACA,kDACA,wDAEA,CAEA,gBACA,4CACA,uBACA,aACA,0CACA,0CACA,iDAEA,gDACA,CACA,sBACA,wBACA,qBACA,QAAmB,cAAQ,YAC3B,SAAwB,GAAS,YACjC,gCACA,6BAGA,kBACA,UAA0B,GAAG,uBAE7B,eACA,UAA0B,GAAG,4BAE7B,0BAEA,mCACA,CACA,sBACA,qBACA,0BACA,mCACA,CACA,sBACA,qBACA,0BACA,mCACA,CACA,8BACA,+BAQA,OALA,yCACA,wDACA,sDACA,6DAEA,iCACA,KAAqB,GAAS,WAC9B,qDACA,KAEA,MAAqB,GAAS,gBAC9B,yDACA,KAEA,MAAqB,GAAS,sBAC9B,8DAGA,CACA,+BACA,CACA,CACA,gBACA,iCACA,IACA,sBACA,oBACA,2BAEA,mCACA,oBAA6B,KAAM,GAAS,gBAAgB,EAC5D,cACA,CAUA,wCACA,8BACA,wCACA,oCACA,MACA,MAEA,gDACA,sDACA,oCAGA,+BACA,CACA,kBACA,WACc,GAAS,sBACvB,IAAqB,IAAC,MACJ,GAAS,gBACT,GAAS,WAC3B,kEACA,CAGA,cACA,wCAAgD,GAAS,aACzD,CAEA,2BACA,4BACA,iCACA,0CACA,uEAAiF,IAAY,WAAa,IAAY,QACtH,CACA,mCACA,2DACA,oDACA,8CAEA,+CACA,wCACA,gDAGA,sBAEA,CAEA,cACA,mBACA,YACA,mBACA,KAEA,eACA,qBACA,KAEA,gBACA,sBACA,KAEA,oBACA,yBACA,KAEA,kBACA,wBACA,KAEA,iBACA,sBACA,KAEA,qBACA,yBACA,KAEA,iBACA,sBACA,KAEA,8BACA,iCACA,KAEA,4BACA,+BACA,KAEA,4BACA,+BACA,KAEA,+BACA,kCACA,KAEA,6BACA,gCACA,KAEA,6BACA,gCACA,KAEA,mCACA,qCACA,KAEA,iCACA,mCACA,KAEA,iCACA,mCACA,KAEA,iCACA,oCACA,KAEA,sCACA,wCACA,KAEA,4BACA,gCACA,KAEA,iCACA,oCACA,KAEA,sCACA,wCACA,KAEA,2CACA,4CACA,KAEA,yCACA,0CACA,KAEA,yCACA,0CACA,KAEA,wCACA,0CACA,KAEA,mCACA,sCACA,KAEA,wCACA,0CACA,KAEA,6CACA,8CACA,KAEA,kDACA,kDACA,KAEA,sCACA,wCACA,KAEA,8BACA,kCACA,KAEA,uBACA,4BACA,KAEA,6BACA,iCACA,KAEA,+BACA,mCACA,KAEA,sCACA,yCACA,KAEA,sCACA,yCACA,KAEA,iCACA,qCACA,KAEA,qCACA,wCACA,KAEA,+BACA,kCACA,KAEA,sBACA,2BACA,KAEA,gCACA,oCACA,KAEA,sBACA,2BACA,KAEA,2BACA,+BACA,KAEA,gBACA,sBACA,KAEA,+BACA,kCACA,KAEA,oCACA,sCACA,KAEA,yCACA,0CACA,KAEA,8CACA,8CACA,KAEA,yBACA,6BACA,KAEA,oBACA,yBACA,KAEA,yBACA,6BACA,KAEA,gBACA,sBACA,KAEA,4BACA,gCACA,KAEA,qBACA,0BACA,KAEA,2BACA,+BACA,KAEA,qCACA,wCACA,KAEA,yCACA,4CACA,KAEA,gDACA,kDACA,KAEA,gDACA,kDACA,KAEA,wCACA,2CACA,KAEA,sDACA,uDACA,KAEA,qCACA,wCACA,KAEA,yCACA,4CACA,KAEA,gDACA,kDACA,KAEA,gDACA,kDACA,KAEA,wCACA,2CACA,KAEA,sBACA,2BACA,KAEA,sBACA,2BACA,KAEA,8BACA,kCACA,KAEA,0BACA,8BACA,KAEA,4BACA,gCACA,KAEA,4BACA,iCACA,KAEA,SACA,4BAEA,CACA,CAIA,cACA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","sources":["webpack://_N_E/./node_modules/parse5/dist/tree-adapters/default.js","webpack://_N_E/./node_modules/parse5/dist/tokenizer/preprocessor.js","webpack://_N_E/./node_modules/parse5/dist/tokenizer/index.js"],"sourcesContent":["import { DOCUMENT_MODE } from '../common/html.js';\nexport const defaultTreeAdapter = {\n    //Node construction\n    createDocument() {\n        return {\n            nodeName: '#document',\n            mode: DOCUMENT_MODE.NO_QUIRKS,\n            childNodes: [],\n        };\n    },\n    createDocumentFragment() {\n        return {\n            nodeName: '#document-fragment',\n            childNodes: [],\n        };\n    },\n    createElement(tagName, namespaceURI, attrs) {\n        return {\n            nodeName: tagName,\n            tagName,\n            attrs,\n            namespaceURI,\n            childNodes: [],\n            parentNode: null,\n        };\n    },\n    createCommentNode(data) {\n        return {\n            nodeName: '#comment',\n            data,\n            parentNode: null,\n        };\n    },\n    createTextNode(value) {\n        return {\n            nodeName: '#text',\n            value,\n            parentNode: null,\n        };\n    },\n    //Tree mutation\n    appendChild(parentNode, newNode) {\n        parentNode.childNodes.push(newNode);\n        newNode.parentNode = parentNode;\n    },\n    insertBefore(parentNode, newNode, referenceNode) {\n        const insertionIdx = parentNode.childNodes.indexOf(referenceNode);\n        parentNode.childNodes.splice(insertionIdx, 0, newNode);\n        newNode.parentNode = parentNode;\n    },\n    setTemplateContent(templateElement, contentElement) {\n        templateElement.content = contentElement;\n    },\n    getTemplateContent(templateElement) {\n        return templateElement.content;\n    },\n    setDocumentType(document, name, publicId, systemId) {\n        const doctypeNode = document.childNodes.find((node) => node.nodeName === '#documentType');\n        if (doctypeNode) {\n            doctypeNode.name = name;\n            doctypeNode.publicId = publicId;\n            doctypeNode.systemId = systemId;\n        }\n        else {\n            const node = {\n                nodeName: '#documentType',\n                name,\n                publicId,\n                systemId,\n                parentNode: null,\n            };\n            defaultTreeAdapter.appendChild(document, node);\n        }\n    },\n    setDocumentMode(document, mode) {\n        document.mode = mode;\n    },\n    getDocumentMode(document) {\n        return document.mode;\n    },\n    detachNode(node) {\n        if (node.parentNode) {\n            const idx = node.parentNode.childNodes.indexOf(node);\n            node.parentNode.childNodes.splice(idx, 1);\n            node.parentNode = null;\n        }\n    },\n    insertText(parentNode, text) {\n        if (parentNode.childNodes.length > 0) {\n            const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];\n            if (defaultTreeAdapter.isTextNode(prevNode)) {\n                prevNode.value += text;\n                return;\n            }\n        }\n        defaultTreeAdapter.appendChild(parentNode, defaultTreeAdapter.createTextNode(text));\n    },\n    insertTextBefore(parentNode, text, referenceNode) {\n        const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];\n        if (prevNode && defaultTreeAdapter.isTextNode(prevNode)) {\n            prevNode.value += text;\n        }\n        else {\n            defaultTreeAdapter.insertBefore(parentNode, defaultTreeAdapter.createTextNode(text), referenceNode);\n        }\n    },\n    adoptAttributes(recipient, attrs) {\n        const recipientAttrsMap = new Set(recipient.attrs.map((attr) => attr.name));\n        for (let j = 0; j < attrs.length; j++) {\n            if (!recipientAttrsMap.has(attrs[j].name)) {\n                recipient.attrs.push(attrs[j]);\n            }\n        }\n    },\n    //Tree traversing\n    getFirstChild(node) {\n        return node.childNodes[0];\n    },\n    getChildNodes(node) {\n        return node.childNodes;\n    },\n    getParentNode(node) {\n        return node.parentNode;\n    },\n    getAttrList(element) {\n        return element.attrs;\n    },\n    //Node data\n    getTagName(element) {\n        return element.tagName;\n    },\n    getNamespaceURI(element) {\n        return element.namespaceURI;\n    },\n    getTextNodeContent(textNode) {\n        return textNode.value;\n    },\n    getCommentNodeContent(commentNode) {\n        return commentNode.data;\n    },\n    getDocumentTypeNodeName(doctypeNode) {\n        return doctypeNode.name;\n    },\n    getDocumentTypeNodePublicId(doctypeNode) {\n        return doctypeNode.publicId;\n    },\n    getDocumentTypeNodeSystemId(doctypeNode) {\n        return doctypeNode.systemId;\n    },\n    //Node types\n    isTextNode(node) {\n        return node.nodeName === '#text';\n    },\n    isCommentNode(node) {\n        return node.nodeName === '#comment';\n    },\n    isDocumentTypeNode(node) {\n        return node.nodeName === '#documentType';\n    },\n    isElementNode(node) {\n        return Object.prototype.hasOwnProperty.call(node, 'tagName');\n    },\n    // Source code location\n    setNodeSourceCodeLocation(node, location) {\n        node.sourceCodeLocation = location;\n    },\n    getNodeSourceCodeLocation(node) {\n        return node.sourceCodeLocation;\n    },\n    updateNodeSourceCodeLocation(node, endLocation) {\n        node.sourceCodeLocation = { ...node.sourceCodeLocation, ...endLocation };\n    },\n};\n","import { CODE_POINTS as $, getSurrogatePairCodePoint, isControlCodePoint, isSurrogate, isSurrogatePair, isUndefinedCodePoint, } from '../common/unicode.js';\nimport { ERR } from '../common/error-codes.js';\n//Const\nconst DEFAULT_BUFFER_WATERLINE = 1 << 16;\n//Preprocessor\n//NOTE: HTML input preprocessing\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/parsing.html#preprocessing-the-input-stream)\nexport class Preprocessor {\n    constructor(handler) {\n        this.handler = handler;\n        this.html = '';\n        this.pos = -1;\n        // NOTE: Initial `lastGapPos` is -2, to ensure `col` on initialisation is 0\n        this.lastGapPos = -2;\n        this.gapStack = [];\n        this.skipNextNewLine = false;\n        this.lastChunkWritten = false;\n        this.endOfChunkHit = false;\n        this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;\n        this.isEol = false;\n        this.lineStartPos = 0;\n        this.droppedBufferSize = 0;\n        this.line = 1;\n        //NOTE: avoid reporting errors twice on advance/retreat\n        this.lastErrOffset = -1;\n    }\n    /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */\n    get col() {\n        return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos);\n    }\n    get offset() {\n        return this.droppedBufferSize + this.pos;\n    }\n    getError(code, cpOffset) {\n        const { line, col, offset } = this;\n        const startCol = col + cpOffset;\n        const startOffset = offset + cpOffset;\n        return {\n            code,\n            startLine: line,\n            endLine: line,\n            startCol,\n            endCol: startCol,\n            startOffset,\n            endOffset: startOffset,\n        };\n    }\n    _err(code) {\n        if (this.handler.onParseError && this.lastErrOffset !== this.offset) {\n            this.lastErrOffset = this.offset;\n            this.handler.onParseError(this.getError(code, 0));\n        }\n    }\n    _addGap() {\n        this.gapStack.push(this.lastGapPos);\n        this.lastGapPos = this.pos;\n    }\n    _processSurrogate(cp) {\n        //NOTE: try to peek a surrogate pair\n        if (this.pos !== this.html.length - 1) {\n            const nextCp = this.html.charCodeAt(this.pos + 1);\n            if (isSurrogatePair(nextCp)) {\n                //NOTE: we have a surrogate pair. Peek pair character and recalculate code point.\n                this.pos++;\n                //NOTE: add a gap that should be avoided during retreat\n                this._addGap();\n                return getSurrogatePairCodePoint(cp, nextCp);\n            }\n        }\n        //NOTE: we are at the end of a chunk, therefore we can't infer the surrogate pair yet.\n        else if (!this.lastChunkWritten) {\n            this.endOfChunkHit = true;\n            return $.EOF;\n        }\n        //NOTE: isolated surrogate\n        this._err(ERR.surrogateInInputStream);\n        return cp;\n    }\n    willDropParsedChunk() {\n        return this.pos > this.bufferWaterline;\n    }\n    dropParsedChunk() {\n        if (this.willDropParsedChunk()) {\n            this.html = this.html.substring(this.pos);\n            this.lineStartPos -= this.pos;\n            this.droppedBufferSize += this.pos;\n            this.pos = 0;\n            this.lastGapPos = -2;\n            this.gapStack.length = 0;\n        }\n    }\n    write(chunk, isLastChunk) {\n        if (this.html.length > 0) {\n            this.html += chunk;\n        }\n        else {\n            this.html = chunk;\n        }\n        this.endOfChunkHit = false;\n        this.lastChunkWritten = isLastChunk;\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.html = this.html.substring(0, this.pos + 1) + chunk + this.html.substring(this.pos + 1);\n        this.endOfChunkHit = false;\n    }\n    startsWith(pattern, caseSensitive) {\n        // Check if our buffer has enough characters\n        if (this.pos + pattern.length > this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return false;\n        }\n        if (caseSensitive) {\n            return this.html.startsWith(pattern, this.pos);\n        }\n        for (let i = 0; i < pattern.length; i++) {\n            const cp = this.html.charCodeAt(this.pos + i) | 0x20;\n            if (cp !== pattern.charCodeAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    peek(offset) {\n        const pos = this.pos + offset;\n        if (pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        const code = this.html.charCodeAt(pos);\n        return code === $.CARRIAGE_RETURN ? $.LINE_FEED : code;\n    }\n    advance() {\n        this.pos++;\n        //NOTE: LF should be in the last column of the line\n        if (this.isEol) {\n            this.isEol = false;\n            this.line++;\n            this.lineStartPos = this.pos;\n        }\n        if (this.pos >= this.html.length) {\n            this.endOfChunkHit = !this.lastChunkWritten;\n            return $.EOF;\n        }\n        let cp = this.html.charCodeAt(this.pos);\n        //NOTE: all U+000D CARRIAGE RETURN (CR) characters must be converted to U+000A LINE FEED (LF) characters\n        if (cp === $.CARRIAGE_RETURN) {\n            this.isEol = true;\n            this.skipNextNewLine = true;\n            return $.LINE_FEED;\n        }\n        //NOTE: any U+000A LINE FEED (LF) characters that immediately follow a U+000D CARRIAGE RETURN (CR) character\n        //must be ignored.\n        if (cp === $.LINE_FEED) {\n            this.isEol = true;\n            if (this.skipNextNewLine) {\n                // `line` will be bumped again in the recursive call.\n                this.line--;\n                this.skipNextNewLine = false;\n                this._addGap();\n                return this.advance();\n            }\n        }\n        this.skipNextNewLine = false;\n        if (isSurrogate(cp)) {\n            cp = this._processSurrogate(cp);\n        }\n        //OPTIMIZATION: first check if code point is in the common allowed\n        //range (ASCII alphanumeric, whitespaces, big chunk of BMP)\n        //before going into detailed performance cost validation.\n        const isCommonValidRange = this.handler.onParseError === null ||\n            (cp > 0x1f && cp < 0x7f) ||\n            cp === $.LINE_FEED ||\n            cp === $.CARRIAGE_RETURN ||\n            (cp > 0x9f && cp < 64976);\n        if (!isCommonValidRange) {\n            this._checkForProblematicCharacters(cp);\n        }\n        return cp;\n    }\n    _checkForProblematicCharacters(cp) {\n        if (isControlCodePoint(cp)) {\n            this._err(ERR.controlCharacterInInputStream);\n        }\n        else if (isUndefinedCodePoint(cp)) {\n            this._err(ERR.noncharacterInInputStream);\n        }\n    }\n    retreat(count) {\n        this.pos -= count;\n        while (this.pos < this.lastGapPos) {\n            this.lastGapPos = this.gapStack.pop();\n            this.pos--;\n        }\n        this.isEol = false;\n    }\n}\n","import { Preprocessor } from './preprocessor.js';\nimport { CODE_POINTS as $, SEQUENCES as $$, REPLACEMENT_CHARACTER, isSurrogate, isUndefinedCodePoint, isControlCodePoint, } from '../common/unicode.js';\nimport { TokenType, getTokenAttr, } from '../common/token.js';\nimport { htmlDecodeTree, EntityDecoder, DecodingMode } from 'entities/decode';\nimport { ERR } from '../common/error-codes.js';\nimport { TAG_ID, getTagID } from '../common/html.js';\n//States\nvar State;\n(function (State) {\n    State[State[\"DATA\"] = 0] = \"DATA\";\n    State[State[\"RCDATA\"] = 1] = \"RCDATA\";\n    State[State[\"RAWTEXT\"] = 2] = \"RAWTEXT\";\n    State[State[\"SCRIPT_DATA\"] = 3] = \"SCRIPT_DATA\";\n    State[State[\"PLAINTEXT\"] = 4] = \"PLAINTEXT\";\n    State[State[\"TAG_OPEN\"] = 5] = \"TAG_OPEN\";\n    State[State[\"END_TAG_OPEN\"] = 6] = \"END_TAG_OPEN\";\n    State[State[\"TAG_NAME\"] = 7] = \"TAG_NAME\";\n    State[State[\"RCDATA_LESS_THAN_SIGN\"] = 8] = \"RCDATA_LESS_THAN_SIGN\";\n    State[State[\"RCDATA_END_TAG_OPEN\"] = 9] = \"RCDATA_END_TAG_OPEN\";\n    State[State[\"RCDATA_END_TAG_NAME\"] = 10] = \"RCDATA_END_TAG_NAME\";\n    State[State[\"RAWTEXT_LESS_THAN_SIGN\"] = 11] = \"RAWTEXT_LESS_THAN_SIGN\";\n    State[State[\"RAWTEXT_END_TAG_OPEN\"] = 12] = \"RAWTEXT_END_TAG_OPEN\";\n    State[State[\"RAWTEXT_END_TAG_NAME\"] = 13] = \"RAWTEXT_END_TAG_NAME\";\n    State[State[\"SCRIPT_DATA_LESS_THAN_SIGN\"] = 14] = \"SCRIPT_DATA_LESS_THAN_SIGN\";\n    State[State[\"SCRIPT_DATA_END_TAG_OPEN\"] = 15] = \"SCRIPT_DATA_END_TAG_OPEN\";\n    State[State[\"SCRIPT_DATA_END_TAG_NAME\"] = 16] = \"SCRIPT_DATA_END_TAG_NAME\";\n    State[State[\"SCRIPT_DATA_ESCAPE_START\"] = 17] = \"SCRIPT_DATA_ESCAPE_START\";\n    State[State[\"SCRIPT_DATA_ESCAPE_START_DASH\"] = 18] = \"SCRIPT_DATA_ESCAPE_START_DASH\";\n    State[State[\"SCRIPT_DATA_ESCAPED\"] = 19] = \"SCRIPT_DATA_ESCAPED\";\n    State[State[\"SCRIPT_DATA_ESCAPED_DASH\"] = 20] = \"SCRIPT_DATA_ESCAPED_DASH\";\n    State[State[\"SCRIPT_DATA_ESCAPED_DASH_DASH\"] = 21] = \"SCRIPT_DATA_ESCAPED_DASH_DASH\";\n    State[State[\"SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN\"] = 22] = \"SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN\";\n    State[State[\"SCRIPT_DATA_ESCAPED_END_TAG_OPEN\"] = 23] = \"SCRIPT_DATA_ESCAPED_END_TAG_OPEN\";\n    State[State[\"SCRIPT_DATA_ESCAPED_END_TAG_NAME\"] = 24] = \"SCRIPT_DATA_ESCAPED_END_TAG_NAME\";\n    State[State[\"SCRIPT_DATA_DOUBLE_ESCAPE_START\"] = 25] = \"SCRIPT_DATA_DOUBLE_ESCAPE_START\";\n    State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED\"] = 26] = \"SCRIPT_DATA_DOUBLE_ESCAPED\";\n    State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED_DASH\"] = 27] = \"SCRIPT_DATA_DOUBLE_ESCAPED_DASH\";\n    State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH\"] = 28] = \"SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH\";\n    State[State[\"SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN\"] = 29] = \"SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN\";\n    State[State[\"SCRIPT_DATA_DOUBLE_ESCAPE_END\"] = 30] = \"SCRIPT_DATA_DOUBLE_ESCAPE_END\";\n    State[State[\"BEFORE_ATTRIBUTE_NAME\"] = 31] = \"BEFORE_ATTRIBUTE_NAME\";\n    State[State[\"ATTRIBUTE_NAME\"] = 32] = \"ATTRIBUTE_NAME\";\n    State[State[\"AFTER_ATTRIBUTE_NAME\"] = 33] = \"AFTER_ATTRIBUTE_NAME\";\n    State[State[\"BEFORE_ATTRIBUTE_VALUE\"] = 34] = \"BEFORE_ATTRIBUTE_VALUE\";\n    State[State[\"ATTRIBUTE_VALUE_DOUBLE_QUOTED\"] = 35] = \"ATTRIBUTE_VALUE_DOUBLE_QUOTED\";\n    State[State[\"ATTRIBUTE_VALUE_SINGLE_QUOTED\"] = 36] = \"ATTRIBUTE_VALUE_SINGLE_QUOTED\";\n    State[State[\"ATTRIBUTE_VALUE_UNQUOTED\"] = 37] = \"ATTRIBUTE_VALUE_UNQUOTED\";\n    State[State[\"AFTER_ATTRIBUTE_VALUE_QUOTED\"] = 38] = \"AFTER_ATTRIBUTE_VALUE_QUOTED\";\n    State[State[\"SELF_CLOSING_START_TAG\"] = 39] = \"SELF_CLOSING_START_TAG\";\n    State[State[\"BOGUS_COMMENT\"] = 40] = \"BOGUS_COMMENT\";\n    State[State[\"MARKUP_DECLARATION_OPEN\"] = 41] = \"MARKUP_DECLARATION_OPEN\";\n    State[State[\"COMMENT_START\"] = 42] = \"COMMENT_START\";\n    State[State[\"COMMENT_START_DASH\"] = 43] = \"COMMENT_START_DASH\";\n    State[State[\"COMMENT\"] = 44] = \"COMMENT\";\n    State[State[\"COMMENT_LESS_THAN_SIGN\"] = 45] = \"COMMENT_LESS_THAN_SIGN\";\n    State[State[\"COMMENT_LESS_THAN_SIGN_BANG\"] = 46] = \"COMMENT_LESS_THAN_SIGN_BANG\";\n    State[State[\"COMMENT_LESS_THAN_SIGN_BANG_DASH\"] = 47] = \"COMMENT_LESS_THAN_SIGN_BANG_DASH\";\n    State[State[\"COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH\"] = 48] = \"COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH\";\n    State[State[\"COMMENT_END_DASH\"] = 49] = \"COMMENT_END_DASH\";\n    State[State[\"COMMENT_END\"] = 50] = \"COMMENT_END\";\n    State[State[\"COMMENT_END_BANG\"] = 51] = \"COMMENT_END_BANG\";\n    State[State[\"DOCTYPE\"] = 52] = \"DOCTYPE\";\n    State[State[\"BEFORE_DOCTYPE_NAME\"] = 53] = \"BEFORE_DOCTYPE_NAME\";\n    State[State[\"DOCTYPE_NAME\"] = 54] = \"DOCTYPE_NAME\";\n    State[State[\"AFTER_DOCTYPE_NAME\"] = 55] = \"AFTER_DOCTYPE_NAME\";\n    State[State[\"AFTER_DOCTYPE_PUBLIC_KEYWORD\"] = 56] = \"AFTER_DOCTYPE_PUBLIC_KEYWORD\";\n    State[State[\"BEFORE_DOCTYPE_PUBLIC_IDENTIFIER\"] = 57] = \"BEFORE_DOCTYPE_PUBLIC_IDENTIFIER\";\n    State[State[\"DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED\"] = 58] = \"DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED\";\n    State[State[\"DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED\"] = 59] = \"DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED\";\n    State[State[\"AFTER_DOCTYPE_PUBLIC_IDENTIFIER\"] = 60] = \"AFTER_DOCTYPE_PUBLIC_IDENTIFIER\";\n    State[State[\"BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS\"] = 61] = \"BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS\";\n    State[State[\"AFTER_DOCTYPE_SYSTEM_KEYWORD\"] = 62] = \"AFTER_DOCTYPE_SYSTEM_KEYWORD\";\n    State[State[\"BEFORE_DOCTYPE_SYSTEM_IDENTIFIER\"] = 63] = \"BEFORE_DOCTYPE_SYSTEM_IDENTIFIER\";\n    State[State[\"DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED\"] = 64] = \"DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED\";\n    State[State[\"DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED\"] = 65] = \"DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED\";\n    State[State[\"AFTER_DOCTYPE_SYSTEM_IDENTIFIER\"] = 66] = \"AFTER_DOCTYPE_SYSTEM_IDENTIFIER\";\n    State[State[\"BOGUS_DOCTYPE\"] = 67] = \"BOGUS_DOCTYPE\";\n    State[State[\"CDATA_SECTION\"] = 68] = \"CDATA_SECTION\";\n    State[State[\"CDATA_SECTION_BRACKET\"] = 69] = \"CDATA_SECTION_BRACKET\";\n    State[State[\"CDATA_SECTION_END\"] = 70] = \"CDATA_SECTION_END\";\n    State[State[\"CHARACTER_REFERENCE\"] = 71] = \"CHARACTER_REFERENCE\";\n    State[State[\"AMBIGUOUS_AMPERSAND\"] = 72] = \"AMBIGUOUS_AMPERSAND\";\n})(State || (State = {}));\n//Tokenizer initial states for different modes\nexport const TokenizerMode = {\n    DATA: State.DATA,\n    RCDATA: State.RCDATA,\n    RAWTEXT: State.RAWTEXT,\n    SCRIPT_DATA: State.SCRIPT_DATA,\n    PLAINTEXT: State.PLAINTEXT,\n    CDATA_SECTION: State.CDATA_SECTION,\n};\n//Utils\n//OPTIMIZATION: these utility functions should not be moved out of this module. V8 Crankshaft will not inline\n//this functions if they will be situated in another module due to context switch.\n//Always perform inlining check before modifying this functions ('node --trace-inlining').\nfunction isAsciiDigit(cp) {\n    return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;\n}\nfunction isAsciiUpper(cp) {\n    return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;\n}\nfunction isAsciiLower(cp) {\n    return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;\n}\nfunction isAsciiLetter(cp) {\n    return isAsciiLower(cp) || isAsciiUpper(cp);\n}\nfunction isAsciiAlphaNumeric(cp) {\n    return isAsciiLetter(cp) || isAsciiDigit(cp);\n}\nfunction toAsciiLower(cp) {\n    return cp + 32;\n}\nfunction isWhitespace(cp) {\n    return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;\n}\nfunction isScriptDataDoubleEscapeSequenceEnd(cp) {\n    return isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN;\n}\nfunction getErrorForNumericCharacterReference(code) {\n    if (code === $.NULL) {\n        return ERR.nullCharacterReference;\n    }\n    else if (code > 1114111) {\n        return ERR.characterReferenceOutsideUnicodeRange;\n    }\n    else if (isSurrogate(code)) {\n        return ERR.surrogateCharacterReference;\n    }\n    else if (isUndefinedCodePoint(code)) {\n        return ERR.noncharacterCharacterReference;\n    }\n    else if (isControlCodePoint(code) || code === $.CARRIAGE_RETURN) {\n        return ERR.controlCharacterReference;\n    }\n    return null;\n}\n//Tokenizer\nexport class Tokenizer {\n    constructor(options, handler) {\n        this.options = options;\n        this.handler = handler;\n        this.paused = false;\n        /** Ensures that the parsing loop isn't run multiple times at once. */\n        this.inLoop = false;\n        /**\n         * Indicates that the current adjusted node exists, is not an element in the HTML namespace,\n         * and that it is not an integration point for either MathML or HTML.\n         *\n         * @see {@link https://html.spec.whatwg.org/multipage/parsing.html#tree-construction}\n         */\n        this.inForeignNode = false;\n        this.lastStartTagName = '';\n        this.active = false;\n        this.state = State.DATA;\n        this.returnState = State.DATA;\n        this.entityStartPos = 0;\n        this.consumedAfterSnapshot = -1;\n        this.currentCharacterToken = null;\n        this.currentToken = null;\n        this.currentAttr = { name: '', value: '' };\n        this.preprocessor = new Preprocessor(handler);\n        this.currentLocation = this.getCurrentLocation(-1);\n        this.entityDecoder = new EntityDecoder(htmlDecodeTree, (cp, consumed) => {\n            // Note: Set `pos` _before_ flushing, as flushing might drop\n            // the current chunk and invalidate `entityStartPos`.\n            this.preprocessor.pos = this.entityStartPos + consumed - 1;\n            this._flushCodePointConsumedAsCharacterReference(cp);\n        }, handler.onParseError\n            ? {\n                missingSemicolonAfterCharacterReference: () => {\n                    this._err(ERR.missingSemicolonAfterCharacterReference, 1);\n                },\n                absenceOfDigitsInNumericCharacterReference: (consumed) => {\n                    this._err(ERR.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + consumed);\n                },\n                validateNumericCharacterReference: (code) => {\n                    const error = getErrorForNumericCharacterReference(code);\n                    if (error)\n                        this._err(error, 1);\n                },\n            }\n            : undefined);\n    }\n    //Errors\n    _err(code, cpOffset = 0) {\n        var _a, _b;\n        (_b = (_a = this.handler).onParseError) === null || _b === void 0 ? void 0 : _b.call(_a, this.preprocessor.getError(code, cpOffset));\n    }\n    // NOTE: `offset` may never run across line boundaries.\n    getCurrentLocation(offset) {\n        if (!this.options.sourceCodeLocationInfo) {\n            return null;\n        }\n        return {\n            startLine: this.preprocessor.line,\n            startCol: this.preprocessor.col - offset,\n            startOffset: this.preprocessor.offset - offset,\n            endLine: -1,\n            endCol: -1,\n            endOffset: -1,\n        };\n    }\n    _runParsingLoop() {\n        if (this.inLoop)\n            return;\n        this.inLoop = true;\n        while (this.active && !this.paused) {\n            this.consumedAfterSnapshot = 0;\n            const cp = this._consume();\n            if (!this._ensureHibernation()) {\n                this._callState(cp);\n            }\n        }\n        this.inLoop = false;\n    }\n    //API\n    pause() {\n        this.paused = true;\n    }\n    resume(writeCallback) {\n        if (!this.paused) {\n            throw new Error('Parser was already resumed');\n        }\n        this.paused = false;\n        // Necessary for synchronous resume.\n        if (this.inLoop)\n            return;\n        this._runParsingLoop();\n        if (!this.paused) {\n            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();\n        }\n    }\n    write(chunk, isLastChunk, writeCallback) {\n        this.active = true;\n        this.preprocessor.write(chunk, isLastChunk);\n        this._runParsingLoop();\n        if (!this.paused) {\n            writeCallback === null || writeCallback === void 0 ? void 0 : writeCallback();\n        }\n    }\n    insertHtmlAtCurrentPos(chunk) {\n        this.active = true;\n        this.preprocessor.insertHtmlAtCurrentPos(chunk);\n        this._runParsingLoop();\n    }\n    //Hibernation\n    _ensureHibernation() {\n        if (this.preprocessor.endOfChunkHit) {\n            this.preprocessor.retreat(this.consumedAfterSnapshot);\n            this.consumedAfterSnapshot = 0;\n            this.active = false;\n            return true;\n        }\n        return false;\n    }\n    //Consumption\n    _consume() {\n        this.consumedAfterSnapshot++;\n        return this.preprocessor.advance();\n    }\n    _advanceBy(count) {\n        this.consumedAfterSnapshot += count;\n        for (let i = 0; i < count; i++) {\n            this.preprocessor.advance();\n        }\n    }\n    _consumeSequenceIfMatch(pattern, caseSensitive) {\n        if (this.preprocessor.startsWith(pattern, caseSensitive)) {\n            // We will already have consumed one character before calling this method.\n            this._advanceBy(pattern.length - 1);\n            return true;\n        }\n        return false;\n    }\n    //Token creation\n    _createStartTagToken() {\n        this.currentToken = {\n            type: TokenType.START_TAG,\n            tagName: '',\n            tagID: TAG_ID.UNKNOWN,\n            selfClosing: false,\n            ackSelfClosing: false,\n            attrs: [],\n            location: this.getCurrentLocation(1),\n        };\n    }\n    _createEndTagToken() {\n        this.currentToken = {\n            type: TokenType.END_TAG,\n            tagName: '',\n            tagID: TAG_ID.UNKNOWN,\n            selfClosing: false,\n            ackSelfClosing: false,\n            attrs: [],\n            location: this.getCurrentLocation(2),\n        };\n    }\n    _createCommentToken(offset) {\n        this.currentToken = {\n            type: TokenType.COMMENT,\n            data: '',\n            location: this.getCurrentLocation(offset),\n        };\n    }\n    _createDoctypeToken(initialName) {\n        this.currentToken = {\n            type: TokenType.DOCTYPE,\n            name: initialName,\n            forceQuirks: false,\n            publicId: null,\n            systemId: null,\n            location: this.currentLocation,\n        };\n    }\n    _createCharacterToken(type, chars) {\n        this.currentCharacterToken = {\n            type,\n            chars,\n            location: this.currentLocation,\n        };\n    }\n    //Tag attributes\n    _createAttr(attrNameFirstCh) {\n        this.currentAttr = {\n            name: attrNameFirstCh,\n            value: '',\n        };\n        this.currentLocation = this.getCurrentLocation(0);\n    }\n    _leaveAttrName() {\n        var _a;\n        var _b;\n        const token = this.currentToken;\n        if (getTokenAttr(token, this.currentAttr.name) === null) {\n            token.attrs.push(this.currentAttr);\n            if (token.location && this.currentLocation) {\n                const attrLocations = ((_a = (_b = token.location).attrs) !== null && _a !== void 0 ? _a : (_b.attrs = Object.create(null)));\n                attrLocations[this.currentAttr.name] = this.currentLocation;\n                // Set end location\n                this._leaveAttrValue();\n            }\n        }\n        else {\n            this._err(ERR.duplicateAttribute);\n        }\n    }\n    _leaveAttrValue() {\n        if (this.currentLocation) {\n            this.currentLocation.endLine = this.preprocessor.line;\n            this.currentLocation.endCol = this.preprocessor.col;\n            this.currentLocation.endOffset = this.preprocessor.offset;\n        }\n    }\n    //Token emission\n    prepareToken(ct) {\n        this._emitCurrentCharacterToken(ct.location);\n        this.currentToken = null;\n        if (ct.location) {\n            ct.location.endLine = this.preprocessor.line;\n            ct.location.endCol = this.preprocessor.col + 1;\n            ct.location.endOffset = this.preprocessor.offset + 1;\n        }\n        this.currentLocation = this.getCurrentLocation(-1);\n    }\n    emitCurrentTagToken() {\n        const ct = this.currentToken;\n        this.prepareToken(ct);\n        ct.tagID = getTagID(ct.tagName);\n        if (ct.type === TokenType.START_TAG) {\n            this.lastStartTagName = ct.tagName;\n            this.handler.onStartTag(ct);\n        }\n        else {\n            if (ct.attrs.length > 0) {\n                this._err(ERR.endTagWithAttributes);\n            }\n            if (ct.selfClosing) {\n                this._err(ERR.endTagWithTrailingSolidus);\n            }\n            this.handler.onEndTag(ct);\n        }\n        this.preprocessor.dropParsedChunk();\n    }\n    emitCurrentComment(ct) {\n        this.prepareToken(ct);\n        this.handler.onComment(ct);\n        this.preprocessor.dropParsedChunk();\n    }\n    emitCurrentDoctype(ct) {\n        this.prepareToken(ct);\n        this.handler.onDoctype(ct);\n        this.preprocessor.dropParsedChunk();\n    }\n    _emitCurrentCharacterToken(nextLocation) {\n        if (this.currentCharacterToken) {\n            //NOTE: if we have a pending character token, make it's end location equal to the\n            //current token's start location.\n            if (nextLocation && this.currentCharacterToken.location) {\n                this.currentCharacterToken.location.endLine = nextLocation.startLine;\n                this.currentCharacterToken.location.endCol = nextLocation.startCol;\n                this.currentCharacterToken.location.endOffset = nextLocation.startOffset;\n            }\n            switch (this.currentCharacterToken.type) {\n                case TokenType.CHARACTER: {\n                    this.handler.onCharacter(this.currentCharacterToken);\n                    break;\n                }\n                case TokenType.NULL_CHARACTER: {\n                    this.handler.onNullCharacter(this.currentCharacterToken);\n                    break;\n                }\n                case TokenType.WHITESPACE_CHARACTER: {\n                    this.handler.onWhitespaceCharacter(this.currentCharacterToken);\n                    break;\n                }\n            }\n            this.currentCharacterToken = null;\n        }\n    }\n    _emitEOFToken() {\n        const location = this.getCurrentLocation(0);\n        if (location) {\n            location.endLine = location.startLine;\n            location.endCol = location.startCol;\n            location.endOffset = location.startOffset;\n        }\n        this._emitCurrentCharacterToken(location);\n        this.handler.onEof({ type: TokenType.EOF, location });\n        this.active = false;\n    }\n    //Characters emission\n    //OPTIMIZATION: The specification uses only one type of character token (one token per character).\n    //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.\n    //If we have a sequence of characters that belong to the same group, the parser can process it\n    //as a single solid character token.\n    //So, there are 3 types of character tokens in parse5:\n    //1)TokenType.NULL_CHARACTER - \\u0000-character sequences (e.g. '\\u0000\\u0000\\u0000')\n    //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\\n  \\r\\t   \\f')\n    //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')\n    _appendCharToCurrentCharacterToken(type, ch) {\n        if (this.currentCharacterToken) {\n            if (this.currentCharacterToken.type === type) {\n                this.currentCharacterToken.chars += ch;\n                return;\n            }\n            else {\n                this.currentLocation = this.getCurrentLocation(0);\n                this._emitCurrentCharacterToken(this.currentLocation);\n                this.preprocessor.dropParsedChunk();\n            }\n        }\n        this._createCharacterToken(type, ch);\n    }\n    _emitCodePoint(cp) {\n        const type = isWhitespace(cp)\n            ? TokenType.WHITESPACE_CHARACTER\n            : cp === $.NULL\n                ? TokenType.NULL_CHARACTER\n                : TokenType.CHARACTER;\n        this._appendCharToCurrentCharacterToken(type, String.fromCodePoint(cp));\n    }\n    //NOTE: used when we emit characters explicitly.\n    //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.\n    _emitChars(ch) {\n        this._appendCharToCurrentCharacterToken(TokenType.CHARACTER, ch);\n    }\n    // Character reference helpers\n    _startCharacterReference() {\n        this.returnState = this.state;\n        this.state = State.CHARACTER_REFERENCE;\n        this.entityStartPos = this.preprocessor.pos;\n        this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? DecodingMode.Attribute : DecodingMode.Legacy);\n    }\n    _isCharacterReferenceInAttribute() {\n        return (this.returnState === State.ATTRIBUTE_VALUE_DOUBLE_QUOTED ||\n            this.returnState === State.ATTRIBUTE_VALUE_SINGLE_QUOTED ||\n            this.returnState === State.ATTRIBUTE_VALUE_UNQUOTED);\n    }\n    _flushCodePointConsumedAsCharacterReference(cp) {\n        if (this._isCharacterReferenceInAttribute()) {\n            this.currentAttr.value += String.fromCodePoint(cp);\n        }\n        else {\n            this._emitCodePoint(cp);\n        }\n    }\n    // Calling states this way turns out to be much faster than any other approach.\n    _callState(cp) {\n        switch (this.state) {\n            case State.DATA: {\n                this._stateData(cp);\n                break;\n            }\n            case State.RCDATA: {\n                this._stateRcdata(cp);\n                break;\n            }\n            case State.RAWTEXT: {\n                this._stateRawtext(cp);\n                break;\n            }\n            case State.SCRIPT_DATA: {\n                this._stateScriptData(cp);\n                break;\n            }\n            case State.PLAINTEXT: {\n                this._statePlaintext(cp);\n                break;\n            }\n            case State.TAG_OPEN: {\n                this._stateTagOpen(cp);\n                break;\n            }\n            case State.END_TAG_OPEN: {\n                this._stateEndTagOpen(cp);\n                break;\n            }\n            case State.TAG_NAME: {\n                this._stateTagName(cp);\n                break;\n            }\n            case State.RCDATA_LESS_THAN_SIGN: {\n                this._stateRcdataLessThanSign(cp);\n                break;\n            }\n            case State.RCDATA_END_TAG_OPEN: {\n                this._stateRcdataEndTagOpen(cp);\n                break;\n            }\n            case State.RCDATA_END_TAG_NAME: {\n                this._stateRcdataEndTagName(cp);\n                break;\n            }\n            case State.RAWTEXT_LESS_THAN_SIGN: {\n                this._stateRawtextLessThanSign(cp);\n                break;\n            }\n            case State.RAWTEXT_END_TAG_OPEN: {\n                this._stateRawtextEndTagOpen(cp);\n                break;\n            }\n            case State.RAWTEXT_END_TAG_NAME: {\n                this._stateRawtextEndTagName(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_LESS_THAN_SIGN: {\n                this._stateScriptDataLessThanSign(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_END_TAG_OPEN: {\n                this._stateScriptDataEndTagOpen(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_END_TAG_NAME: {\n                this._stateScriptDataEndTagName(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPE_START: {\n                this._stateScriptDataEscapeStart(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPE_START_DASH: {\n                this._stateScriptDataEscapeStartDash(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPED: {\n                this._stateScriptDataEscaped(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPED_DASH: {\n                this._stateScriptDataEscapedDash(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPED_DASH_DASH: {\n                this._stateScriptDataEscapedDashDash(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {\n                this._stateScriptDataEscapedLessThanSign(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {\n                this._stateScriptDataEscapedEndTagOpen(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {\n                this._stateScriptDataEscapedEndTagName(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_DOUBLE_ESCAPE_START: {\n                this._stateScriptDataDoubleEscapeStart(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_DOUBLE_ESCAPED: {\n                this._stateScriptDataDoubleEscaped(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {\n                this._stateScriptDataDoubleEscapedDash(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {\n                this._stateScriptDataDoubleEscapedDashDash(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {\n                this._stateScriptDataDoubleEscapedLessThanSign(cp);\n                break;\n            }\n            case State.SCRIPT_DATA_DOUBLE_ESCAPE_END: {\n                this._stateScriptDataDoubleEscapeEnd(cp);\n                break;\n            }\n            case State.BEFORE_ATTRIBUTE_NAME: {\n                this._stateBeforeAttributeName(cp);\n                break;\n            }\n            case State.ATTRIBUTE_NAME: {\n                this._stateAttributeName(cp);\n                break;\n            }\n            case State.AFTER_ATTRIBUTE_NAME: {\n                this._stateAfterAttributeName(cp);\n                break;\n            }\n            case State.BEFORE_ATTRIBUTE_VALUE: {\n                this._stateBeforeAttributeValue(cp);\n                break;\n            }\n            case State.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {\n                this._stateAttributeValueDoubleQuoted(cp);\n                break;\n            }\n            case State.ATTRIBUTE_VALUE_SINGLE_QUOTED: {\n                this._stateAttributeValueSingleQuoted(cp);\n                break;\n            }\n            case State.ATTRIBUTE_VALUE_UNQUOTED: {\n                this._stateAttributeValueUnquoted(cp);\n                break;\n            }\n            case State.AFTER_ATTRIBUTE_VALUE_QUOTED: {\n                this._stateAfterAttributeValueQuoted(cp);\n                break;\n            }\n            case State.SELF_CLOSING_START_TAG: {\n                this._stateSelfClosingStartTag(cp);\n                break;\n            }\n            case State.BOGUS_COMMENT: {\n                this._stateBogusComment(cp);\n                break;\n            }\n            case State.MARKUP_DECLARATION_OPEN: {\n                this._stateMarkupDeclarationOpen(cp);\n                break;\n            }\n            case State.COMMENT_START: {\n                this._stateCommentStart(cp);\n                break;\n            }\n            case State.COMMENT_START_DASH: {\n                this._stateCommentStartDash(cp);\n                break;\n            }\n            case State.COMMENT: {\n                this._stateComment(cp);\n                break;\n            }\n            case State.COMMENT_LESS_THAN_SIGN: {\n                this._stateCommentLessThanSign(cp);\n                break;\n            }\n            case State.COMMENT_LESS_THAN_SIGN_BANG: {\n                this._stateCommentLessThanSignBang(cp);\n                break;\n            }\n            case State.COMMENT_LESS_THAN_SIGN_BANG_DASH: {\n                this._stateCommentLessThanSignBangDash(cp);\n                break;\n            }\n            case State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {\n                this._stateCommentLessThanSignBangDashDash(cp);\n                break;\n            }\n            case State.COMMENT_END_DASH: {\n                this._stateCommentEndDash(cp);\n                break;\n            }\n            case State.COMMENT_END: {\n                this._stateCommentEnd(cp);\n                break;\n            }\n            case State.COMMENT_END_BANG: {\n                this._stateCommentEndBang(cp);\n                break;\n            }\n            case State.DOCTYPE: {\n                this._stateDoctype(cp);\n                break;\n            }\n            case State.BEFORE_DOCTYPE_NAME: {\n                this._stateBeforeDoctypeName(cp);\n                break;\n            }\n            case State.DOCTYPE_NAME: {\n                this._stateDoctypeName(cp);\n                break;\n            }\n            case State.AFTER_DOCTYPE_NAME: {\n                this._stateAfterDoctypeName(cp);\n                break;\n            }\n            case State.AFTER_DOCTYPE_PUBLIC_KEYWORD: {\n                this._stateAfterDoctypePublicKeyword(cp);\n                break;\n            }\n            case State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {\n                this._stateBeforeDoctypePublicIdentifier(cp);\n                break;\n            }\n            case State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {\n                this._stateDoctypePublicIdentifierDoubleQuoted(cp);\n                break;\n            }\n            case State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {\n                this._stateDoctypePublicIdentifierSingleQuoted(cp);\n                break;\n            }\n            case State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {\n                this._stateAfterDoctypePublicIdentifier(cp);\n                break;\n            }\n            case State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {\n                this._stateBetweenDoctypePublicAndSystemIdentifiers(cp);\n                break;\n            }\n            case State.AFTER_DOCTYPE_SYSTEM_KEYWORD: {\n                this._stateAfterDoctypeSystemKeyword(cp);\n                break;\n            }\n            case State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {\n                this._stateBeforeDoctypeSystemIdentifier(cp);\n                break;\n            }\n            case State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {\n                this._stateDoctypeSystemIdentifierDoubleQuoted(cp);\n                break;\n            }\n            case State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {\n                this._stateDoctypeSystemIdentifierSingleQuoted(cp);\n                break;\n            }\n            case State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {\n                this._stateAfterDoctypeSystemIdentifier(cp);\n                break;\n            }\n            case State.BOGUS_DOCTYPE: {\n                this._stateBogusDoctype(cp);\n                break;\n            }\n            case State.CDATA_SECTION: {\n                this._stateCdataSection(cp);\n                break;\n            }\n            case State.CDATA_SECTION_BRACKET: {\n                this._stateCdataSectionBracket(cp);\n                break;\n            }\n            case State.CDATA_SECTION_END: {\n                this._stateCdataSectionEnd(cp);\n                break;\n            }\n            case State.CHARACTER_REFERENCE: {\n                this._stateCharacterReference();\n                break;\n            }\n            case State.AMBIGUOUS_AMPERSAND: {\n                this._stateAmbiguousAmpersand(cp);\n                break;\n            }\n            default: {\n                throw new Error('Unknown state');\n            }\n        }\n    }\n    // State machine\n    // Data state\n    //------------------------------------------------------------------\n    _stateData(cp) {\n        switch (cp) {\n            case $.LESS_THAN_SIGN: {\n                this.state = State.TAG_OPEN;\n                break;\n            }\n            case $.AMPERSAND: {\n                this._startCharacterReference();\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitCodePoint(cp);\n                break;\n            }\n            case $.EOF: {\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    //  RCDATA state\n    //------------------------------------------------------------------\n    _stateRcdata(cp) {\n        switch (cp) {\n            case $.AMPERSAND: {\n                this._startCharacterReference();\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.RCDATA_LESS_THAN_SIGN;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // RAWTEXT state\n    //------------------------------------------------------------------\n    _stateRawtext(cp) {\n        switch (cp) {\n            case $.LESS_THAN_SIGN: {\n                this.state = State.RAWTEXT_LESS_THAN_SIGN;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data state\n    //------------------------------------------------------------------\n    _stateScriptData(cp) {\n        switch (cp) {\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_LESS_THAN_SIGN;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // PLAINTEXT state\n    //------------------------------------------------------------------\n    _statePlaintext(cp) {\n        switch (cp) {\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Tag open state\n    //------------------------------------------------------------------\n    _stateTagOpen(cp) {\n        if (isAsciiLetter(cp)) {\n            this._createStartTagToken();\n            this.state = State.TAG_NAME;\n            this._stateTagName(cp);\n        }\n        else\n            switch (cp) {\n                case $.EXCLAMATION_MARK: {\n                    this.state = State.MARKUP_DECLARATION_OPEN;\n                    break;\n                }\n                case $.SOLIDUS: {\n                    this.state = State.END_TAG_OPEN;\n                    break;\n                }\n                case $.QUESTION_MARK: {\n                    this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);\n                    this._createCommentToken(1);\n                    this.state = State.BOGUS_COMMENT;\n                    this._stateBogusComment(cp);\n                    break;\n                }\n                case $.EOF: {\n                    this._err(ERR.eofBeforeTagName);\n                    this._emitChars('<');\n                    this._emitEOFToken();\n                    break;\n                }\n                default: {\n                    this._err(ERR.invalidFirstCharacterOfTagName);\n                    this._emitChars('<');\n                    this.state = State.DATA;\n                    this._stateData(cp);\n                }\n            }\n    }\n    // End tag open state\n    //------------------------------------------------------------------\n    _stateEndTagOpen(cp) {\n        if (isAsciiLetter(cp)) {\n            this._createEndTagToken();\n            this.state = State.TAG_NAME;\n            this._stateTagName(cp);\n        }\n        else\n            switch (cp) {\n                case $.GREATER_THAN_SIGN: {\n                    this._err(ERR.missingEndTagName);\n                    this.state = State.DATA;\n                    break;\n                }\n                case $.EOF: {\n                    this._err(ERR.eofBeforeTagName);\n                    this._emitChars('</');\n                    this._emitEOFToken();\n                    break;\n                }\n                default: {\n                    this._err(ERR.invalidFirstCharacterOfTagName);\n                    this._createCommentToken(2);\n                    this.state = State.BOGUS_COMMENT;\n                    this._stateBogusComment(cp);\n                }\n            }\n    }\n    // Tag name state\n    //------------------------------------------------------------------\n    _stateTagName(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this.state = State.BEFORE_ATTRIBUTE_NAME;\n                break;\n            }\n            case $.SOLIDUS: {\n                this.state = State.SELF_CLOSING_START_TAG;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentTagToken();\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.tagName += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.tagName += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);\n            }\n        }\n    }\n    // RCDATA less-than sign state\n    //------------------------------------------------------------------\n    _stateRcdataLessThanSign(cp) {\n        if (cp === $.SOLIDUS) {\n            this.state = State.RCDATA_END_TAG_OPEN;\n        }\n        else {\n            this._emitChars('<');\n            this.state = State.RCDATA;\n            this._stateRcdata(cp);\n        }\n    }\n    // RCDATA end tag open state\n    //------------------------------------------------------------------\n    _stateRcdataEndTagOpen(cp) {\n        if (isAsciiLetter(cp)) {\n            this.state = State.RCDATA_END_TAG_NAME;\n            this._stateRcdataEndTagName(cp);\n        }\n        else {\n            this._emitChars('</');\n            this.state = State.RCDATA;\n            this._stateRcdata(cp);\n        }\n    }\n    handleSpecialEndTag(_cp) {\n        if (!this.preprocessor.startsWith(this.lastStartTagName, false)) {\n            return !this._ensureHibernation();\n        }\n        this._createEndTagToken();\n        const token = this.currentToken;\n        token.tagName = this.lastStartTagName;\n        const cp = this.preprocessor.peek(this.lastStartTagName.length);\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this._advanceBy(this.lastStartTagName.length);\n                this.state = State.BEFORE_ATTRIBUTE_NAME;\n                return false;\n            }\n            case $.SOLIDUS: {\n                this._advanceBy(this.lastStartTagName.length);\n                this.state = State.SELF_CLOSING_START_TAG;\n                return false;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._advanceBy(this.lastStartTagName.length);\n                this.emitCurrentTagToken();\n                this.state = State.DATA;\n                return false;\n            }\n            default: {\n                return !this._ensureHibernation();\n            }\n        }\n    }\n    // RCDATA end tag name state\n    //------------------------------------------------------------------\n    _stateRcdataEndTagName(cp) {\n        if (this.handleSpecialEndTag(cp)) {\n            this._emitChars('</');\n            this.state = State.RCDATA;\n            this._stateRcdata(cp);\n        }\n    }\n    // RAWTEXT less-than sign state\n    //------------------------------------------------------------------\n    _stateRawtextLessThanSign(cp) {\n        if (cp === $.SOLIDUS) {\n            this.state = State.RAWTEXT_END_TAG_OPEN;\n        }\n        else {\n            this._emitChars('<');\n            this.state = State.RAWTEXT;\n            this._stateRawtext(cp);\n        }\n    }\n    // RAWTEXT end tag open state\n    //------------------------------------------------------------------\n    _stateRawtextEndTagOpen(cp) {\n        if (isAsciiLetter(cp)) {\n            this.state = State.RAWTEXT_END_TAG_NAME;\n            this._stateRawtextEndTagName(cp);\n        }\n        else {\n            this._emitChars('</');\n            this.state = State.RAWTEXT;\n            this._stateRawtext(cp);\n        }\n    }\n    // RAWTEXT end tag name state\n    //------------------------------------------------------------------\n    _stateRawtextEndTagName(cp) {\n        if (this.handleSpecialEndTag(cp)) {\n            this._emitChars('</');\n            this.state = State.RAWTEXT;\n            this._stateRawtext(cp);\n        }\n    }\n    // Script data less-than sign state\n    //------------------------------------------------------------------\n    _stateScriptDataLessThanSign(cp) {\n        switch (cp) {\n            case $.SOLIDUS: {\n                this.state = State.SCRIPT_DATA_END_TAG_OPEN;\n                break;\n            }\n            case $.EXCLAMATION_MARK: {\n                this.state = State.SCRIPT_DATA_ESCAPE_START;\n                this._emitChars('<!');\n                break;\n            }\n            default: {\n                this._emitChars('<');\n                this.state = State.SCRIPT_DATA;\n                this._stateScriptData(cp);\n            }\n        }\n    }\n    // Script data end tag open state\n    //------------------------------------------------------------------\n    _stateScriptDataEndTagOpen(cp) {\n        if (isAsciiLetter(cp)) {\n            this.state = State.SCRIPT_DATA_END_TAG_NAME;\n            this._stateScriptDataEndTagName(cp);\n        }\n        else {\n            this._emitChars('</');\n            this.state = State.SCRIPT_DATA;\n            this._stateScriptData(cp);\n        }\n    }\n    // Script data end tag name state\n    //------------------------------------------------------------------\n    _stateScriptDataEndTagName(cp) {\n        if (this.handleSpecialEndTag(cp)) {\n            this._emitChars('</');\n            this.state = State.SCRIPT_DATA;\n            this._stateScriptData(cp);\n        }\n    }\n    // Script data escape start state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapeStart(cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = State.SCRIPT_DATA_ESCAPE_START_DASH;\n            this._emitChars('-');\n        }\n        else {\n            this.state = State.SCRIPT_DATA;\n            this._stateScriptData(cp);\n        }\n    }\n    // Script data escape start dash state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapeStartDash(cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;\n            this._emitChars('-');\n        }\n        else {\n            this.state = State.SCRIPT_DATA;\n            this._stateScriptData(cp);\n        }\n    }\n    // Script data escaped state\n    //------------------------------------------------------------------\n    _stateScriptDataEscaped(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.SCRIPT_DATA_ESCAPED_DASH;\n                this._emitChars('-');\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInScriptHtmlCommentLikeText);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data escaped dash state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapedDash(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.SCRIPT_DATA_ESCAPED_DASH_DASH;\n                this._emitChars('-');\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.state = State.SCRIPT_DATA_ESCAPED;\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInScriptHtmlCommentLikeText);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.state = State.SCRIPT_DATA_ESCAPED;\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data escaped dash dash state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapedDashDash(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this._emitChars('-');\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA;\n                this._emitChars('>');\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.state = State.SCRIPT_DATA_ESCAPED;\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInScriptHtmlCommentLikeText);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.state = State.SCRIPT_DATA_ESCAPED;\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data escaped less-than sign state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapedLessThanSign(cp) {\n        if (cp === $.SOLIDUS) {\n            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_OPEN;\n        }\n        else if (isAsciiLetter(cp)) {\n            this._emitChars('<');\n            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_START;\n            this._stateScriptDataDoubleEscapeStart(cp);\n        }\n        else {\n            this._emitChars('<');\n            this.state = State.SCRIPT_DATA_ESCAPED;\n            this._stateScriptDataEscaped(cp);\n        }\n    }\n    // Script data escaped end tag open state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapedEndTagOpen(cp) {\n        if (isAsciiLetter(cp)) {\n            this.state = State.SCRIPT_DATA_ESCAPED_END_TAG_NAME;\n            this._stateScriptDataEscapedEndTagName(cp);\n        }\n        else {\n            this._emitChars('</');\n            this.state = State.SCRIPT_DATA_ESCAPED;\n            this._stateScriptDataEscaped(cp);\n        }\n    }\n    // Script data escaped end tag name state\n    //------------------------------------------------------------------\n    _stateScriptDataEscapedEndTagName(cp) {\n        if (this.handleSpecialEndTag(cp)) {\n            this._emitChars('</');\n            this.state = State.SCRIPT_DATA_ESCAPED;\n            this._stateScriptDataEscaped(cp);\n        }\n    }\n    // Script data double escape start state\n    //------------------------------------------------------------------\n    _stateScriptDataDoubleEscapeStart(cp) {\n        if (this.preprocessor.startsWith($$.SCRIPT, false) &&\n            isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek($$.SCRIPT.length))) {\n            this._emitCodePoint(cp);\n            for (let i = 0; i < $$.SCRIPT.length; i++) {\n                this._emitCodePoint(this._consume());\n            }\n            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n        }\n        else if (!this._ensureHibernation()) {\n            this.state = State.SCRIPT_DATA_ESCAPED;\n            this._stateScriptDataEscaped(cp);\n        }\n    }\n    // Script data double escaped state\n    //------------------------------------------------------------------\n    _stateScriptDataDoubleEscaped(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH;\n                this._emitChars('-');\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;\n                this._emitChars('<');\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInScriptHtmlCommentLikeText);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data double escaped dash state\n    //------------------------------------------------------------------\n    _stateScriptDataDoubleEscapedDash(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH;\n                this._emitChars('-');\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;\n                this._emitChars('<');\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInScriptHtmlCommentLikeText);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data double escaped dash dash state\n    //------------------------------------------------------------------\n    _stateScriptDataDoubleEscapedDashDash(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this._emitChars('-');\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN;\n                this._emitChars('<');\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.SCRIPT_DATA;\n                this._emitChars('>');\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n                this._emitChars(REPLACEMENT_CHARACTER);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInScriptHtmlCommentLikeText);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // Script data double escaped less-than sign state\n    //------------------------------------------------------------------\n    _stateScriptDataDoubleEscapedLessThanSign(cp) {\n        if (cp === $.SOLIDUS) {\n            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPE_END;\n            this._emitChars('/');\n        }\n        else {\n            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n            this._stateScriptDataDoubleEscaped(cp);\n        }\n    }\n    // Script data double escape end state\n    //------------------------------------------------------------------\n    _stateScriptDataDoubleEscapeEnd(cp) {\n        if (this.preprocessor.startsWith($$.SCRIPT, false) &&\n            isScriptDataDoubleEscapeSequenceEnd(this.preprocessor.peek($$.SCRIPT.length))) {\n            this._emitCodePoint(cp);\n            for (let i = 0; i < $$.SCRIPT.length; i++) {\n                this._emitCodePoint(this._consume());\n            }\n            this.state = State.SCRIPT_DATA_ESCAPED;\n        }\n        else if (!this._ensureHibernation()) {\n            this.state = State.SCRIPT_DATA_DOUBLE_ESCAPED;\n            this._stateScriptDataDoubleEscaped(cp);\n        }\n    }\n    // Before attribute name state\n    //------------------------------------------------------------------\n    _stateBeforeAttributeName(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.SOLIDUS:\n            case $.GREATER_THAN_SIGN:\n            case $.EOF: {\n                this.state = State.AFTER_ATTRIBUTE_NAME;\n                this._stateAfterAttributeName(cp);\n                break;\n            }\n            case $.EQUALS_SIGN: {\n                this._err(ERR.unexpectedEqualsSignBeforeAttributeName);\n                this._createAttr('=');\n                this.state = State.ATTRIBUTE_NAME;\n                break;\n            }\n            default: {\n                this._createAttr('');\n                this.state = State.ATTRIBUTE_NAME;\n                this._stateAttributeName(cp);\n            }\n        }\n    }\n    // Attribute name state\n    //------------------------------------------------------------------\n    _stateAttributeName(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED:\n            case $.SOLIDUS:\n            case $.GREATER_THAN_SIGN:\n            case $.EOF: {\n                this._leaveAttrName();\n                this.state = State.AFTER_ATTRIBUTE_NAME;\n                this._stateAfterAttributeName(cp);\n                break;\n            }\n            case $.EQUALS_SIGN: {\n                this._leaveAttrName();\n                this.state = State.BEFORE_ATTRIBUTE_VALUE;\n                break;\n            }\n            case $.QUOTATION_MARK:\n            case $.APOSTROPHE:\n            case $.LESS_THAN_SIGN: {\n                this._err(ERR.unexpectedCharacterInAttributeName);\n                this.currentAttr.name += String.fromCodePoint(cp);\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.currentAttr.name += REPLACEMENT_CHARACTER;\n                break;\n            }\n            default: {\n                this.currentAttr.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);\n            }\n        }\n    }\n    // After attribute name state\n    //------------------------------------------------------------------\n    _stateAfterAttributeName(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.SOLIDUS: {\n                this.state = State.SELF_CLOSING_START_TAG;\n                break;\n            }\n            case $.EQUALS_SIGN: {\n                this.state = State.BEFORE_ATTRIBUTE_VALUE;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentTagToken();\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._createAttr('');\n                this.state = State.ATTRIBUTE_NAME;\n                this._stateAttributeName(cp);\n            }\n        }\n    }\n    // Before attribute value state\n    //------------------------------------------------------------------\n    _stateBeforeAttributeValue(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                this.state = State.ATTRIBUTE_VALUE_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                this.state = State.ATTRIBUTE_VALUE_SINGLE_QUOTED;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.missingAttributeValue);\n                this.state = State.DATA;\n                this.emitCurrentTagToken();\n                break;\n            }\n            default: {\n                this.state = State.ATTRIBUTE_VALUE_UNQUOTED;\n                this._stateAttributeValueUnquoted(cp);\n            }\n        }\n    }\n    // Attribute value (double-quoted) state\n    //------------------------------------------------------------------\n    _stateAttributeValueDoubleQuoted(cp) {\n        switch (cp) {\n            case $.QUOTATION_MARK: {\n                this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;\n                break;\n            }\n            case $.AMPERSAND: {\n                this._startCharacterReference();\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.currentAttr.value += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.currentAttr.value += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // Attribute value (single-quoted) state\n    //------------------------------------------------------------------\n    _stateAttributeValueSingleQuoted(cp) {\n        switch (cp) {\n            case $.APOSTROPHE: {\n                this.state = State.AFTER_ATTRIBUTE_VALUE_QUOTED;\n                break;\n            }\n            case $.AMPERSAND: {\n                this._startCharacterReference();\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.currentAttr.value += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.currentAttr.value += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // Attribute value (unquoted) state\n    //------------------------------------------------------------------\n    _stateAttributeValueUnquoted(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this._leaveAttrValue();\n                this.state = State.BEFORE_ATTRIBUTE_NAME;\n                break;\n            }\n            case $.AMPERSAND: {\n                this._startCharacterReference();\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._leaveAttrValue();\n                this.state = State.DATA;\n                this.emitCurrentTagToken();\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                this.currentAttr.value += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.QUOTATION_MARK:\n            case $.APOSTROPHE:\n            case $.LESS_THAN_SIGN:\n            case $.EQUALS_SIGN:\n            case $.GRAVE_ACCENT: {\n                this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);\n                this.currentAttr.value += String.fromCodePoint(cp);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this.currentAttr.value += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // After attribute value (quoted) state\n    //------------------------------------------------------------------\n    _stateAfterAttributeValueQuoted(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this._leaveAttrValue();\n                this.state = State.BEFORE_ATTRIBUTE_NAME;\n                break;\n            }\n            case $.SOLIDUS: {\n                this._leaveAttrValue();\n                this.state = State.SELF_CLOSING_START_TAG;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._leaveAttrValue();\n                this.state = State.DATA;\n                this.emitCurrentTagToken();\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingWhitespaceBetweenAttributes);\n                this.state = State.BEFORE_ATTRIBUTE_NAME;\n                this._stateBeforeAttributeName(cp);\n            }\n        }\n    }\n    // Self-closing start tag state\n    //------------------------------------------------------------------\n    _stateSelfClosingStartTag(cp) {\n        switch (cp) {\n            case $.GREATER_THAN_SIGN: {\n                const token = this.currentToken;\n                token.selfClosing = true;\n                this.state = State.DATA;\n                this.emitCurrentTagToken();\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInTag);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.unexpectedSolidusInTag);\n                this.state = State.BEFORE_ATTRIBUTE_NAME;\n                this._stateBeforeAttributeName(cp);\n            }\n        }\n    }\n    // Bogus comment state\n    //------------------------------------------------------------------\n    _stateBogusComment(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentComment(token);\n                break;\n            }\n            case $.EOF: {\n                this.emitCurrentComment(token);\n                this._emitEOFToken();\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.data += REPLACEMENT_CHARACTER;\n                break;\n            }\n            default: {\n                token.data += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // Markup declaration open state\n    //------------------------------------------------------------------\n    _stateMarkupDeclarationOpen(cp) {\n        if (this._consumeSequenceIfMatch($$.DASH_DASH, true)) {\n            this._createCommentToken($$.DASH_DASH.length + 1);\n            this.state = State.COMMENT_START;\n        }\n        else if (this._consumeSequenceIfMatch($$.DOCTYPE, false)) {\n            // NOTE: Doctypes tokens are created without fixed offsets. We keep track of the moment a doctype *might* start here.\n            this.currentLocation = this.getCurrentLocation($$.DOCTYPE.length + 1);\n            this.state = State.DOCTYPE;\n        }\n        else if (this._consumeSequenceIfMatch($$.CDATA_START, true)) {\n            if (this.inForeignNode) {\n                this.state = State.CDATA_SECTION;\n            }\n            else {\n                this._err(ERR.cdataInHtmlContent);\n                this._createCommentToken($$.CDATA_START.length + 1);\n                this.currentToken.data = '[CDATA[';\n                this.state = State.BOGUS_COMMENT;\n            }\n        }\n        //NOTE: Sequence lookups can be abrupted by hibernation. In that case, lookup\n        //results are no longer valid and we will need to start over.\n        else if (!this._ensureHibernation()) {\n            this._err(ERR.incorrectlyOpenedComment);\n            this._createCommentToken(2);\n            this.state = State.BOGUS_COMMENT;\n            this._stateBogusComment(cp);\n        }\n    }\n    // Comment start state\n    //------------------------------------------------------------------\n    _stateCommentStart(cp) {\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.COMMENT_START_DASH;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.abruptClosingOfEmptyComment);\n                this.state = State.DATA;\n                const token = this.currentToken;\n                this.emitCurrentComment(token);\n                break;\n            }\n            default: {\n                this.state = State.COMMENT;\n                this._stateComment(cp);\n            }\n        }\n    }\n    // Comment start dash state\n    //------------------------------------------------------------------\n    _stateCommentStartDash(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.COMMENT_END;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.abruptClosingOfEmptyComment);\n                this.state = State.DATA;\n                this.emitCurrentComment(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInComment);\n                this.emitCurrentComment(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.data += '-';\n                this.state = State.COMMENT;\n                this._stateComment(cp);\n            }\n        }\n    }\n    // Comment state\n    //------------------------------------------------------------------\n    _stateComment(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.COMMENT_END_DASH;\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                token.data += '<';\n                this.state = State.COMMENT_LESS_THAN_SIGN;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.data += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInComment);\n                this.emitCurrentComment(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.data += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // Comment less-than sign state\n    //------------------------------------------------------------------\n    _stateCommentLessThanSign(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.EXCLAMATION_MARK: {\n                token.data += '!';\n                this.state = State.COMMENT_LESS_THAN_SIGN_BANG;\n                break;\n            }\n            case $.LESS_THAN_SIGN: {\n                token.data += '<';\n                break;\n            }\n            default: {\n                this.state = State.COMMENT;\n                this._stateComment(cp);\n            }\n        }\n    }\n    // Comment less-than sign bang state\n    //------------------------------------------------------------------\n    _stateCommentLessThanSignBang(cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH;\n        }\n        else {\n            this.state = State.COMMENT;\n            this._stateComment(cp);\n        }\n    }\n    // Comment less-than sign bang dash state\n    //------------------------------------------------------------------\n    _stateCommentLessThanSignBangDash(cp) {\n        if (cp === $.HYPHEN_MINUS) {\n            this.state = State.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH;\n        }\n        else {\n            this.state = State.COMMENT_END_DASH;\n            this._stateCommentEndDash(cp);\n        }\n    }\n    // Comment less-than sign bang dash dash state\n    //------------------------------------------------------------------\n    _stateCommentLessThanSignBangDashDash(cp) {\n        if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {\n            this._err(ERR.nestedComment);\n        }\n        this.state = State.COMMENT_END;\n        this._stateCommentEnd(cp);\n    }\n    // Comment end dash state\n    //------------------------------------------------------------------\n    _stateCommentEndDash(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                this.state = State.COMMENT_END;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInComment);\n                this.emitCurrentComment(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.data += '-';\n                this.state = State.COMMENT;\n                this._stateComment(cp);\n            }\n        }\n    }\n    // Comment end state\n    //------------------------------------------------------------------\n    _stateCommentEnd(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentComment(token);\n                break;\n            }\n            case $.EXCLAMATION_MARK: {\n                this.state = State.COMMENT_END_BANG;\n                break;\n            }\n            case $.HYPHEN_MINUS: {\n                token.data += '-';\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInComment);\n                this.emitCurrentComment(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.data += '--';\n                this.state = State.COMMENT;\n                this._stateComment(cp);\n            }\n        }\n    }\n    // Comment end bang state\n    //------------------------------------------------------------------\n    _stateCommentEndBang(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.HYPHEN_MINUS: {\n                token.data += '--!';\n                this.state = State.COMMENT_END_DASH;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.incorrectlyClosedComment);\n                this.state = State.DATA;\n                this.emitCurrentComment(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInComment);\n                this.emitCurrentComment(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.data += '--!';\n                this.state = State.COMMENT;\n                this._stateComment(cp);\n            }\n        }\n    }\n    // DOCTYPE state\n    //------------------------------------------------------------------\n    _stateDoctype(cp) {\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this.state = State.BEFORE_DOCTYPE_NAME;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.BEFORE_DOCTYPE_NAME;\n                this._stateBeforeDoctypeName(cp);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                this._createDoctypeToken(null);\n                const token = this.currentToken;\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingWhitespaceBeforeDoctypeName);\n                this.state = State.BEFORE_DOCTYPE_NAME;\n                this._stateBeforeDoctypeName(cp);\n            }\n        }\n    }\n    // Before DOCTYPE name state\n    //------------------------------------------------------------------\n    _stateBeforeDoctypeName(cp) {\n        if (isAsciiUpper(cp)) {\n            this._createDoctypeToken(String.fromCharCode(toAsciiLower(cp)));\n            this.state = State.DOCTYPE_NAME;\n        }\n        else\n            switch (cp) {\n                case $.SPACE:\n                case $.LINE_FEED:\n                case $.TABULATION:\n                case $.FORM_FEED: {\n                    // Ignore whitespace\n                    break;\n                }\n                case $.NULL: {\n                    this._err(ERR.unexpectedNullCharacter);\n                    this._createDoctypeToken(REPLACEMENT_CHARACTER);\n                    this.state = State.DOCTYPE_NAME;\n                    break;\n                }\n                case $.GREATER_THAN_SIGN: {\n                    this._err(ERR.missingDoctypeName);\n                    this._createDoctypeToken(null);\n                    const token = this.currentToken;\n                    token.forceQuirks = true;\n                    this.emitCurrentDoctype(token);\n                    this.state = State.DATA;\n                    break;\n                }\n                case $.EOF: {\n                    this._err(ERR.eofInDoctype);\n                    this._createDoctypeToken(null);\n                    const token = this.currentToken;\n                    token.forceQuirks = true;\n                    this.emitCurrentDoctype(token);\n                    this._emitEOFToken();\n                    break;\n                }\n                default: {\n                    this._createDoctypeToken(String.fromCodePoint(cp));\n                    this.state = State.DOCTYPE_NAME;\n                }\n            }\n    }\n    // DOCTYPE name state\n    //------------------------------------------------------------------\n    _stateDoctypeName(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this.state = State.AFTER_DOCTYPE_NAME;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.name += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.name += String.fromCodePoint(isAsciiUpper(cp) ? toAsciiLower(cp) : cp);\n            }\n        }\n    }\n    // After DOCTYPE name state\n    //------------------------------------------------------------------\n    _stateAfterDoctypeName(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                if (this._consumeSequenceIfMatch($$.PUBLIC, false)) {\n                    this.state = State.AFTER_DOCTYPE_PUBLIC_KEYWORD;\n                }\n                else if (this._consumeSequenceIfMatch($$.SYSTEM, false)) {\n                    this.state = State.AFTER_DOCTYPE_SYSTEM_KEYWORD;\n                }\n                //NOTE: sequence lookup can be abrupted by hibernation. In that case lookup\n                //results are no longer valid and we will need to start over.\n                else if (!this._ensureHibernation()) {\n                    this._err(ERR.invalidCharacterSequenceAfterDoctypeName);\n                    token.forceQuirks = true;\n                    this.state = State.BOGUS_DOCTYPE;\n                    this._stateBogusDoctype(cp);\n                }\n            }\n        }\n    }\n    // After DOCTYPE public keyword state\n    //------------------------------------------------------------------\n    _stateAfterDoctypePublicKeyword(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this.state = State.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);\n                token.publicId = '';\n                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);\n                token.publicId = '';\n                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.missingDoctypePublicIdentifier);\n                token.forceQuirks = true;\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);\n                token.forceQuirks = true;\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // Before DOCTYPE public identifier state\n    //------------------------------------------------------------------\n    _stateBeforeDoctypePublicIdentifier(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                token.publicId = '';\n                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                token.publicId = '';\n                this.state = State.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.missingDoctypePublicIdentifier);\n                token.forceQuirks = true;\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);\n                token.forceQuirks = true;\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // DOCTYPE public identifier (double-quoted) state\n    //------------------------------------------------------------------\n    _stateDoctypePublicIdentifierDoubleQuoted(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.QUOTATION_MARK: {\n                this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.publicId += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.abruptDoctypePublicIdentifier);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.publicId += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // DOCTYPE public identifier (single-quoted) state\n    //------------------------------------------------------------------\n    _stateDoctypePublicIdentifierSingleQuoted(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.APOSTROPHE: {\n                this.state = State.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.publicId += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.abruptDoctypePublicIdentifier);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.publicId += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // After DOCTYPE public identifier state\n    //------------------------------------------------------------------\n    _stateAfterDoctypePublicIdentifier(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this.state = State.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // Between DOCTYPE public and system identifiers state\n    //------------------------------------------------------------------\n    _stateBetweenDoctypePublicAndSystemIdentifiers(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // After DOCTYPE system keyword state\n    //------------------------------------------------------------------\n    _stateAfterDoctypeSystemKeyword(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                this.state = State.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.missingDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // Before DOCTYPE system identifier state\n    //------------------------------------------------------------------\n    _stateBeforeDoctypeSystemIdentifier(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.QUOTATION_MARK: {\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;\n                break;\n            }\n            case $.APOSTROPHE: {\n                token.systemId = '';\n                this.state = State.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.missingDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.state = State.DATA;\n                this.emitCurrentDoctype(token);\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // DOCTYPE system identifier (double-quoted) state\n    //------------------------------------------------------------------\n    _stateDoctypeSystemIdentifierDoubleQuoted(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.QUOTATION_MARK: {\n                this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.systemId += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.abruptDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.systemId += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // DOCTYPE system identifier (single-quoted) state\n    //------------------------------------------------------------------\n    _stateDoctypeSystemIdentifierSingleQuoted(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.APOSTROPHE: {\n                this.state = State.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                token.systemId += REPLACEMENT_CHARACTER;\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this._err(ERR.abruptDoctypeSystemIdentifier);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                token.systemId += String.fromCodePoint(cp);\n            }\n        }\n    }\n    // After DOCTYPE system identifier state\n    //------------------------------------------------------------------\n    _stateAfterDoctypeSystemIdentifier(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.SPACE:\n            case $.LINE_FEED:\n            case $.TABULATION:\n            case $.FORM_FEED: {\n                // Ignore whitespace\n                break;\n            }\n            case $.GREATER_THAN_SIGN: {\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInDoctype);\n                token.forceQuirks = true;\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);\n                this.state = State.BOGUS_DOCTYPE;\n                this._stateBogusDoctype(cp);\n            }\n        }\n    }\n    // Bogus DOCTYPE state\n    //------------------------------------------------------------------\n    _stateBogusDoctype(cp) {\n        const token = this.currentToken;\n        switch (cp) {\n            case $.GREATER_THAN_SIGN: {\n                this.emitCurrentDoctype(token);\n                this.state = State.DATA;\n                break;\n            }\n            case $.NULL: {\n                this._err(ERR.unexpectedNullCharacter);\n                break;\n            }\n            case $.EOF: {\n                this.emitCurrentDoctype(token);\n                this._emitEOFToken();\n                break;\n            }\n            default:\n            // Do nothing\n        }\n    }\n    // CDATA section state\n    //------------------------------------------------------------------\n    _stateCdataSection(cp) {\n        switch (cp) {\n            case $.RIGHT_SQUARE_BRACKET: {\n                this.state = State.CDATA_SECTION_BRACKET;\n                break;\n            }\n            case $.EOF: {\n                this._err(ERR.eofInCdata);\n                this._emitEOFToken();\n                break;\n            }\n            default: {\n                this._emitCodePoint(cp);\n            }\n        }\n    }\n    // CDATA section bracket state\n    //------------------------------------------------------------------\n    _stateCdataSectionBracket(cp) {\n        if (cp === $.RIGHT_SQUARE_BRACKET) {\n            this.state = State.CDATA_SECTION_END;\n        }\n        else {\n            this._emitChars(']');\n            this.state = State.CDATA_SECTION;\n            this._stateCdataSection(cp);\n        }\n    }\n    // CDATA section end state\n    //------------------------------------------------------------------\n    _stateCdataSectionEnd(cp) {\n        switch (cp) {\n            case $.GREATER_THAN_SIGN: {\n                this.state = State.DATA;\n                break;\n            }\n            case $.RIGHT_SQUARE_BRACKET: {\n                this._emitChars(']');\n                break;\n            }\n            default: {\n                this._emitChars(']]');\n                this.state = State.CDATA_SECTION;\n                this._stateCdataSection(cp);\n            }\n        }\n    }\n    // Character reference state\n    //------------------------------------------------------------------\n    _stateCharacterReference() {\n        let length = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);\n        if (length < 0) {\n            if (this.preprocessor.lastChunkWritten) {\n                length = this.entityDecoder.end();\n            }\n            else {\n                // Wait for the rest of the entity.\n                this.active = false;\n                // Mark the entire buffer as read.\n                this.preprocessor.pos = this.preprocessor.html.length - 1;\n                this.consumedAfterSnapshot = 0;\n                this.preprocessor.endOfChunkHit = true;\n                return;\n            }\n        }\n        if (length === 0) {\n            // This was not a valid entity. Go back to the beginning, and\n            // figure out what to do.\n            this.preprocessor.pos = this.entityStartPos;\n            this._flushCodePointConsumedAsCharacterReference($.AMPERSAND);\n            this.state =\n                !this._isCharacterReferenceInAttribute() && isAsciiAlphaNumeric(this.preprocessor.peek(1))\n                    ? State.AMBIGUOUS_AMPERSAND\n                    : this.returnState;\n        }\n        else {\n            // We successfully parsed an entity. Switch to the return state.\n            this.state = this.returnState;\n        }\n    }\n    // Ambiguos ampersand state\n    //------------------------------------------------------------------\n    _stateAmbiguousAmpersand(cp) {\n        if (isAsciiAlphaNumeric(cp)) {\n            this._flushCodePointConsumedAsCharacterReference(cp);\n        }\n        else {\n            if (cp === $.SEMICOLON) {\n                this._err(ERR.unknownNamedCharacterReference);\n            }\n            this.state = this.returnState;\n            this._callState(cp);\n        }\n    }\n}\n"],"names":[],"sourceRoot":"","ignoreList":[0,1,2]}