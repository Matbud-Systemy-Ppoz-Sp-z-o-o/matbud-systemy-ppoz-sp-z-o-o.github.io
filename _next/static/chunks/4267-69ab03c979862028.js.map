{"version":3,"file":"static/chunks/4267-69ab03c979862028.js","mappings":"8JA+CIA,+NA+jBqB,SAATC,SAAAA,6BAiDKC,sBA9jBkB,SAAjBC,SAAAA,QAAiB,2BAvFH,WAK7B,WACgC,eACC,YACJ,WACA,eACnB,YACkD,UACpC,WACE,UACD,WACF,WACO,OACF,eACT,WACA,WACG,WACE,WACH,WACA,WACA,WACD,UACS,WACG,WACH,WACT,WACL,UACD,WACS,WAC2B,WAErB,OAuCpC,SAASC,IACP,OAAOC,OAAOC,MAAM,CAAC,qBAA4B,CAA5B,MAAU,mBAAV,+DAA2B,GAAG,CACjDC,WAAW,CACb,EACF,CASO,SAAeJ,EACpBK,CAAkC,8BAOhBC,EAAY,MAAGC,EAAL,+CALX,SAAMC,QAAQC,OAAO,CACpCJ,EAAQK,MAAM,CAACC,UAAU,CAACC,aAAa,YAEzC,GAAI,CAACC,CAHCA,EAAAA,EAAAA,IAAAA,EAAAA,EAGS,UAAO,GAatB,OAXyD,EAAxBN,GAAAA,EAAAA,SAAAA,EAAUF,EAAQS,MAAM,EAAjDC,QAAAA,CAEFC,EAAYC,CAAAA,EAAAA,EAAAA,WAAAA,EAAYX,GAC1BY,CAAAA,EAAAA,EAAAA,cAAAA,EAAeZ,GACfA,EACEa,EAA0BC,CAAAA,EAAAA,EAAAA,WAAAA,EAC9BC,CAAAA,EAAAA,EAAAA,SAAAA,EAAUL,EAAWX,EAAQiB,MAAM,GAKrC,GAAOT,EAASU,IAAI,CAAC,SAACC,CAAAA,SACpB,IAAIC,OAAOD,EAAEE,MAAM,EAAEC,IAAI,CAACR,QAE9B,KAEA,SAASS,EAAYC,CAAW,EAC9B,IAAMC,EAASC,CAAAA,EAAAA,EAAAA,iBAAAA,IAEf,OAAOF,EAAIG,UAAU,CAACF,GAAUD,EAAII,SAAS,CAACH,EAAOI,MAAM,EAAIL,CACjE,CAEA,SAASM,EAAazB,CAAkB,CAAEmB,CAAQ,CAAEO,CAAQ,EAG1D,IAAI,MAA6BC,CAAAA,EAAAA,EAAAA,WAAAA,EAAY3B,EAAQmB,EAAK,OAArDS,EAAAA,CAAAA,CAAAA,EAAAA,CAAcC,EAAW,KACxBT,EAASC,CAAAA,CADe,CACfA,EAAAA,iBAAAA,IACTS,EAAkBF,EAAaN,UAAU,CAACF,GAC1CW,EAAgBF,GAAcA,EAAWP,UAAU,CAACF,GAE1DQ,EAAeV,EAAYU,GAC3BC,EAAaA,EAAaX,EAAYW,GAAcA,EAEpD,IAAMG,EAAcF,EAAkBF,EAAelB,CAAAA,EAAAA,EAAAA,WAAAA,EAAYkB,GAC3DK,EAAaP,EACfR,EAAYS,CAAAA,EAAAA,EAAAA,WAAAA,EAAY3B,EAAQ0B,IAChCG,GAAcD,EAElB,MAAO,CACLT,IAAKa,EACLN,GAAIK,EAAgBE,EAAavB,CAAAA,EAAAA,EAAAA,WAAAA,EAAYuB,EAC/C,CACF,CAEA,SAASC,EAAoB7B,CAAgB,CAAE8B,CAAe,EAC5D,IAAMC,EAAgBC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBjC,UAC9D,SAAI+B,GAA4BA,WAA6B,GACpD/B,GAIL,EAAOkC,QAAQ,CAACH,IAElBD,EAAMtB,IAAI,CAAC,KAFuB,IAEtB2B,CAAAA,EACV,GAAIC,CAAAA,EAAAA,EAAAA,cAAAA,EAAeD,IAASE,CAAAA,EAAAA,EAAAA,aAAAA,EAAcF,GAAMG,EAAE,CAAC1B,IAAI,CAACmB,GAEtD,OADA/B,EAAWmC,GACJ,CAF+D,GAMrEH,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBhC,GAC7B,CA+JA,SAAeuC,EACbjD,CAAkC,8BAS5BkD,8DAPgBvD,EAAkBK,WACxC,GAAI,CADY,UACA,CAACA,EAAQmD,SAAS,CAChC,CADkC,KAClC,GAAO,eAGUnD,EAAQmD,SAAS,WAErB,SAAMC,SAtKrBC,CAAc,CACdC,CAAkB,CAClBtD,CAAkC,EAElC,IAAMuD,EAAa,CACjBC,SAAUxD,EAAQK,MAAM,CAACmD,QAAQ,CACjCC,KAAM,CAAEC,QAAS1D,EAAQK,MAAM,CAACqD,OAAO,EACvCC,eAAeC,CACjB,EACMC,CAFoD,CAEpCP,EAASQ,OAAO,CAACC,GAAG,CAAC,oBAEvCC,EACFH,GAAiBP,EAASQ,OAAO,CAACC,GAAG,CAAC,yBAElCE,EAAcX,EAASQ,OAAO,CAACC,GAAG,CAACG,EAAAA,mBAAmB,EAa5D,IAVED,GACCD,GACAC,EAAYrB,OADb,CACqB,CAAC,GAAtB,sBACCqB,EAAD,QAAqB,CAAC,YACrBA,EAAD,QAAqB,CAAC,SACtB,CAEAD,EAAgBC,CAAAA,EAGdD,EAAe,CACjB,GACEA,EAAcrC,UAAU,CAAC,KAEzB,CACA,EAFAwC,EAEMC,EAAsBC,CAF0B,EAE1BA,EAAAA,gBAAAA,EAAiBL,GACvCM,EAAeC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBH,EAAoB1D,QAAQ,CAAE,YACrE6C,EACAiB,WAAW,CACb,GAEIC,EAAa/B,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoB4B,EAAa5D,QAAQ,EAC1D,OAAOP,QAAQuE,GAAG,CAAC,CACjB1E,EAAQK,MAAM,CAACC,UAAU,CAACqE,WAAW,GACrCC,CAAAA,EAAAA,EAAAA,sBAAAA,IACD,EAAEC,IAAI,CAAC,gBAAC,MAAsC,KAArCrC,EAAqC,KAA9B,CAA8B,IAA5BsC,CAAYC,QAAQ,CAApBD,CAAsB,IACnC/C,EAAKf,CAAAA,EAAAA,EAAAA,SAAAA,EAAUsD,EAAa5D,QAAQ,CAAE4D,EAAarD,MAAM,EAE7D,GACE6B,CAAAA,EAAAA,EAAAA,cAAAA,EAAef,IACd,CAAC8B,GACArB,EAAMI,QAAQ,CACZoC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBnE,CAAAA,EAAAA,EAAAA,cAAAA,EAAekB,GAAK/B,EAAQK,MAAM,CAACqD,OAAO,EAC3DhD,QAAQ,EAEf,CACA,IAAMuE,EAAeV,CAAAA,EAAAA,EAAAA,mBAAAA,EACnBF,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiBhB,GAAQ3C,QAAQ,CACjC,CACE6C,WAEIA,CAFQY,CAGZK,KAH2C,GACvCU,CAASA,EAEF,CACb,GAIFd,EAAoB1D,QAAQ,CAD5BqB,EAAKhB,CAAAA,EAAAA,EAAAA,WAAAA,EAAYkE,EAAavE,QAAQ,CAExC,CAiBO,GAAI,CAAC8B,EAAMI,QAAQ,CAAC6B,GAAa,CACtC,IAAMU,EAAmB5C,EAAoBkC,EAAYjC,GAErD2C,IAAqBV,IACvBA,EAAaU,CAAAA,CAEjB,CAEA,GALuC,CAKjClD,EAAe,EAAOW,QAAQ,CAAC6B,GAQjCA,EAPAlC,EACEyC,CAAAA,EAAAA,EAAAA,mBAAAA,EACEnE,CAAAA,EAAAA,EAAAA,cAAAA,EAAeuD,EAAoB1D,QAAQ,EAC3CV,EAAQK,MAAM,CAACqD,OAAO,EACtBhD,QAAQ,CACV8B,GAIN,GAAIM,CAAAA,EAAAA,EAAAA,cAAAA,EAAeb,GAAe,CAChC,IAAMmD,EAAUC,CAAAA,EAAAA,EAAAA,eAAAA,EAAgBtC,CAAAA,EAAAA,EAAAA,aAAAA,EAAcd,IAAeF,GAC7DlC,OAAOC,MAAM,CAACsE,EAAoBkB,KAAK,CAAEF,GAAW,CAAC,EACvD,CAEA,MAAO,CACLG,KAAM,UACNC,SAAUpB,eACVnC,CACF,CACF,EACF,CACA,IAAMwD,EAAMvF,CAAAA,EAAAA,EAAAA,SAAAA,EAAUmD,GAOtB,OAAOlD,QAAQC,OAAO,CAAC,CACrBmF,KAAM,oBACNG,YAAc,GARCC,CAAAA,CAQCjF,CARDiF,EAAAA,sBAAAA,EAAuB,WACnCpB,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBkB,EAAI/E,QAAQ,CAAE,YAAE6C,EAAYiB,WAAW,CAAK,EAAE,GACrEoB,cAAe5F,EAAQK,MAAM,CAACuF,aAAa,CAC3CC,QAAS,MAKkBJ,EAAIH,KAAK,CAAGG,EAAIK,IAAI,EAEnD,CAEA,IAAMC,EAAiBzC,EAASQ,OAAO,CAACC,GAAG,CAAC,qBAE5C,GAAIgC,EAAgB,CAClB,GAAIA,EAAepE,UAAU,CAAC,KAAM,CAClC,IAAM8D,EAAMvF,CAAAA,EAAAA,EAAAA,SAAAA,EAAU6F,GAChBrF,EAAWiF,GAAAA,EAAAA,sBAAAA,EAAuB,WACnCpB,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBkB,EAAI/E,QAAQ,CAAE,CAAE6C,WAAAA,EAAYiB,WAAW,CAAK,EAAE,GACrEoB,cAAe5F,EAAQK,MAAM,CAACuF,aAAa,CAC3CC,QAAS,MAGX,OAAO1F,QAAQC,OAAO,CAAC,CACrBmF,KAAM,oBACNS,MAAQ,GAAEtF,EAAW+E,EAAIH,KAAK,CAAGG,EAAIK,IAAI,CACzCG,OAAS,GAAEvF,EAAW+E,EAAIH,KAAK,CAAGG,EAAIK,IAAI,EAE9C,CAEA,OAAO3F,QAAQC,OAAO,CAAC,CACrBmF,KAAM,oBACNG,YAAaK,CACf,EACF,CAEA,OAAO5F,QAAQC,OAAO,CAAC,CAAEmF,KAAM,MAAgB,EACjD,EAgByCW,CAFjCA,EAAO,UAE+BC,QAAQ,CAAED,EAAK5C,QAAQ,CAAEtD,WAErE,qBAAO,CACLmG,SAAUD,EAAKC,QAAQ,CACvBC,KAAMF,EAAKE,IAAI,CACf9C,SAAU4C,EAAK5C,QAAQ,CACvB+C,KAAMH,EAAKG,IAAI,CACfC,SAAUJ,EAAKI,QAAQ,CACvBpD,OAAAA,CACF,KACF,KAyEA,IAAMqD,EACJpC,IAC6B,kBACNqC,EAFvBrC,KAE8BsC,OAAO,EACrC,CAAC,CAAE,WACD,GAAI,CACF,IAAIC,EAAI,SAER,OAAOC,eAAeC,OAAO,CAACF,EAAGA,GAAIC,eAAeE,UAAU,CAACH,IAAI,CACrE,CAAE,MAAOI,EAAG,CAAC,CACf,IAEIC,EAAqBC,OAAO,sBAmDlC,SAASC,EAAiBZ,CAAY,EACpC,GAAI,CACF,OAAOa,KAAKC,KAAK,CAACd,EACpB,CAAE,MAAOe,EAAO,CACd,OAAO,IACT,CACF,CAEA,SAASC,EAAc,CAUD,EAVC,QACrBlB,QAAQ,KACRmB,aAAa,GAFQ,EAGrBC,UAAU,CACVC,EAAa,oBACbC,cAAc,KACdC,SAAS,KACTC,YAAY,KACZC,YAAY,KACZC,wBAAwB,CAEVvB,EAAa,IAAIwB,EAAT,EAAE,EAAqBtB,OAAOuB,QAAQ,CAACC,IAAI,EAAzDA,IAAAA,CACFC,EAAU,SAACC,CAAAA,MAULA,QATVC,CAtEJ,SAASA,EACP3G,CAAW,CACX4G,CAAgB,CAChBpI,CAAgD,EAEhD,OAAOqI,MAAM7G,EAAK,CAYhB8G,YAAa,cACbC,OAAQvI,EAAQuI,MAAM,EAAI,MAC1BzE,QAASjE,OAAOC,MAAM,CAAC,CAAC,EAAGE,EAAQ8D,OAAO,CAAE,CAC1C,gBAAiB,GACnB,EACF,GAAGe,IAAI,CAAC,SAACvB,CAAAA,EACP,MAAO,CAACA,EAASkF,EAAE,EAAIJ,EAAW,GAAK9E,EAASmF,MAAM,EAAI,IACtDN,EAAW3G,EAAK4G,EAAW,EAAGpI,GAC9BsD,CACN,EACF,GA2Ce6C,EAAUsB,EAAiB,EAAI,EAAG,CAC3C3D,QAASjE,OAAOC,MAAM,CACpB,CAAC,EACDyH,EAAa,CAAEmB,QAAS,UAAW,EAAI,CAAC,EACxCnB,GAAcC,EAAgB,CAAE,wBAAyB,GAAI,EAAI,CAAC,EAG9D,CAFJrD,GAIFoE,GAJgC,GAC1B,CAAqD,OAGnDL,EAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAQK,MAAAA,EAARL,EAAkB,KAC5B,GACGrD,IAAI,CAAC,SAACvB,CAAAA,SACL,EAAakF,EAAE,EAAIN,CAAAA,QAAAA,KAAAA,EAAAA,EAAQK,MAAAA,IAAW,OAC7B,CADqC,SACnCpC,WAAU7C,EAAU+C,KAAM,GAAID,KAAM,CAAC,WAAGE,CAAS,EAGrDhD,EAAS+C,IAAI,GAAGxB,IAAI,CAAC,SAACwB,CAAAA,EAC3B,GAAI,CAAC/C,EAASkF,EAAE,CAAE,CAOhB,GACEhB,GACA,CAAC,IAAK,IAAK,IAAK,IAAI,CAAC5E,QAAQ,CAACU,EAASmF,MAAM,EAE7C,CADA,KACO,UAAEtC,WAAU7C,OAAU+C,EAAMD,KAAM,CAAC,WAAGE,CAAS,EAGxD,GAAwB,MAApBhD,EAASmF,MAAM,CAAU,KACvBxB,EAAJ,UAAIA,EAAAA,EAAiBZ,EAAAA,CAAAA,CAAAA,KAAAA,EAAjBY,EAAwB0B,QAAQ,CAClC,CADoC,KAC7B,UACLxC,EACAC,KAAM,CAAEuC,SAAU5B,CAAmB,EACrCzD,SAAAA,OACA+C,WACAC,CACF,CAEJ,CAEA,IAAMc,EAAQ,qBAAwC,CAAxC,MAAW,+BAAX,+DAAuC,EAWrD,OAJKK,GACHmB,CAAAA,EAAAA,EAAAA,QADmB,MACnBA,EAAexB,GAGXA,CACR,CAEA,MAAO,UACLjB,EACAC,KAAMsB,EAAYT,EAAiBZ,GAAQ,cAC3C/C,OACA+C,WACAC,CACF,CACF,EACF,GACCzB,IAAI,CAAC,SAACqB,CAAAA,EAQL,OANE,GAEoD,YACpD,CADAA,EAAK5C,MADGuF,EACK,CAAC/E,CADFgF,KAAa,CACJ,CAAC/E,CADF,EACK,CAAC,uBAE1B,OAAOuD,CAAa,CAAChB,EAAS,CAEzBJ,CACT,GACC6C,KAAK,CAAC,SAACC,CAAAA,EAcN,MAbI,GACF,OAAO1B,CAAa,CAAChB,EAAS,CAG9B,CACgB,UALa,WAM7B,CADI2C,KADK,EACE,EACD,oDACVD,CACA,CADIC,OAAO,CACF,CACO,gBAAhBD,EAAIC,OAAY,GAChB,CACAL,EAAAA,EAAAA,cAAAA,EAAeI,GAEXA,CACR,WAMJ,GAAgCrB,EACvBM,EAAQ,CAAC,GAAGpD,IAAI,CAAC,CADoB,QACnBqB,CAAAA,EAMvB,MALwD,YAAY,CAAhEA,EAAK5C,QAAQ,CAACQ,OAAO,CAACC,GAAG,CAAC,uBAE5BuD,EAAa,CAAChB,EAAS,CAAGnG,QAAQC,OAAO,CAAC8F,EAAAA,EAGrCA,CACT,QAG8BhB,IAA5BoC,CAAa,CAAChB,EAAS,CAClBgB,CAAa,CAAChB,EAAS,CAExBgB,CAAa,CAAChB,EAAS,CAAG2B,EAChCL,EAAe,CAAEW,OAAQ,MAAO,EAAI,CAAC,EAEzC,CAMO,SAAS9I,IACd,OAAOyJ,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,KAAK,CAAC,EAAG,GAC7C,CAEA,SAASC,GAAqB,CAM7B,EAN6B,OACzB,CADyB,QAE5BjJ,MAAM,CAON,GAAImB,IAAQT,CAAAA,EAAAA,EAAAA,WAAAA,EAAYC,CAAAA,EAAAA,EAAAA,SAAAA,EAAUX,EAAOI,MAAM,CAAEJ,EAAOY,MAAM,GAC5D,CADgE,KAC1D,qBAEL,CAFK,MACH,yDAAwDO,EAAI,IAAGuG,SAASC,IAAI,EADzE,+DAEN,GAEFxB,OAAOuB,QAAQ,CAACC,IAAI,CAAGxG,CACzB,CAEA,IAAM+H,GAAsB,gBAAC,EAM5B,EALCC,KAAK,GAKN,EAJCnJ,MAAM,CAKFN,GAAY,EACV0J,EAAUpJ,EAAOqJ,GAAG,CAAG,WAC3B3J,GAAY,CACd,EAeA,OAAO4J,WAZL,GAAI5J,EAAW,CACb,IAAMqH,EAAa,qBAElB,CAFkB,MAChB,wCAAuCoC,EAAM,KAD7B,+DAEnB,EAEA,OADApC,EAAMrH,SAAS,EAAG,EACZqH,CACR,CAEIqC,IAAWpJ,EAAOqJ,GAAG,EAAE,CACzBrJ,EAAOqJ,GAAG,CAAG,KAEjB,CAEF,KAEe,sBAgDXhJ,CAAgB,CAChB4E,CAAqB,CACrBvD,CAAU,EA6BT,CACD,gBA5BE6H,YAAY,KACZtJ,UAAU,KACVuJ,GAAG,KACHC,OAAO,KACPC,SAAS,KACTf,GAAG,KACHgB,YAAY,KACZC,UAAU,KACVhJ,MAAM,CAGO,GAHP,EACNyC,OAAO,CACM,CAAbkC,CAAa,gBACbsE,aAAa,CAZf,EAaEC,SAAS,mBAxDbC,GAAAA,CAAqB,CAAC,OAEtBC,GAAAA,CAAqB,CAAC,OAgBtBC,oBAAAA,EAAuB,OAiBfC,IAAAA,CAAe9K,SA+JvB+K,UAAAA,CAAa,SAACC,CAAAA,EACZ,IA2CIC,EA3CE,IAAEJ,oBAAoB,CAC5B,EAAKA,EAAD,kBAAqB,EAAG,EAE5B,IAAMK,EAAQF,EAAEE,KAAK,CAErB,GAAI,CAACA,EAAO,CAUV,MAAM,EAAEjK,QAAQ,KAAE4E,KAAK,CACvB,EAAKsF,EAAD,SAAY,CACd,eACAC,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqB,CAAEnK,SAAUK,CAAAA,EAAAA,EAAAA,WAAAA,EAAYL,SAAW4E,CAAM,GAC9DwF,CAAAA,EAAAA,EAAAA,MAAAA,KAEF,MACF,CAGA,GAAIH,EAAMI,IAAI,CAAE,YACdvE,OAAOuB,QAAQ,CAACiD,MAAM,GAIxB,GAAKL,CAAD,CAAOM,GAAG,EAAE,EAMdX,GACA,EAAKrJ,EAAD,IAAO,GAAK0J,EAAM3K,OAAO,CAACiB,MAAM,EACpC0J,EAAM5I,EAAE,GAAK,EAAKtB,EAAD,IAAO,EACxB,CAKF,MAAM,EAAEe,GAAG,KAAEO,EAAE,KAAE/B,OAAO,CAAEkL,EAAQP,CAAL,CAAKA,CAAH,EAAGA,CAClC,GAAIxG,GAEI,CAFiC,CAE5BoG,CAF8B,CAE/B,EAAK,GAAKW,EAAK,CAErB,GAAI,CACFvE,MAJuB,SAIRC,OAAO,CACpB,iBAAmB,EAAK2D,EAAD,EAAK,CAC5BrD,KAAKiE,SAAS,CAAC,CAAEC,EAAGC,KAAKC,WAAW,CAAEC,EAAGF,KAAKG,WAAW,GAE7D,CAAE,QAAM,CAAC,CAGT,GAAI,CACF,IAAM9E,EAAIC,eAAe8E,OAAO,CAAC,iBAAmBP,GACpDR,EAAexD,KAAKC,KAAK,CAACT,EAC5B,CAAE,QAAM,CACNgE,EAAe,CAAEU,EAAG,EAAGG,EAAG,CAAE,CAC9B,CACF,CAGJ,EAAKhB,EAAD,EAAK,CAAGW,EAEZ,IAAM,EAAe7G,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiB7C,GAA9Bd,QAAQ,GAKd,EAAKgL,EAAD,GAAM,EACV3J,IAAOhB,CAAAA,EAAAA,EAAAA,WAAAA,EAAY,EAAKN,EAAD,IAAO,GAC9BC,IAAaK,CAAAA,EAAAA,EAAAA,WAAAA,EAAY,EAAKL,EAAD,OAAS,GACtC,EAME,EAAKiL,EAAD,EAAK,EAAK,EAAD,EAAK,EAAK,CAAChB,EAAAA,GAAQ,EAI/BiB,EAAD,IAAO,CACT,eACApK,EACAO,EACAlC,OAAOC,MAAM,CAA2C,CAAC,EAAGE,EAAS,CACnE6L,QAAS7L,EAAQ6L,OAAO,EAAI,EAAKC,EAAD,MAAS,CACzC7K,OAAQjB,EAAQiB,MAAM,EAAI,EAAK2E,EAAD,WAAc,CAE5CmG,GAAI,CACN,GACArB,GAEJ,EA3NE,IAAMlB,EAAQ9G,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBhC,GAGlC,IAAI,CAACsL,UAAU,CAAG,CAAC,EAIftL,WAAwB,KAC1B,IAAI,CAACsL,UAAU,CAACxC,EAAM,CAAG,CACvBO,UAAAA,EACAkC,SAAS,EACTC,MAAOtC,MACPZ,EACAmD,QAASvC,GAAgBA,EAAauC,OAAO,CAC7CC,QAASxC,GAAgBA,EAAawC,OAAO,CAC/C,EAGF,IAAI,CAACJ,UAAU,CAAC,QAAQ,CAAG,CACzBjC,UAAWF,EACXwC,YAAa,EAEZ,EAKH,IAAI,CAACC,MAAM,CAAG5M,EAAO4M,MAAM,CAE3B,IAAI,CAAChM,UAAU,CAAGA,EAGlB,IAAMiM,EACJzJ,CAAAA,EAAAA,EAAAA,cAAAA,EAAepC,IAAa2K,KAAKmB,aAAa,CAACC,UAAU,CA6CzD,GA3CF,IAAI,CAACjJ,QAAQ,CAAyC,EAAtCW,CAChB,IAAI,CAD8C,GAC1C,CAAG6F,EACX,IAAI,CAACN,GAAG,CAAG,KACX,IAAI,CAACgD,QAAQ,CAAG5C,EAGhB,IAAI,CAAC4B,KAAK,EAAG,EACb,IAAI,CAACiB,cAAc,EAAG,EACtB,IAAI,CAACC,OAAO,CAAG,CAAC,CACdvB,CAAAA,KAAKmB,aAAa,CAACK,IAAI,EACvBxB,KAAKmB,aAAa,CAACM,GAAG,EACtBzB,KAAKmB,aAAa,CAACO,qBAAqB,EACvC1B,KAAKmB,aAAa,CAACQ,MAAM,EAAI,CAAC3B,KAAKmB,aAAa,CAACS,GAAG,EACpD,CAACV,GACA,CAAClB,KAAKtD,QAAQ,CAACmF,MAAM,CACRC,CAajB,EAbI,CAAChJ,CAaD,CAACwG,KAAK,CAAG,OACXnB,WACA9I,QACA4E,EACA7E,OAAQ8L,EAAoB7L,EAAWqB,EACvCoI,UAAW,CAAC,CAACA,EACblJ,QAAQkD,IAA2Ce,EAAZ,GAAGjE,CAAMA,OAChDgJ,CACF,EAEA,IAAI,CAACmD,gCAAgC,CAAGjN,QAAQC,OAAO,EAAC,GAKlD,CAAC2B,EAAGJ,UAAU,CAAC,MAAO,CAGxB,IAAM3B,EAA6B,QAAEiB,CAAO,EACtCR,EAASqK,CAAAA,EAAAA,EAAAA,MAAAA,GAEf,KAAI,CAACsC,gCAAgC,CAAGzN,EAAkB,CACxDU,OAAQ,IAAI,CACZY,OAAAA,EACAR,OAAAA,CACF,GAAGoE,IAAI,CAAC,SAACO,CAAAA,EAgBP,OAbEpF,EAAgBqN,kBAAkB,CAAGtL,IAAOrB,EAE9C,EAAKkK,EAAD,SAAY,CACd,eACAxF,EACI3E,EACAoK,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqB,CACnBnK,SAAUK,CAAAA,EAAAA,EAAAA,WAAAA,EAAYL,SACtB4E,CACF,GACJ7E,EACAT,GAEKoF,CACT,EACF,CAEAoB,OAAO8G,gBAAgB,CAAC,WAAY,IAAI,CAAC9C,UAAU,EAI/CrG,IAAqC,EAAE,KAEhCsC,OAAO,CAAC8G,MADY,WACK,CAAG,qDA2G3CvC,EACExE,OAAOuB,QAAQ,CAACiD,MAAM,EACxB,IAIC,0BACDwC,EACEhH,KADK,EACEC,OAAO,CAAC+G,IAAI,EACrB,IAIC,6BACDC,EACEjH,OAAOC,CADC,MACM,CAACgH,OAAO,EACxB,IAQAC,IAAAA,sBAAKlM,CAAQ,CAAEO,CAAQ,CAAE/B,CAA+B,EAAE,MACxD,GADuBA,CACnBmE,IADmBnE,EACoB,EADpBA,IAAAA,EAA6B,EAAC,EAI/CuG,EACF,GAAI,CAEFI,eAAeC,IAHU,GAGH,CACpB,iBAAmB,IAAI,CAAC2D,IAAI,CAC5BrD,KAAKiE,SAAS,CAAC,CAAEC,EAAGC,KAAKC,WAAW,CAAEC,EAAGF,KAAKG,WAAW,GAE7D,CAAE,QAAM,CAAC,CAIb,OAD0C,KAA1B1J,EAAa,IAAI,CAAEN,EAAKO,EAAAA,CAAE,CAAtCP,GAAG,CAAEO,EAAI,KACN,IAAI,CAAC6J,MAAM,CAAC,YAAapK,EAAKO,EAAI/B,EAC3C,IAOC,6BACD2N,CAAgB,CAAE5L,CAAQ,CAAE/B,CAA+B,EAAE,MAE3D,OAF0BA,KAAAA,IAAAA,IAAAA,EAA6B,EAAC,EACpDwB,EAAG,GAASM,EAAa,IAAI,CAAEN,EAAKO,EAAAA,CAAE,CAAnC,QAAEA,EAAE,CACJ,CADM,GACF,CAAC6J,MAAM,CAAC,eAAgBpK,EAAKO,EAAI/B,EAC9C,QAEM4N,aAAN,SACE7L,CAAU,CACVG,CAAmB,CACnBjB,CAAuB,CACvB4M,CAAsB,EACtB,4BASQC,EACAC,EAAAA,EA2DFC,EACAC,CAlDOjF,CAmDLkF,EAAAA,CACJ,WAEeC,EAAOC,EAAmB,CAArB,CAAqB,EAgBjC,EACA,IAEuB,EAGnBC,EAEAC,CAxB2B,CA6BZ,CAVZC,CAUY,0DArGzB,CAAC,IAAI,CAACC,MAAM,EAAI,CAAC,IAAI,CAACC,MAAAA,EAAQ,cAE9BC,EAAAA,OAAAA,CAAAA,CADiB,CACjBA,gBAYK,MAAM9J,uBAAAA,GAAAA,GAAAA,EAAAA,sBAAAA,GAGX,gBALwBkJ,EAAgB,aAAtCa,CAAsC,mBAAtCA,CACuBZ,EACxB,EADCa,aAAwC,EACzC,MADCA,cASF,YAAIf,EACF,UAAO,EADS,CASlB,OANAvE,GAAqB,CACnB9H,IAAKT,GAAAA,EAAAA,WAAAA,EACHC,CAAAA,EAAAA,EAAAA,SAAAA,EAAUe,EAAId,GAAU,IAAI,CAACA,MAAM,CAAE,IAAI,CAAC2E,aAAa,GAEzDvF,OAAQ,IACV,GACA,GAAO,IAAIF,QAAQ,WAAO,WAmBxB2N,CAAAA,QAAAA,KAAAA,EAAAA,EAAkBe,SAAAA,EAAW,EAC/B,IAAI,CAACL,MAAM,CAAG,IAAIM,EAChBhB,EAAiBiB,QAAQ,CACzBjB,EAAiBkB,SAAS,EAE5B,IAAI,CAACR,MAAM,CAACS,MAAM,CAACnB,KAGjBC,MAAAA,EAAAA,KAAAA,EAAAA,EAAmBc,SAAAA,EAAW,EAChC,IAAI,CAACJ,MAAM,CAAG,IAAIK,EAChBf,EAAkBgB,QAAQ,CAC1BhB,EAAkBiB,SAAS,EAE7B,IAAI,CAACP,MAAM,CAACQ,MAAM,CAAClB,wBAIA,KACC,KAErB,IAAEhM,CAAG,EAAG,CAAEA,GAAIG,CAAW,0BAE5B,MAA+CgM,CAAAA,CAAAA,OAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAA1C,EAAM,mBACT,GAD2D,cAAhDnM,EAAAA,CAAAA,EAAAA,EAAAA,iBAAAA,CACPoM,MACgBzL,CAAAA,EAAAA,EAAAA,mBAAAA,EAChB,IAAIoF,IAAIqG,EAAO,YAAYzN,QAAQ,EAE/BwO,EAAkBnO,CAAAA,EAAAA,EAAAA,WAAAA,EACtBC,CAAAA,EAAAA,EAAAA,SAAAA,EAAUmO,EAAWlO,GAAU,IAAI,CAACA,MAAM,GAI1CmN,GACAe,IACEzM,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoB,IAAIoF,IAAI,IAAI,CAACrH,MAAM,CAAE,YAAYC,QAAQ,GAC/D,CAMA,KAAK,GALLsN,EACEA,GACA,CAAC,WAAC,IAAI,CAACQ,MAAAA,EAAM,OAAX,EAAaY,QAAQ,CAACD,EAAAA,CAAAA,EACxB,CAAC,SAAC,MAAI,CAACX,MAAAA,EAAM,OAAX,EAAaY,QAAQ,CAACF,EAAAA,CAAAA,CAErB,GAAuBC,EAAWD,kBAIrC,CAJuD,GAKrD,EAAQ,IAFSX,KAAac,KAAK,CAAC,KAGpC,CAACpB,GAAqBK,EAAID,EAAWxM,MAAM,CAAG,EAC9CyM,IAGA,GAAIgB,CADEA,EAAcjB,EAAWhF,KAAK,CAAC,EAAGiF,EACpCgB,CADuCC,IAAI,CAAC,QAC5CD,OAAe,MAAI,CAACb,MAAAA,EAAM,OAAX,EAAaW,QAAQ,CAACE,EAAAA,CAAAA,CAAc,CACrDrB,GAAoB,EACpB,KACF,CAMJ,GAAID,GAAoBC,EAAmB,CACzC,GAAIJ,EACF,UAAO,EADS,CASlB,OANAvE,GAAqB,CACnB9H,IAAKT,CAAAA,EAAAA,EAAAA,WAAAA,EACHC,CAAAA,EAAAA,EAAAA,SAAAA,EAAUe,EAAId,GAAU,IAAI,CAACA,MAAM,CAAE,IAAI,CAAC2E,aAAa,GAEzDvF,OAAQ,IAAI,GAEd,GAAO,IAAIF,QAAQ,WAAO,GAC5B,CACF,qGAIN,UAAO,KACT,oCAEA,SAAcyL,CACS,CACrBpK,CAAW,CACXO,CAAU,CACV/B,CAA0B,CAC1B0K,CAAuC,EACrB,0BA8Ob,EAtOC8E,EAMFC,EAKEC,EAOAC,EAEAjE,EAAAA,EA6DEkE,EA8CA/D,EAAAA,EAAiBgE,EAAAA,EAnFjBrK,EAgHFsK,EAkBK9G,EAAK,EAYVtI,EAAU4E,EAAO,EAKFP,CALA,CAAP,CA8BV7C,EAzBiB6C,CAkCjByE,GACEuG,GASAC,GASAC,GAAAA,GAgBIC,GAAAA,GA0DF1K,GAGA2K,GAAAA,GAGAC,GAKEC,GAgDJC,GAwKFjF,GAAAA,GACAkF,GAtKEA,GA+BIC,GAwBAC,GAWEN,GACAO,GAoBJC,EAzBMC,CA2CFlL,GASEmL,GAM6B/O,EA/BjCgP,CA+BW7K,GAAYD,GAAN,EAAW,CAoBpB,MAsCdhG,GADI+Q,GArCOC,GAqCPD,GAMAE,GAiCF5F,GAAAA,GACAkF,GASOvH,GA0BAyB,EA1BK,CAgBVyG,GA8CClI,KAAK,iDAnqBd,GAAI,CAACmI,CAAAA,EAAAA,EAAAA,UAAAA,EAAW3P,GAEd,GAFoB,IACpB8H,GAAqB,KAAE9H,EAAKnB,OAAQ,IAAI,GACxC,IAAO,SAOJmP,OAFoBxP,EAAgB+L,EAAE,GAEnB,CAAC/L,EAAQ6L,OAAAA,EAAS,MAAtC,MACF,SAAM,IAAI,CAAC+B,IAAI,CAAC7L,OAAImD,EAAWlF,EAAQiB,MAAM,oCAyB/C,KArBEuO,GACCxP,EAAgBqN,kBAAkB,EACnCnN,CAAAA,EAAAA,EAAAA,SAAAA,EAAUsB,GAAKd,QAAQ,GAAKR,CAAAA,EAAAA,EAAAA,SAAAA,EAAU6B,GAAIrB,QAAQ,GAElC,OACb,IAAI,CAACiK,KAAK,IAM2B,KAAjB,IAAI,CAACiC,OAAO,CACrC,IAAI,CAACA,OAAO,EAAG,IACD,IAAI,CAAClB,KAAK,CAEpB,IACF,IAAI,CAACA,KAAK,EAAG,GAKX8D,GAAmB,IAAI,CAAC9F,GAAG,CAC7B,CAD+B,KAC/B,GAAO,OAGH0H,EAAa1B,EAAUzO,MAAM,CA2F/BoQ,EAAAA,EAAE,EAAE,YACMC,IAAI,CAAC,eAGwBtR,EAAAA,KAAAA,IAAzB,GAAyBA,EAAAA,OAAAA,GAApB,iBAAe,CAAf,CAAiB,KAAjB,GAAiB,EAClCuR,EAAa,SAAE1F,CAAQ,EAEzB,IAAI,CAAC2F,cAAc,EAAI,IAAI,CAAC9H,GAAG,EAAE,CAC/B,KACK4C,EADG,IACG,CAACmF,IAAI,CAChB,mBACA7R,IACA,IAAI,CAAC4R,cAAc,CACnBD,GAGJ,IAAI,CAAC7H,GAAG,GACR,IAAI,CAACA,GAAG,CAAG,MAGb3H,EAAKhB,CAAAA,EAAAA,EAAAA,WAAAA,EACHC,CAAAA,EAAAA,EAAAA,SAAAA,EACEJ,CAAAA,EAAAA,EAAAA,WAAAA,EAAYmB,GAAMlB,CAAAA,EAAAA,EAAAA,cAAAA,EAAekB,GAAMA,EACvC/B,EAAQiB,MAAM,CACd,IAAI,CAAC2E,aAAa,KAGJ8L,GAAAA,EAAAA,YAAAA,EAChB9Q,CAAAA,EAAAA,EAAAA,WAAAA,EAAYmB,GAAMlB,CAAAA,EAAAA,EAAAA,cAAAA,EAAekB,GAAMA,EACvC2N,EAAUzO,MAAM,EAElB,IAAI,CAACuQ,cAAc,CAAGzP,IAEDqP,IAAe1B,EAAUzO,MAAM,EAKhD,EAACuO,GAAmB,IAAI,CAACmC,eAAe,CAAChR,IAAc,CAACmP,CAAAA,CAAAA,CAAc,YACxEJ,EAAUjP,MAAM,CAAGE,IACZ2L,MAAM,CAACmF,IAAI,CAAC,kBAAmB1P,EAAIwP,GAE1C,IAAI,CAAC3G,WAAW,CAACrC,EAAQ/G,EAAKO,EAAI,WAC7B/B,GAAO,CACV6P,GADU,KACF,KAENA,GACF,IAAI,CADM,YACO,CAAClP,oDAGZ,IAAI,CAACiR,GAAG,CAAClC,EAAW,IAAI,CAAC1D,UAAU,CAAC0D,EAAUlG,KAAK,CAAC,CAAE,qBAA5D,sBAKA,iBAHIqI,CAAAA,EAAAA,EAAAA,OAAAA,EAAQ7I,IAAQA,EAAIjJ,SAAS,EAAE,EAC1BuM,MAAM,CAACmF,IAAI,CAAC,mBAAoBzI,EAAKrI,EAAW4Q,GAEnDvI,SAIR,SADOsD,MAAM,CAACmF,IAAI,CAAC,qBAAsB1P,EAAIwP,GAC7C,IAAO,aAGLO,EAASzN,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiB7C,EAAAA,aACJsQ,EAAAA,KAAAA,oDAOmB3R,QAAQuE,GAAG,CAAC,CACrD,IAAI,CAACpE,UAAU,CAACqE,WAAW,GAC3BC,CAAAA,EAAAA,EAAAA,sBAAAA,IACA,IAAI,CAACtE,UAAU,CAACC,aAAa,oBAH7BiC,EAAO,sBAA4B,aAA5B,UAAEsC,CAAYC,QAAQ,CAApBD,CAAsB,eASjC,OAJY,SAGZwE,GAAqB,CAAE9H,IAAKO,EAAI1B,OAAQ,IAAI,GAC5C,IAAO,WA4BT,GApBI,IAAK,CAAC0R,QAAQ,CAACpR,IAAemP,IAChCvH,EAAS,IADsB,IAAe,MACrC,KAKMxG,EAKjBrB,EAAWA,EACPgC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoB7B,CAAAA,EAAAA,EAAAA,cAAAA,EAAeH,IACnCA,KAEQgC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBhC,MACPqB,EAAGJ,UAAU,CAAC,MAAQ0C,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiBtC,GAAIrB,QAAQ,CAI5E,OAAK,MAAI,CAACsL,UAAU,CAACtL,EAAAA,EAAS,OAAzB,EAAmCsR,WAAW,CAEjD,CAFmD,MACnD1I,GAAqB,CAAE9H,IAAKO,EAAI1B,OAAQ,IAAI,GAC5C,GAAO,IAAIF,QAAQ,WAAO,UAGA,CAAC,CAC3B4P,CAAAA,IACAvG,KAAUuG,IACT,EAACjN,CAAAA,EAAAA,EAAAA,SAAD,KAACA,EAAe0G,KACf,CAACnE,CAAAA,EAAAA,EAAAA,eAAAA,EAAgBtC,CAAAA,EAAAA,EAAAA,aAAAA,EAAcyG,KAAQuG,GAAAA,CAAAA,CAAgB,CAAC,MAMzD/P,EAAQ6L,OAAAA,EAAT,aACC,SAAMlM,EAAkB,CACvBc,OAAQsB,EACRd,OAAQyO,EAAUzO,MAAM,CACxBZ,OAAQ,IAAI,2CAoDhB,SAjDImP,GAAmBS,KACrBR,GAAoB,GAGlBA,GAAkC,KAJI,MAIO,CAAxB/O,IACrBV,EAAgBqN,kBAAkB,EAAG,EA+BrCyE,EAAOpR,QAAQ,CAAG6B,EAAoB7B,EAAU8B,GAE5CsP,EAAOpR,QAAQ,GAAKA,IACtBA,EAAWoR,EAAOpR,EADc,MACN,CAC1BoR,EAAOpR,QAAQ,CAAGK,CAAAA,EAAAA,EAAAA,WAAAA,EAAYL,GAE1B,KACFc,EAAMqJ,CAAAA,EAAAA,EAAAA,OADgB,aAChBA,EAAqBiH,EAAAA,IAM/B,CAACX,CAAAA,EAAAA,EAAAA,UAAAA,EAAWpP,GAQd,EARmB,KAOnBuH,GAAqB,CAAE9H,IAAKO,EAAI1B,OAAQ,IAAI,GAC5C,IAAO,GAQT,GALA6B,GAAawP,CAAAA,EAAAA,EAAAA,YAAAA,EAAa7Q,CAAAA,EAAAA,EAAAA,cAAAA,EAAeqB,IAAawN,EAAUzO,MAAM,EAEtEuI,GAAQ9G,GAAAA,EAAAA,mBAAAA,EAAoBhC,GACxBuR,IAA6B,EAE7BnP,CAAAA,EAAAA,EAAAA,cAAAA,EAAe0G,IAWjB,IAXyB,GAENhE,IADFnB,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiBnC,GAAAA,EACNxB,QAAQ,IAEjBqC,CAAAA,EAAAA,EAAAA,aAAAA,EAAcyG,IACjCyI,GAAa5M,CAAAA,EAAAA,EAAAA,eAAAA,EAAgB8K,IAAYlQ,OAElBiS,CADjBA,GAAoB1I,KAAUvJ,EAAAA,EAEhCkS,CAAAA,EAAAA,EAAAA,aAAAA,EAAc3I,GAAOvJ,GAAYqF,GAChC,CAAC,EAED2M,MAAeC,IAAsB9B,GAAegC,MAAAA,EAAS,GAiChErQ,EAAK8I,CAjCkC,EAiClCA,EAAAA,SADuB,WACvBA,EACHhL,OAAOC,MAAM,CAAC,CAAC,EAAG0F,GAAU,CAC1B9E,SAAU0P,GAAegC,MAAM,CAC/B9M,MAAO+M,CAAAA,EAAAA,EAAAA,IAAAA,EAAK/M,EAAO8K,GAAelI,MAAM,CAC1C,IAIFrI,OAAOC,MAAM,CAACwF,EAAO2M,SApCrB,GAAI5B,IAJkBxQ,OAAOyS,IAAI,CAACnC,GAAWoC,MAAM,EAAEC,MAAM,CACzD,SAACC,CAAAA,QAAU,CAACnN,CAAK,CAACmN,EAAM,EAAI,CAACtC,GAAWoC,MAAM,CAACE,EAAM,CAACC,QAAQ,IAG9C7Q,MAAM,CAAG,GAAK,CAACoO,GAc/B,MAAM,UAd4C,WAyBjD,CAXK,MACHiC,CAAAA,GACI,wBAAyB1Q,EAAI,oCAAmC6O,GAAcd,IAAI,CACjF,MACA,kCACD,4BAA6BtP,GAAW,4CAA6CuJ,GAAM,OAAG,gDAE/F0I,CAAAA,EACI,4BACA,wBAAqB,CAC1B,oBAVC,2CAWN,EAYJ,CAGE,KACK5F,MAAM,CAACmF,IAAI,CADE,mBACmB1P,EAAIwP,MAGN,SAAlB,IAAI,CAAC7Q,QAAQ,EAAe,gBAAI,CAACA,QAAQ,uDAGtC,IAAI,CAACiS,YAAY,CAAC,OACtCnJ,YACA9I,QACA4E,KACAvD,aACAG,cACAqP,EACAtQ,OAAQyO,EAAUzO,MAAM,CACxBkJ,UAAWuF,EAAUvF,SAAS,CAC9B3C,cAAeyI,GACfpI,yBAA0B7H,EAAQ6H,wBAAwB,CAC1D2H,gBAAiBA,GAAmB,CAAC,IAAI,CAACvF,UAAU,qBACpD+F,EACF,kBAbgB,YAeXR,GAAmB,CAACxP,EAAQ6L,OAAAA,EAAS,MAAtC,gBACI,IAAI,CAAC+B,IAAI,CACb7L,EACA,eAAgBwO,GAAYA,GAAUrO,UAAU,MAAGgD,EACnDwK,EAAUzO,MAAM,WAHlB,4BA8DF,GAvDI,UAAWsP,IAAaN,KAE1BzG,GADA9I,EAAW6P,GAAU/G,KAAK,CADmB,CACfA,GAG1B,EAAYqC,OAAO,EAAE,CACvBvG,EAAQzF,OAAOC,MAAM,CAAC,CAAC,EAAGyQ,GAAUjL,KAAK,EAAI,CAAC,EAAGA,EAAAA,KAGrB1E,CAAAA,EAAAA,EAAAA,WAAAA,EAAYkR,EAAOpR,QAAQ,EACrDG,CAAAA,EAAAA,EAAAA,cAAAA,EAAeiR,EAAOpR,QAAQ,EAC9BoR,EAAOpR,QAAQ,CAEfuR,IAAcvR,IAAa8P,IAC7B3Q,OAAOyS,IAAI,CAACL,IAAYW,GAD4B,IACrB,CAAC,SAAC1H,CAAAA,EAC3B+G,IAAc3M,CAAK,CAAC4F,EAAI,GAAK+G,EAAU,CAAC/G,EAAI,EAAE,OACzC5F,CAAK,CAAC4F,EAAI,GAKnBpI,CAAAA,EAAAA,EAAAA,cAAAA,EAAepC,SAEf,CAAC6Q,CAFyB,CAEd1F,MAUEgH,CAVK,EAAItC,GAAUrO,UAAU,CACvCqO,GAAUrO,UAAU,CACpBnB,CAAAA,EAAAA,EAAAA,WAAAA,EACEC,CAAAA,EAAAA,EAAAA,SAAAA,EACE,IAAI8G,IAAI/F,EAAIgG,SAASC,IAAI,EAAEtH,QAAQ,CACnCgP,EAAUzO,MAAM,GAElB,GAKJL,CAAAA,EAAAA,EAAAA,WAAAA,EAAY6P,MACdA,GAAY5P,GADc,EACdA,cAAAA,EAAe4P,GAAAA,KAQV1N,CAAAA,EAAAA,EAAAA,aAAAA,EAAcrC,GAK7BgQ,IAJkBrL,CAAAA,EAAAA,EAAAA,MAIH,SAJGA,EAAgB8K,IACpC,IAAIrI,IAAI2I,GAAW1I,SAASC,IAAI,EAAEtH,SAAQ,GAI1Cb,OAAOC,MAAM,CAACwF,EAAOoL,KAMvB,SAAUH,GACZ,GAAIA,KADmB,gBACqB,IAA9BhL,IAAI,CAChB,SAAO,IAAI,CAACqG,MAAM,CAACrD,EAAQgI,GAAUtK,MAAM,CAAEsK,GAAUvK,KAAK,CAAEhG,SAG9D,OADAsJ,GAAqB,CAAE9H,IAAK+O,GAAU7K,WAAW,CAAErF,OAAQ,IAAI,GAC/D,GAAO,IAAIF,QAAQ,WAAO,WAIPoQ,GAAUxG,SAAAA,GAChB4G,GAAUmC,qBAAqB,EAG9ChC,EAFkB,CAACiC,MAAM,CAACpC,GAAUmC,qBAAqB,IAEjDF,OAAO,CAAC,SAACI,CAAAA,EACfC,CAAAA,EAAAA,EAAAA,sBAAAA,EAAuBD,EAAO9G,KAAK,CACrC,MAIGqE,GAAUpE,OAAO,EAAIoE,GAAUnE,OAAAA,GAAYmE,GAAUrE,KAAAA,EAAO,MAA5DqE,OACH,GACEA,GAAUrE,KAAK,CAACgH,SAAS,EACzB3C,GAAUrE,KAAK,CAACgH,SAAS,CAACC,YAAY,CACtC,CASA,GAPAnT,EAAQiB,MAAM,CAAG,GAQfyE,IANkB6K,GAAUrE,KAAK,CAACgH,SAAS,CAACC,YAAAA,EAMhCxR,UAAU,CAAC,OAC8B,IAArD4O,GACA,KADe,CAAC2C,SAAS,CAACE,sBAAsB,CAahD,MAVAvC,IADmBxM,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiBqB,GAAAA,EACzBhF,QAAQ,CAAG6B,EACpBsO,GAAWnQ,QAAQ,CACnB8B,GAMAkD,GAAAA,MAFA,IAAI,CACJA,GACAA,GAAAA,EAHMlE,GAAAA,CAAAA,GAAAA,GAAaO,EAAAA,CAKrB,GAAO,IAAI,CAAC6J,MAAM,CAACrD,EAAQtC,GAAQD,GAAOhG,IAG5C,OADAsJ,GAAqB,CAAE9H,IAAKkE,GAAarF,OAAQ,IAAI,GACrD,GAAO,IAAIF,QAAQ,WAAO,GAC5B,IAEAuP,EAAUvF,SAAS,CAAG,CAAC,CAACoG,GAAUrE,KAAK,CAACmH,WAAW,IAGrCnH,KAAK,CAACvD,QAAQ,GAAK5B,EAA7BwJ,MAAAA,UAA6BxJ,gBAI7B,mCAAM,IAAI,CAACuM,cAAc,CAAC,iCAC1BC,GAAgB,sCAEhBA,GAAgB,kCAGA,IAAI,CAACZ,YAAY,CAAC,CAClCnJ,MAAO+J,GACP7S,SAAU6S,GACVjO,MAAAA,KACAvD,aACAG,GACAqP,WAAY,CAAE1F,SAAS,CAAM,EAC7B5K,OAAQyO,EAAUzO,MAAM,CACxBkJ,UAAWuF,EAAUvF,SAAS,CAC9BqJ,YAAY,CACd,YAEA,GAAI,SAZJjD,CAYcA,EAZF,SAYa,CACvB,MAAM,qBAAiD,CAAjD,MAAW,wCAAX,+DAAgD,yBAM1Df,GACkB,gBAAd,CAAC9O,QAAQ,EACb2K,CAAAA,OAAAA,GAAAA,KAAKmB,aAAa,CAACN,KAAAA,GAAK,OAAxBb,GAAAA,GAA0B6H,SAAAA,EAAS,OAAnC7H,GAAqCoI,UAAAA,IAAe,aACpDlD,GAAAA,GAAUrE,KAAAA,EAAK,OAAfqE,GAAiB2C,SAAAA,GACjB,CAGA3C,GAAUrE,KAAK,CAACgH,SAAS,CAACO,UAAU,CAAG,KAInCC,GACJ1T,EAAQ6L,OAAO,EAAI6D,EAAUlG,KAAK,IAAM+G,CAAAA,MAAAA,GAAAA,GAAU/G,KAAAA,EAAV+G,GAAmB/G,EAAAA,CAAAA,CAAI,GAI7CuH,IADJ,OAAd/Q,GAAAA,EAAQ6P,MAAAA,EAAR7P,GAAmB,CAACwP,GAAmB,CAACkE,EAAAA,EACP,CAAEtI,EAAG,EAAGG,EAAG,CAAE,EAAI,KAC9CoI,GAAsBjJ,MAAAA,EAAAA,EAAgBkJ,MAGhB,WACvBlE,GAAS,OACZlG,YACA9I,QACA4E,EACA7E,OAAQE,EACRsJ,YAAY,SAQSqG,EAAAA,CAAAA,CAAnBd,MAAAA,gBACgB,IAAI,CAACmD,YAAY,CAAC,CAClCnJ,MAAO,IAAI,CAAC9I,QAAQ,CACpBA,SAAU,IAAI,CAACA,QAAQ,OACvB4E,KACAvD,aACAG,GACAqP,WAAY,CAAE1F,SAAS,CAAM,EAC7B5K,OAAQyO,EAAUzO,MAAM,CACxBkJ,UAAWuF,EAAUvF,SAAS,CAC9BqF,gBAAiBA,GAAmB,CAAC,IAAI,CAACvF,UAAU,YAGtD,GAAI,SAZJsG,CAYcA,EAZF,SAYa,CACvB,MAAM,qBAA6D,CAA7D,MAAW,mCAAkC,IAAI,CAAC7P,QAAQ,EAA1D,+DAA4D,GAIhD,YAAlB,IAAI,CAACA,QAAQ,EACb2K,CAAAA,OAAAA,GAAAA,KAAKmB,aAAa,CAACN,KAAAA,GAAK,OAAxBb,GAAAA,GAA0B6H,SAAAA,EAAS,OAAnC7H,GAAqCoI,UAAAA,IAAe,YACpDlD,IAAAA,GAAUrE,KAAAA,EAAK,OAAfqE,GAAiB2C,SAAAA,GACjB,CAGA3C,GAAUrE,KAAK,CAACgH,SAAS,CAACO,UAAU,CAAG,2DAIjC,IAAI,CAAC7B,GAAG,CAACX,GAAqBV,GAAWoD,oBAA/C,wBAKA,kBAHI9B,CAAAA,EAAAA,EAAAA,OAAAA,EAAQ7I,KAAQA,GAAIjJ,SAAS,EAAE,EAC1BuM,MAAM,CAACmF,IAAI,CAAC,mBAAoBzI,GAAKrI,EAAW4Q,GAEnDvI,WAGR,UAAO,gBAGFsD,CAaF4E,KAbQ,CAACO,IAAI,CAAC,sBAAuB1P,EAAIwP,GAC9C,IAAI,CAAC3G,WAAW,CAACrC,EAAQ/G,EAAKO,EAAI/B,GAMhCwP,GACA,CAACmE,IACD,CAAChE,GACD,CAACG,GACD+D,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoB5C,GAAqB,IAAI,CAACtG,KAAK,EAEjD,gCAEA,mCAAM,IAAI,CAACiH,GAAG,CAACX,GAAqBV,GAAWoD,4CAE/C,GAAIlJ,cAAE1K,SAAS,CAAEwQ,GAAUnJ,KAAK,CAAGmJ,GAAUnJ,KAAK,EAAIqD,QACjD,MAAMA,wBAGb,GAAI8F,GAAUnJ,KAAK,CAUjB,CAVmB,KACf,KACKkF,MAAM,CAACmF,IAAI,CAChB,mBACAlB,GAAUnJ,KAAK,CACfzG,EACA4Q,GAIEhB,GAAUnJ,KAAK,CASlBoI,KACIlD,MAAM,CAACmF,IAAI,CADE,sBACsB1P,EAAIwP,MAI9B,OACdR,IAAgB+C,GAAUxS,IAAI,CAACS,IACjC,CADsC,GAClC,CAACgS,YAAY,CAAChS,sBAItB,UAAO,WAEP,eAAI8P,CAAAA,EAAAA,EAAAA,OAAAA,EAAQ7I,KAAQA,GAAIjJ,SAAS,CAC/B,CADiC,KACjC,IAAO,EAET,OAAMiJ,uBAEV,iBAEA4B,IAAAA,6BACErC,CAAqB,CACrB/G,CAAW,CACXO,CAAU,CACV/B,CAA+B,EACzB,KADNA,IAAAA,IAAAA,EAA6B,EAAC,GAcf,cAAXuI,GAA0BuC,CAAAA,EAAAA,EAAAA,MAAAA,MAAa/I,CAAAA,GAAI,CAC7C,IAAI,CAAC+J,QAAQ,CAAG9L,EAAQ6L,OAAO,CAC/BrF,OAAOC,OAAO,CAAC8B,EAAO,CACpB,KACE/G,KACAO,UACA/B,EACAiL,IAAK,GACLC,IAAM,IAAI,CAACX,IAAI,CAAc,cAAXhC,EAAyB,IAAI,CAACgC,IAAI,CAAG9K,GACzD,EAIA,CAHA,EAIAsC,GAGN,qCAEA,SAAMiS,CAC4C,CAChDtT,CAAgB,CAChB4E,CAAqB,CACrBvD,CAAU,CACVwP,CAA2B,CAC3B0C,CAAuB,EACY,qBAfsD,KA2CnF/H,EAEF,MAEIqE,EAAAA,qDA/BR,GAAIvH,EAAIjJ,SAAS,CAEf,CAFiB,KAEXiJ,EAGR,GAAIkL,CAAAA,EAAAA,EAAAA,YAAAA,EAAalL,IAAQiL,EAgBvB,QAfO3H,KAD+B,CACzB,CAACmF,IAAI,CAAC,mBAAoBzI,EAAKjH,EAAIwP,GAQhDjI,GAAqB,CACnB9H,IAAKO,EACL1B,OAAQ,IAAI,GAKRT,qDAQE,IAAI,CAAC0T,cAAc,CAAC,sBADdvJ,EAAS,aAAflH,IAAAA,CAAAA,EAAAA,EAAiBwJ,WAAW,CAW/BkE,GARuC,OAC1CrE,YACAnC,cACAsC,MACArD,EACA5B,MAAO4B,EACT,EAEekD,KAAK,CAAhB,6DAEwB,IAAI,CAACiI,eAAe,CAACpK,EAAW,CACtDf,IAAAA,EACAtI,SAAAA,QACA4E,CACF,kBAJAiL,EAAUrE,KAAK,CAAG,6BAKH,SAEfqE,EAAUrE,KAAK,CAAG,CAAC,eAIvB,SAAOqE,UAEP,OADO6D,EAAc,SACrB,GADqB,IACV,CAACJ,oBAAoB,CAC9BnC,CAAAA,EAAAA,EAAAA,OAAAA,EAAQuC,GAAgBA,EAAe,qBAA4B,CAA5B,MAAUA,EAAe,IAAzB,+DAA2B,GAClE1T,EACA4E,EACAvD,EACAwP,GACA,uBAGN,0CAEA,SAAMoB,CA4BL,EAAE,4BA3BM0B,EAAc,wBAkCjB7K,EA+EAtD,EACAA,EAKEA,EA0DsBA,EAAAA,EAvIpByD,EAAAA,EAAAA,EAcA2K,EAAAA,EAAAA,EAAAA,EAAAA,EAqGA/D,EAAAA,EAoBAgE,EAEAC,EAAAA,EAQEtI,EAAK,EA+ENlD,CA/EM,+DA3LfQ,KAAAA,CAAAA,EAAAA,EACA9I,QAAQ,KACR4E,KAAK,KACLvD,EAAE,KACFG,UAAU,GALO,EAMjBqP,UAAU,KACVtQ,MAAM,KACNuG,aAAa,KACb2C,SAAS,KACTtC,wBAAwB,KACxB2H,eAAe,KACfQ,mBAAmB,KACnBwD,UAAU,CAsBV,EAAYa,mBAIV,2BADII,EAA6C,IAAI,CAACzI,UAAU,CAACxC,EAAM,CACnE+H,EAAW1F,OAAO,EAAI4I,GAAgB,IAAI,CAACjL,KAAK,GAAKA,EACvD,KAD8D,CAC9D,GAAOiL,QAGelL,GAAoB,OAAEC,EAAOnJ,OAAQ,IAAI,GAE7DmH,IACFiN,OAAevP,CAAAA,EAGbwP,CAJe,EAKjBD,GACE,YAAaA,CAAf,CAGIvP,OADAuP,EAGA7M,CALW6M,CAAW,IAC1BtQ,CAMAgC,OANQ0C,EAME,CANC,CAACC,EAME,CAACxI,EANU,GAAL,KAMK,CAACqU,WAAW,CAAC,CACpC3M,KAAM6C,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqB,UAAEnK,QAAU4E,CAAM,GAC7CsP,mBAAmB,EACnBnU,OAAQ+S,EAAa,OAAStR,SAC9BjB,CACF,GACAuG,cAAe,GACfC,eAAgB,IAAI,CAACiE,KAAK,CAC1BhE,WAAW,EACXJ,cAAeM,EAAe,IAAI,CAACyC,GAAG,CAAG,IAAI,CAACD,GAAG,CACjDzC,aAAc,CAACwC,EACf5C,WAAY,4BACZM,eACAD,CACF,OAOqB,CAACoI,CAAAA,CAAAA,CAApBR,MAAAA,eACI,2BACMvM,EAAsB,CAC1BE,UAAW,kBAAMkE,EAAciN,IAC/B7T,OAAQ+S,EAAa,OAAStR,EAC9BjB,OAAQA,EACRZ,OAAQ,IAAI,GACX0I,KAAK,CAAC,SAACC,CAAAA,EAKR,GAAIwG,EACF,OAAO,IAET,IAHqB,GAGfxG,CACR,aAdA,0BAgCN,GAdI9C,CAzBAA,EAAAA,CAAAA,GAyBSxF,CAAAA,eAAuC,SAAbA,CAAa,EAAK,EACvDwF,EAAKhD,MAAM,MAAGgC,CAAAA,EAGZsK,IACGtJ,EAGHA,EAAKE,EAHI,EAGA,CAAGiF,IAJK,CAIAmB,aAAa,CAACN,KAAK,CAFpChG,EAAO,CAAEE,KAAMiF,KAAKmB,aAAa,CAACN,KAAM,GAM5CvC,IAGEzD,CAAAA,MAAAA,CAAAA,EAAAA,GAAAA,IAAAA,EAAAA,EAAMhD,MAAAA,EAAM,OAAZgD,EAAcX,IAAI,IAAK,qBACvBW,CAAAA,MAAAA,CAAAA,EAAAA,GAAAA,IAAAA,EAAAA,EAAMhD,MAAAA,EAAM,OAAZgD,EAAcX,IAAI,IAAK,oBAEvB,CADA,KACA,GAAOW,EAAKhD,MAAM,MAGhBgD,MAAAA,CAAAA,EAAAA,GAAAA,IAAAA,EAAAA,EAAMhD,MAAAA,EAAM,OAAZgD,EAAcX,IAAAA,IAAS,UAAW,mBAC9BsP,EAAgBnS,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBwD,EAAKhD,MAAM,CAACjB,YAAY,KAC9C,IAAI,CAAC3B,UAAU,CAACqE,WAAW,WAM/C,GANMnC,EAAQ,UAMV,CAACgN,GAAmBhN,EAAMI,QAAQ,CAACiS,EAAAA,GAAgB,CACrDrL,EAAQqL,EACRnU,EAAWwF,EAAKhD,MAAM,CAACjB,YAAY,CACnCqD,EAAQ,OAAKA,EAAUY,EAAKhD,CAAV,KAAgB,CAACsC,QAAQ,CAACF,KAAK,EACjDpD,EAAarB,CAAAA,EAAAA,EAAAA,cAAAA,EACXmE,GAAAA,EAAAA,mBAAAA,EAAoBkB,EAAKhD,MAAM,CAACsC,QAAQ,CAAC9E,QAAQ,CAAE,IAAI,CAACgD,OAAO,EAC5DhD,QAAQ,EAIb+T,EAAe,IAAI,CAACzI,UAAU,CAACxC,EAAM,CAEnC+H,EAAW1F,OAAO,EAClB4I,GACA,IAAI,CAACjL,KAAK,GAAKA,GACf,CAAChC,GAKD,SAAO,GAJP,CAIO,OAAKiN,GAAY,OAAEjL,EAAF,oBAK9B,GAAIsL,CAAAA,EAAAA,EAAAA,UAAAA,EAAWtL,GAEb,KAFqB,EACrBF,GAAqB,CAAE9H,IAAKO,EAAI1B,OAAQ,IAAI,GAC5C,GAAO,IAAIF,QAAe,WAAO,SAIjCuU,cACC,SAAM,IAAI,CAACpB,cAAc,CAAC9J,GAAO3E,IAAI,CACpC,SAACkQ,CAAAA,GAAS,MACRhL,UAAWgL,EAAIlS,IAAI,CACnBwJ,YAAa0I,EAAI1I,WAAW,CAC5BF,QAAS4I,EAAIC,GAAG,CAAC7I,OAAO,CACxBC,QAAS2I,EAAIC,GAAG,CAAC5I,OACnB,qDAYsBlG,MAAAA,CAAAA,EAAAA,GAAAA,IAAAA,EAAAA,EAAM5C,QAAAA,EAAQ,OAAd4C,EAAgBpC,OAAO,CAACC,GAAG,CAAC,uBAE9BwM,EAAUpE,OAAO,EAAIoE,EAAUnE,OAAO,CAI1DmI,GAAqBrO,CAAAA,QAAAA,KAAAA,EAAAA,EAAMC,QAAAA,GAAU,OAChC,IAAI,CAACiE,GAAG,CAAClE,EAAKC,QAAQ,CAAC,IAGE,IAAI,CAAC8O,QAAQ,CAAC,gGAC1CT,EAAiB,YACnB,GAAItO,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAME,IAAAA,GAAQ,CAACmO,EACjB,SAAO,CAAEjO,OAD2B,EACjBJ,EAAKI,QAAQ,CAAE4F,MAAOhG,EAAKE,IAAI,YAW9BiB,EAAc,UARnBnB,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMC,QAAAA,EACnBD,EAAKC,QAAQ,CACb,IAAI,CAAC7F,UAAU,CAACqU,WAAW,CAAC,CAC1B3M,KAAM6C,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqB,UAAEnK,QAAU4E,CAAM,GAC7C7E,OAAQyB,SACRjB,CACF,GAIFwG,eAAgB,IAAI,CAACiE,KAAK,CAC1BhE,WAAW,EACXJ,cAAeiN,EAAoB,CAAC,EAAI,IAAI,CAACnK,GAAG,CAChDzC,aAAc,CAACwC,EACf5C,YAAY,2BACZM,CACF,WAEA,SAAO,CACLvB,SAAU4O,CAXNA,EAAU,UAWI5O,QAAQ,CAC1B4F,MAAOgJ,EAAQ9O,IAAI,EAAI,CAAC,CAC1B,UAKO,UADPtC,QAAS,CAAC,GACH,GAAM,IAAI,CAACqQ,eAAe,CAC/B5D,EAAUxG,SAAS,CACnB,UAEErJ,QACA4E,EACA7E,OAAQsB,SACRd,EACAyC,QAAS,IAAI,CAACA,OAAO,CACrBkC,cAAe,IAAI,CAACA,aAAa,WAXvC,MAAO,MAELsG,KAAAA,CAAAA,EAAAA,IAAAA,GAAAA,CAAAA,KAaJ,qBAiCA,8BA9E4B,EAAb5F,QAAQ,CAkDnBiK,EAAUnE,OAAO,EAAIkI,EAAoBnO,QAAQ,EAAIG,GACvD,OADiE,IACtD,CAAC8D,GAAG,CAAC9D,EAAS,CAMzB,IAAK,CAAC6D,SAAS,GACfoG,EAAUpE,OAAO,EAEhBqD,EADDrL,CAGAkD,EACExH,KAJMgJ,EAIC/I,CAJE,CAACgJ,GAEZ,CAEe,CAAC,CAAC,EAAGwL,EAAqB,CACrC1M,WAJJ,GAIkB,EACdD,cAAc,EACdL,cAAe,IAAI,CAAC+C,GAAG,IAEzBtB,KAAK,CAAC,WAAO,GAGjBmD,EAAMgH,SAAS,CAAGrT,OAAOC,MAAM,CAAC,CAAC,EAAGoM,EAAMgH,SAAS,EACnD3C,EAAUrE,KAAK,CAAGA,EAClBqE,EAAU/G,KAAK,CAAGA,EAClB+G,EAAUjL,KAAK,CAAGA,EAClBiL,EAAUrO,UAAU,CAAGA,EACvB,IAAI,CAAC8J,UAAU,CAACxC,EAAM,CAAG+G,EAEzB,GAAOA,WAEP,qBAAO,IAAI,CAACyD,oBAAoB,CAC9BmB,CAAAA,EAAAA,EAAAA,cAAAA,EAAenM,GACftI,EACA4E,EACAvD,EACAwP,wBAGN,0CAEQK,CACkB,CACxB1L,CAAsB,CACtB0N,CAA4C,EAI5C,OAFA,IAAI,CAACjJ,KAAK,CAAGA,EAEN,IAAI,CAACyK,GAAG,CACblP,EACA,IAAI,CAAC8F,UAAU,CAAC,QAAQ,CAACjC,SAAS,CAClC6J,EAEJ,IAKC,oCACcyB,CAA0B,EAAE,IACrC,CAAC1J,IAAI,CAAG0J,CACd,yCAEA1D,CAA0B,EAAW,GAC/B,CAAC,IAAI,CAAClR,MAAM,CAAE,OAAO,EACzB,IAAgC,EAA1B,QAA8B,CAACA,MAAM,CAAC4O,KAAK,CAAC,IAAK,MAAhDiG,EAAAA,CAAAA,CAAAA,EAAAA,CAAcC,EAAQ,KAC7B,CAD6B,CACvB,MAA6BlG,KAAK,CAAC,IAAK,MAAvCmG,EAAAA,CAAAA,CAAAA,EAAAA,CAAcC,EAAW1T,CAAAA,CAAAA,EAAAA,EAAH,KAG7B,EAAI0T,GAAWH,IAAiBE,GAAgBD,IAAYE,GAKxDH,IAAiBE,EALgD,CAa9DD,IAAYE,CACrB,MATqC,gCAWrC1B,CAAuB,EAAQ,IACO,EAA9B,MAAmB1E,KAAK,CAAC,IAAK,KAAdtN,CAAAA,EAAAA,CAAAA,EAAAA,KAAAA,IAAAA,EAAN,EAAE,CAAC,EAEnB2T,CAAAA,EAAAA,EAAAA,wCAAAA,EACE,WAGE,GAAa,KAAT5P,GAAwB,QAATA,EAAgB,YACjCU,OAAOmP,QAAQ,CAAC,EAAG,GAKrB,IAAMC,EAAUC,mBAAmB/P,GAE7BgQ,EAAOC,SAASC,cAAc,CAACJ,GACrC,GAAIE,EAAM,YACRA,EAAKG,cAAc,GAKrB,IAAMC,EAASH,SAASI,iBAAiB,CAACP,EAAQ,CAAC,EAAE,CACjDM,GACFA,EAAOD,GADG,WACW,EAEzB,EACA,CACEG,eAAgB,IAAI,CAACzE,eAAe,CAAC5P,EACvC,EAEJ,IAEAgQ,IAAAA,0BAAStR,CAAc,EAAW,OACzB,IAAI,CAACA,MAAM,GAAKA,CACzB,IAQM4V,IAAAA,iBAAN,CANA,QAOE7U,CAAW,CACXf,CAAoB,CACpBT,CAA6B,EACd,4BAYX8R,EAAAA,EAAAA,EAGYxM,EAAO,EAUbgR,CAVW,CAUXA,EAAAA,EAkBJrG,EAOAlL,EAAAA,EAAAA,EAAAA,EAAAA,UAzBIuR,2CAnBV,IAAI,KAA6B,CARjC7V,KAAAA,IAAAA,IAAAA,EAAiBe,CAAAA,EACjBxB,KAAAA,IAAAA,GAAAA,GAA2B,EAAC,EAOSuW,CAAAA,EAAAA,EAAAA,KAAAA,EAAM/P,OAAOgQ,SAAS,CAACC,SAAS,EAInE,CAJsE,KAItE,WAGIC,EAAc5E,GADPzN,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiB7C,EAAAA,EACHd,QAAQ,KAE7BA,QAAQ,GAAYoR,EAAAA,KAAAA,GACDpR,KAmBL,IAAI,CAACJ,UAAU,CAACqE,WAAW,kBAAzCnC,EAAQ,SACVN,EAAazB,EAEXQ,EACJ,KAA0B,IAAnBjB,EAAQiB,MAAM,CACjBjB,EAAQiB,MAAM,EAAIiE,OAClB,IAAI,CAACjE,MAAM,IAEetB,EAAkB,CAChDc,OAAQA,EACRQ,OAAQA,EACRZ,OAAQ,IAAI,WAGiD,SANrC,SAMqC,aAa7D,GAXgB0E,EAAa,EAAMH,IAAAA,EAAT,CAAtBE,UAAAA,CAWAoL,CATEA,EAAiB1Q,EACrBuB,CAAAA,EAAAA,EAAAA,WAAAA,EAAYC,CAAAA,EAAAA,EAAAA,SAAAA,EAAUP,EAAQ,IAAI,CAACQ,MAAM,GAAG,GAC5CuB,EACAuC,EACA+M,EAAOxM,KAAK,CACZ,SAACqR,CAAAA,SAAcpU,EAAoBoU,EAAGnU,IACtC,IAAI,CAACkB,QAAO,EAGKkT,YAAY,CAC7B,CAD+B,KAC/B,GAGE,CAAC3G,IACH/N,EAAawP,CAAAA,EAAAA,EAAAA,QADS,IACTA,EACX7Q,CAAAA,EAAAA,EAAAA,cAAAA,EAAeqP,EAAezP,MAAM,EACpC,IAAI,CAACQ,OAAM,EAIXiP,EAAe2G,WAAW,EAAI3G,EAAejO,YAAY,EAAE,CAG7DvB,EAAWwP,EAAejO,YAAY,CACtC6P,EAAOpR,QAAQ,CAAGA,EAEbuP,IACHzO,EAAMqJ,CAAAA,EAAAA,EAAAA,QADgB,YAChBA,EAAqBiH,EAAAA,oBAsB/B3N,OAlBF2N,EAAOpR,QAAQ,CAAG6B,EAAoBuP,EAAOpR,QAAQ,CAAE8B,GAEnDM,CAAAA,EAAAA,EAAAA,cAAAA,EAAegP,EAAOpR,QAAQ,GAAG,CACnCA,EAAWoR,EAAOpR,QAAQ,CAC1BoR,EAAOpR,QAAQ,CAAGA,EAClBb,OAAOC,MAAM,CACXwF,EACAD,CAAAA,EAAAA,EAAAA,eAAAA,EAAgBtC,CAAAA,EAAAA,EAAAA,aAAAA,EAAc+O,EAAOpR,QAAQ,GAC3CR,CAAAA,EAAAA,EAAAA,SAAS,EAACO,GAAQC,QAAQ,GACvB,CAAC,GAGJ,IACFc,EAAMqJ,CAAAA,EAAAA,EAAAA,QADgB,YAChBA,EAAqBiH,EAAAA,GAK7B3N,aAEI,SAAMlB,EAAsB,CAC1BE,UAAW,kBACTkE,EAAc,CACZlB,SAAU,EAAK7F,EAAD,QAAW,CAACqU,WAAW,CAAC,CACpC3M,KAAM6C,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqB,CACzBnK,SAAUoW,EACVxR,MAAAA,CACF,GACAsP,mBAAmB,EACnBnU,OAAQyB,SACRjB,CACF,GACAuG,eAAe,EACfC,eAAgB,GAChBC,UAAW,GACXJ,cAAe,EAAK8C,EAAD,CAAI,CACvBzC,aAAc,CAAC,EAAKwC,EAAD,OAAU,CAC7B5C,YAAY,CACd,IACF9G,OAAQA,EACRQ,OAAQA,EACRZ,OAAQ,IAAI,uCAmBpB,IAZI6F,OA/BEA,EAAAA,CAAAA,EA+BFA,KAAAA,EAAAA,EAAMhD,MAAM,CAACqC,IAAAA,IAAS,WAAW,CACnCuM,EAAOpR,QAAQ,CAAGwF,EAAKhD,MAAM,CAACjB,YAAY,CAC1CvB,EAAWwF,EAAKhD,MAAM,CAACjB,YAAY,CACnCqD,EAAQ,OAAKA,EAAUY,EAAKhD,CAAV,KAAgB,CAACsC,QAAQ,CAACF,KAAK,EACjDpD,EAAagE,EAAKhD,MAAM,CAACsC,QAAQ,CAAC9E,QAAQ,CAC1Cc,EAAMqJ,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqBiH,IAOzB5L,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAMhD,MAAM,CAACqC,IAAAA,IAAS,oBACxB,CAD6C,KAC7C,WAGIiE,EAAQ9G,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBhC,MAExB,IAAI,CAACkN,IAAI,CAACnN,EAAQyB,EAAYlC,EAAQiB,MAAM,EAAE,kBAApD,UAA2D,CAC7D,IAAI,CAAC+K,UAAU,CAAC0K,EAAY,CAAG,CAAE1E,aAAa,EAAK,KAG/C7R,QAAQuE,GAAG,CAAC,CAChB,IAAI,CAACpE,UAAU,CAACyW,MAAM,CAACvN,GAAO3E,IAAI,CAAC,SAACmS,CAAAA,EAClC,QAAOA,GACH3P,EAAc,CACZlB,SAAUD,CAAAA,MAAAA,EAAAA,KAAAA,EAAAA,EAAME,IAAAA,EACZF,MAAAA,EAAAA,KAAAA,EAAAA,EAAMC,QAAQ,CACd,EAAK7F,EAAD,QAAW,CAACqU,WAAW,CAAC,CAC1B3M,KAAMxG,EACNf,OAAQyB,EACRjB,OAAQA,CACV,GACJwG,gBAAgB,EAChBC,UAAW,GACXJ,cAAe,EAAK8C,EAAD,CAAI,CACvBzC,aAAc,CAAC,EAAKwC,EAAD,OAAU,CAC7B5C,YAAY,EACZM,yBACE7H,EAAQ6H,wBAAwB,EAC/B7H,EAAQiX,QAAQ,EACf,CAAC,CACP,GACGpS,CAF+C,GAE3C,CAAC,kBAAM,IACXkE,KAAK,CAAC,kBAAM,GAErB,GADM,IAEF,CAACzI,UAAU,CAACN,EAAQiX,QAAQ,CAAG,WAAa,WAAW,CAACzN,oBAzB9D,eA2BF,iBAEM8J,IAAAA,uBAAN,SAAqB9J,CAAa,EAAE,8BAQzBR,qDAPHW,EAAkBJ,GAAoB,OAAEC,EAAOnJ,OAAQ,IAAI,oDAGjC,IAAI,CAACC,UAAU,CAAC4W,QAAQ,CAAC1N,WAGvD,OAHM2N,EAAkB,SACxBxN,IAEA,GAAOwN,UAGP,iBADAxN,IACMX,qBAEV,+CAEAiM,CAAgC,EAAc,WACxClV,GAAY,EACV0J,EAAS,WACb1J,EAAY,EACd,EAEA,OADA,IAAI,CAAC2J,GAAG,CAAGD,EACJ2N,IAAKvS,IAAI,CAAC,SAACqB,CAAAA,EAKhB,GAJIuD,IAAW,EAAKC,EAAD,CAAI,EAAE,CACvB,EAAKA,EAAD,CAAI,CAAG,MAGT3J,EAAW,CACb,IAAMiJ,EAAW,qBAA4C,CAA5C,MAAU,mCAAV,+DAA2C,EAE5D,OADAA,EAAIjJ,SAAS,EAAG,EACViJ,CACR,CAEA,OAAO9C,CACT,EACF,yCAEAiO,CAC0B,CACxBkD,CAAoB,EACU,IACXxN,EAAb,CAAgB,EAAE,CAAO,CAACmC,UAAU,CAAC,QAAQ,CAA3CjC,SAAAA,CACFuN,EAAU,IAAI,CAAC5K,QAAQ,CAAC7C,GAE9B,OADAwN,EAAIC,OAAO,CAAGA,EACPC,CAAAA,EAAAA,EAAAA,mBAAAA,EAA4C1N,EAAK,SACtDyN,YACAvN,EACA1J,OAAQ,IAAI,KACZgX,CACF,EACF,QAEI7N,QAAgB,IAApB,WACE,OAAO,IAAI,CAACmB,KAAK,CAACnB,KAAK,IAGrB9I,IAAAA,MAAmB,SAAvB,WACE,OAAO,IAAI,CAACiK,KAAK,CAACjK,QAAQ,QAGxB4E,QAAwB,IAA5B,WACE,OAAO,IAAI,CAACqF,KAAK,CAACrF,KAAK,QAGrB7E,SAAiB,IAArB,WACE,OAAO,IAAI,CAACkK,KAAK,CAAClK,MAAM,QAGtBQ,SAA6B,IAAjC,WACE,OAAO,IAAI,CAAC0J,KAAK,CAAC1J,MAAM,QAGtBgJ,aAAsB,IAA1B,WACE,OAAO,IAAI,CAACU,KAAK,CAACV,UAAU,QAG1BE,YAAqB,IAAzB,WACE,OAAO,IAAI,CAACQ,KAAK,CAACR,SAAS,KA/3DVzK,KAAAA,GA6CZ4M,MAAAA,CAAmCkL,CAAAA,EAAAA,EAAAA,OAAAA,AAAI","sources":["webpack://_N_E/../../../../src/shared/lib/router/router.ts"],"sourcesContent":["// tslint:disable:no-console\nimport type { ComponentType } from 'react'\nimport type { DomainLocale } from '../../../server/config'\nimport type { MittEmitter } from '../mitt'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { RouterEvent } from '../../../client/router'\nimport type { StyleSheetTuple } from '../../../client/page-loader'\nimport type { UrlObject } from 'url'\nimport type PageLoader from '../../../client/page-loader'\nimport type { AppContextType, NextPageContext, NEXT_DATA } from '../utils'\nimport { removeTrailingSlash } from './utils/remove-trailing-slash'\nimport {\n  getClientBuildManifest,\n  isAssetError,\n  markAssetError,\n} from '../../../client/route-loader'\nimport { handleClientScriptLoad } from '../../../client/script'\nimport isError, { getProperError } from '../../../lib/is-error'\nimport { denormalizePagePath } from '../page-path/denormalize-page-path'\nimport { normalizeLocalePath } from '../i18n/normalize-locale-path'\nimport mitt from '../mitt'\nimport { getLocationOrigin, getURL, loadGetInitialProps, ST } from '../utils'\nimport { isDynamicRoute } from './utils/is-dynamic'\nimport { parseRelativeUrl } from './utils/parse-relative-url'\nimport { getRouteMatcher } from './utils/route-matcher'\nimport { getRouteRegex } from './utils/route-regex'\nimport { formatWithValidation } from './utils/format-url'\nimport { detectDomainLocale } from '../../../client/detect-domain-locale'\nimport { parsePath } from './utils/parse-path'\nimport { addLocale } from '../../../client/add-locale'\nimport { removeLocale } from '../../../client/remove-locale'\nimport { removeBasePath } from '../../../client/remove-base-path'\nimport { addBasePath } from '../../../client/add-base-path'\nimport { hasBasePath } from '../../../client/has-base-path'\nimport { resolveHref } from '../../../client/resolve-href'\nimport { isAPIRoute } from '../../../lib/is-api-route'\nimport { getNextPathnameInfo } from './utils/get-next-pathname-info'\nimport { formatNextPathnameInfo } from './utils/format-next-pathname-info'\nimport { compareRouterStates } from './utils/compare-states'\nimport { isLocalURL } from './utils/is-local-url'\nimport { isBot } from './utils/is-bot'\nimport { omit } from './utils/omit'\nimport { interpolateAs } from './utils/interpolate-as'\nimport { disableSmoothScrollDuringRouteTransition } from './utils/disable-smooth-scroll'\nimport type { Params } from '../../../server/request/params'\nimport { MATCHED_PATH_HEADER } from '../../../lib/constants'\n\nlet resolveRewrites: typeof import('./utils/resolve-rewrites').default\nif (process.env.__NEXT_HAS_REWRITES) {\n  resolveRewrites = (\n    require('./utils/resolve-rewrites') as typeof import('./utils/resolve-rewrites')\n  ).default\n}\n\ndeclare global {\n  interface Window {\n    /* prod */\n    __NEXT_DATA__: NEXT_DATA\n  }\n}\n\ninterface RouteProperties {\n  shallow: boolean\n}\n\ninterface TransitionOptions {\n  shallow?: boolean\n  locale?: string | false\n  scroll?: boolean\n  unstable_skipClientCache?: boolean\n}\n\ninterface NextHistoryState {\n  url: string\n  as: string\n  options: TransitionOptions\n}\n\nexport type HistoryState =\n  | null\n  | { __NA: true; __N?: false }\n  | { __N: false; __NA?: false }\n  | ({ __NA?: false; __N: true; key: string } & NextHistoryState)\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true,\n  })\n}\n\ninterface MiddlewareEffectParams<T extends FetchDataOutput> {\n  fetchData?: () => Promise<T>\n  locale?: string\n  asPath: string\n  router: Router\n}\n\nexport async function matchesMiddleware<T extends FetchDataOutput>(\n  options: MiddlewareEffectParams<T>\n): Promise<boolean> {\n  const matchers = await Promise.resolve(\n    options.router.pageLoader.getMiddleware()\n  )\n  if (!matchers) return false\n\n  const { pathname: asPathname } = parsePath(options.asPath)\n  // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n  const cleanedAs = hasBasePath(asPathname)\n    ? removeBasePath(asPathname)\n    : asPathname\n  const asWithBasePathAndLocale = addBasePath(\n    addLocale(cleanedAs, options.locale)\n  )\n\n  // Check only path match on client. Matching \"has\" should be done on server\n  // where we can access more info such as headers, HttpOnly cookie, etc.\n  return matchers.some((m) =>\n    new RegExp(m.regexp).test(asWithBasePathAndLocale)\n  )\n}\n\nfunction stripOrigin(url: string) {\n  const origin = getLocationOrigin()\n\n  return url.startsWith(origin) ? url.substring(origin.length) : url\n}\n\nfunction prepareUrlAs(router: NextRouter, url: Url, as?: Url) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = resolveHref(router, url, true)\n  const origin = getLocationOrigin()\n  const hrefWasAbsolute = resolvedHref.startsWith(origin)\n  const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin)\n\n  resolvedHref = stripOrigin(resolvedHref)\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs\n\n  const preparedUrl = hrefWasAbsolute ? resolvedHref : addBasePath(resolvedHref)\n  const preparedAs = as\n    ? stripOrigin(resolveHref(router, as))\n    : resolvedAs || resolvedHref\n\n  return {\n    url: preparedUrl,\n    as: asWasAbsolute ? preparedAs : addBasePath(preparedAs),\n  }\n}\n\nfunction resolveDynamicRoute(pathname: string, pages: string[]) {\n  const cleanPathname = removeTrailingSlash(denormalizePagePath(pathname))\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname\n  }\n\n  // handle resolving href for dynamic routes\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some((page) => {\n      if (isDynamicRoute(page) && getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page\n        return true\n      }\n    })\n  }\n  return removeTrailingSlash(pathname)\n}\n\nfunction getMiddlewareData<T extends FetchDataOutput>(\n  source: string,\n  response: Response,\n  options: MiddlewareEffectParams<T>\n) {\n  const nextConfig = {\n    basePath: options.router.basePath,\n    i18n: { locales: options.router.locales },\n    trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH),\n  }\n  const rewriteHeader = response.headers.get('x-nextjs-rewrite')\n\n  let rewriteTarget =\n    rewriteHeader || response.headers.get('x-nextjs-matched-path')\n\n  const matchedPath = response.headers.get(MATCHED_PATH_HEADER)\n\n  if (\n    matchedPath &&\n    !rewriteTarget &&\n    !matchedPath.includes('__next_data_catchall') &&\n    !matchedPath.includes('/_error') &&\n    !matchedPath.includes('/404')\n  ) {\n    // leverage x-matched-path to detect next.config.js rewrites\n    rewriteTarget = matchedPath\n  }\n\n  if (rewriteTarget) {\n    if (\n      rewriteTarget.startsWith('/') ||\n      process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE\n    ) {\n      const parsedRewriteTarget = parseRelativeUrl(rewriteTarget)\n      const pathnameInfo = getNextPathnameInfo(parsedRewriteTarget.pathname, {\n        nextConfig,\n        parseData: true,\n      })\n\n      let fsPathname = removeTrailingSlash(pathnameInfo.pathname)\n      return Promise.all([\n        options.router.pageLoader.getPageList(),\n        getClientBuildManifest(),\n      ]).then(([pages, { __rewrites: rewrites }]: any) => {\n        let as = addLocale(pathnameInfo.pathname, pathnameInfo.locale)\n\n        if (\n          isDynamicRoute(as) ||\n          (!rewriteHeader &&\n            pages.includes(\n              normalizeLocalePath(removeBasePath(as), options.router.locales)\n                .pathname\n            ))\n        ) {\n          const parsedSource = getNextPathnameInfo(\n            parseRelativeUrl(source).pathname,\n            {\n              nextConfig: process.env.__NEXT_HAS_REWRITES\n                ? undefined\n                : nextConfig,\n              parseData: true,\n            }\n          )\n\n          as = addBasePath(parsedSource.pathname)\n          parsedRewriteTarget.pathname = as\n        }\n\n        if (process.env.__NEXT_HAS_REWRITES) {\n          const result = resolveRewrites(\n            as,\n            pages,\n            rewrites,\n            parsedRewriteTarget.query,\n            (path: string) => resolveDynamicRoute(path, pages),\n            options.router.locales\n          )\n\n          if (result.matchedPage) {\n            parsedRewriteTarget.pathname = result.parsedAs.pathname\n            as = parsedRewriteTarget.pathname\n            Object.assign(parsedRewriteTarget.query, result.parsedAs.query)\n          }\n        } else if (!pages.includes(fsPathname)) {\n          const resolvedPathname = resolveDynamicRoute(fsPathname, pages)\n\n          if (resolvedPathname !== fsPathname) {\n            fsPathname = resolvedPathname\n          }\n        }\n\n        const resolvedHref = !pages.includes(fsPathname)\n          ? resolveDynamicRoute(\n              normalizeLocalePath(\n                removeBasePath(parsedRewriteTarget.pathname),\n                options.router.locales\n              ).pathname,\n              pages\n            )\n          : fsPathname\n\n        if (isDynamicRoute(resolvedHref)) {\n          const matches = getRouteMatcher(getRouteRegex(resolvedHref))(as)\n          Object.assign(parsedRewriteTarget.query, matches || {})\n        }\n\n        return {\n          type: 'rewrite' as const,\n          parsedAs: parsedRewriteTarget,\n          resolvedHref,\n        }\n      })\n    }\n    const src = parsePath(source)\n    const pathname = formatNextPathnameInfo({\n      ...getNextPathnameInfo(src.pathname, { nextConfig, parseData: true }),\n      defaultLocale: options.router.defaultLocale,\n      buildId: '',\n    })\n\n    return Promise.resolve({\n      type: 'redirect-external' as const,\n      destination: `${pathname}${src.query}${src.hash}`,\n    })\n  }\n\n  const redirectTarget = response.headers.get('x-nextjs-redirect')\n\n  if (redirectTarget) {\n    if (redirectTarget.startsWith('/')) {\n      const src = parsePath(redirectTarget)\n      const pathname = formatNextPathnameInfo({\n        ...getNextPathnameInfo(src.pathname, { nextConfig, parseData: true }),\n        defaultLocale: options.router.defaultLocale,\n        buildId: '',\n      })\n\n      return Promise.resolve({\n        type: 'redirect-internal' as const,\n        newAs: `${pathname}${src.query}${src.hash}`,\n        newUrl: `${pathname}${src.query}${src.hash}`,\n      })\n    }\n\n    return Promise.resolve({\n      type: 'redirect-external' as const,\n      destination: redirectTarget,\n    })\n  }\n\n  return Promise.resolve({ type: 'next' as const })\n}\n\ninterface WithMiddlewareEffectsOutput extends FetchDataOutput {\n  effect: Awaited<ReturnType<typeof getMiddlewareData>>\n}\n\nasync function withMiddlewareEffects<T extends FetchDataOutput>(\n  options: MiddlewareEffectParams<T>\n): Promise<WithMiddlewareEffectsOutput | null> {\n  const matches = await matchesMiddleware(options)\n  if (!matches || !options.fetchData) {\n    return null\n  }\n\n  const data = await options.fetchData()\n\n  const effect = await getMiddlewareData(data.dataHref, data.response, options)\n\n  return {\n    dataHref: data.dataHref,\n    json: data.json,\n    response: data.response,\n    text: data.text,\n    cacheKey: data.cacheKey,\n    effect,\n  }\n}\n\nexport type Url = UrlObject | string\n\nexport type BaseRouter = {\n  route: string\n  pathname: string\n  query: ParsedUrlQuery\n  asPath: string\n  basePath: string\n  locale?: string | undefined\n  locales?: readonly string[] | undefined\n  defaultLocale?: string | undefined\n  domainLocales?: readonly DomainLocale[] | undefined\n  isLocaleDomain: boolean\n}\n\nexport type NextRouter = BaseRouter &\n  Pick<\n    Router,\n    | 'push'\n    | 'replace'\n    | 'reload'\n    | 'back'\n    | 'forward'\n    | 'prefetch'\n    | 'beforePopState'\n    | 'events'\n    | 'isFallback'\n    | 'isReady'\n    | 'isPreview'\n  >\n\nexport type PrefetchOptions = {\n  priority?: boolean\n  locale?: string | false\n  unstable_skipClientCache?: boolean\n}\n\nexport type PrivateRouteInfo =\n  | (Omit<CompletePrivateRouteInfo, 'styleSheets'> & { initial: true })\n  | CompletePrivateRouteInfo\n\nexport type CompletePrivateRouteInfo = {\n  Component: ComponentType\n  styleSheets: StyleSheetTuple[]\n  __N_SSG?: boolean\n  __N_SSP?: boolean\n  props?: Record<string, any>\n  err?: Error\n  error?: any\n  route?: string\n  resolvedAs?: string\n  query?: ParsedUrlQuery\n}\n\nexport type AppProps = Pick<CompletePrivateRouteInfo, 'Component' | 'err'> & {\n  router: Router\n} & Record<string, any>\nexport type AppComponent = ComponentType<AppProps>\n\ntype Subscription = (\n  data: PrivateRouteInfo,\n  App: AppComponent,\n  resetScroll: { x: number; y: number } | null\n) => Promise<void>\n\ntype BeforePopStateCallback = (state: NextHistoryState) => boolean\n\ntype ComponentLoadCancel = (() => void) | null\n\ntype HistoryMethod = 'replaceState' | 'pushState'\n\nconst manualScrollRestoration =\n  process.env.__NEXT_SCROLL_RESTORATION &&\n  typeof window !== 'undefined' &&\n  'scrollRestoration' in window.history &&\n  !!(function () {\n    try {\n      let v = '__next'\n      // eslint-disable-next-line no-sequences\n      return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true\n    } catch (n) {}\n  })()\n\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND')\n\nfunction fetchRetry(\n  url: string,\n  attempts: number,\n  options: Pick<RequestInit, 'method' | 'headers'>\n): Promise<Response> {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wont send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin',\n    method: options.method || 'GET',\n    headers: Object.assign({}, options.headers, {\n      'x-nextjs-data': '1',\n    }),\n  }).then((response) => {\n    return !response.ok && attempts > 1 && response.status >= 500\n      ? fetchRetry(url, attempts - 1, options)\n      : response\n  })\n}\n\ninterface FetchDataOutput {\n  dataHref: string\n  json: Record<string, any> | null\n  response: Response\n  text: string\n  cacheKey: string\n}\n\ninterface FetchNextDataParams {\n  dataHref: string\n  isServerRender: boolean\n  parseJSON: boolean | undefined\n  hasMiddleware?: boolean\n  inflightCache: NextDataCache\n  persistCache: boolean\n  isPrefetch: boolean\n  isBackground?: boolean\n  unstable_skipClientCache?: boolean\n}\n\nfunction tryToParseAsJSON(text: string) {\n  try {\n    return JSON.parse(text)\n  } catch (error) {\n    return null\n  }\n}\n\nfunction fetchNextData({\n  dataHref,\n  inflightCache,\n  isPrefetch,\n  hasMiddleware,\n  isServerRender,\n  parseJSON,\n  persistCache,\n  isBackground,\n  unstable_skipClientCache,\n}: FetchNextDataParams): Promise<FetchDataOutput> {\n  const { href: cacheKey } = new URL(dataHref, window.location.href)\n  const getData = (params?: { method?: 'HEAD' | 'GET' }) =>\n    fetchRetry(dataHref, isServerRender ? 3 : 1, {\n      headers: Object.assign(\n        {} as HeadersInit,\n        isPrefetch ? { purpose: 'prefetch' } : {},\n        isPrefetch && hasMiddleware ? { 'x-middleware-prefetch': '1' } : {},\n        process.env.NEXT_DEPLOYMENT_ID\n          ? { 'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID }\n          : {}\n      ),\n      method: params?.method ?? 'GET',\n    })\n      .then((response) => {\n        if (response.ok && params?.method === 'HEAD') {\n          return { dataHref, response, text: '', json: {}, cacheKey }\n        }\n\n        return response.text().then((text) => {\n          if (!response.ok) {\n            /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */\n            if (\n              hasMiddleware &&\n              [301, 302, 307, 308].includes(response.status)\n            ) {\n              return { dataHref, response, text, json: {}, cacheKey }\n            }\n\n            if (response.status === 404) {\n              if (tryToParseAsJSON(text)?.notFound) {\n                return {\n                  dataHref,\n                  json: { notFound: SSG_DATA_NOT_FOUND },\n                  response,\n                  text,\n                  cacheKey,\n                }\n              }\n            }\n\n            const error = new Error(`Failed to load static props`)\n\n            /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */\n            if (!isServerRender) {\n              markAssetError(error)\n            }\n\n            throw error\n          }\n\n          return {\n            dataHref,\n            json: parseJSON ? tryToParseAsJSON(text) : null,\n            response,\n            text,\n            cacheKey,\n          }\n        })\n      })\n      .then((data) => {\n        if (\n          !persistCache ||\n          process.env.NODE_ENV !== 'production' ||\n          data.response.headers.get('x-middleware-cache') === 'no-cache'\n        ) {\n          delete inflightCache[cacheKey]\n        }\n        return data\n      })\n      .catch((err) => {\n        if (!unstable_skipClientCache) {\n          delete inflightCache[cacheKey]\n        }\n        if (\n          // chrome\n          err.message === 'Failed to fetch' ||\n          // firefox\n          err.message === 'NetworkError when attempting to fetch resource.' ||\n          // safari\n          err.message === 'Load failed'\n        ) {\n          markAssetError(err)\n        }\n        throw err\n      })\n\n  // when skipping client cache we wait to update\n  // inflight cache until successful data response\n  // this allows racing click event with fetching newer data\n  // without blocking navigation when stale data is available\n  if (unstable_skipClientCache && persistCache) {\n    return getData({}).then((data) => {\n      if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n        // only update cache if not marked as no-cache\n        inflightCache[cacheKey] = Promise.resolve(data)\n      }\n\n      return data\n    })\n  }\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey]\n  }\n  return (inflightCache[cacheKey] = getData(\n    isBackground ? { method: 'HEAD' } : {}\n  ))\n}\n\ninterface NextDataCache {\n  [asPath: string]: Promise<FetchDataOutput>\n}\n\nexport function createKey() {\n  return Math.random().toString(36).slice(2, 10)\n}\n\nfunction handleHardNavigation({\n  url,\n  router,\n}: {\n  url: string\n  router: Router\n}) {\n  // ensure we don't trigger a hard navigation to the same\n  // URL as this can end up with an infinite refresh\n  if (url === addBasePath(addLocale(router.asPath, router.locale))) {\n    throw new Error(\n      `Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`\n    )\n  }\n  window.location.href = url\n}\n\nconst getCancelledHandler = ({\n  route,\n  router,\n}: {\n  route: string\n  router: Router\n}) => {\n  let cancelled = false\n  const cancel = (router.clc = () => {\n    cancelled = true\n  })\n\n  const handleCancelled = () => {\n    if (cancelled) {\n      const error: any = new Error(\n        `Abort fetching component for route: \"${route}\"`\n      )\n      error.cancelled = true\n      throw error\n    }\n\n    if (cancel === router.clc) {\n      router.clc = null\n    }\n  }\n  return handleCancelled\n}\n\nexport default class Router implements BaseRouter {\n  basePath: string\n\n  /**\n   * Map of all components loaded in `Router`\n   */\n  components: { [pathname: string]: PrivateRouteInfo }\n  // Server Data Cache (full data requests)\n  sdc: NextDataCache = {}\n  // Server Background Cache (HEAD requests)\n  sbc: NextDataCache = {}\n\n  sub: Subscription\n  clc: ComponentLoadCancel\n  pageLoader: PageLoader\n  _bps: BeforePopStateCallback | undefined\n  events: MittEmitter<RouterEvent>\n  _wrapApp: (App: AppComponent) => any\n  isSsr: boolean\n  _inFlightRoute?: string | undefined\n  _shallow?: boolean | undefined\n  locales?: readonly string[] | undefined\n  defaultLocale?: string | undefined\n  domainLocales?: readonly DomainLocale[] | undefined\n  isReady: boolean\n  isLocaleDomain: boolean\n  isFirstPopStateEvent = true\n  _initialMatchesMiddlewarePromise: Promise<boolean>\n  // static entries filter\n  _bfl_s?: import('../../lib/bloom-filter').BloomFilter\n  // dynamic entires filter\n  _bfl_d?: import('../../lib/bloom-filter').BloomFilter\n\n  private state: Readonly<{\n    route: string\n    pathname: string\n    query: ParsedUrlQuery\n    asPath: string\n    locale: string | undefined\n    isFallback: boolean\n    isPreview: boolean\n  }>\n\n  private _key: string = createKey()\n\n  static events: MittEmitter<RouterEvent> = mitt()\n\n  constructor(\n    pathname: string,\n    query: ParsedUrlQuery,\n    as: string,\n    {\n      initialProps,\n      pageLoader,\n      App,\n      wrapApp,\n      Component,\n      err,\n      subscription,\n      isFallback,\n      locale,\n      locales,\n      defaultLocale,\n      domainLocales,\n      isPreview,\n    }: {\n      subscription: Subscription\n      initialProps: any\n      pageLoader: any\n      Component: ComponentType\n      App: AppComponent\n      wrapApp: (WrapAppComponent: AppComponent) => any\n      err?: Error\n      isFallback: boolean\n      locale?: string\n      locales?: readonly string[]\n      defaultLocale?: string\n      domainLocales?: readonly DomainLocale[]\n      isPreview?: boolean\n    }\n  ) {\n    // represents the current component key\n    const route = removeTrailingSlash(pathname)\n\n    // set up the component cache (by route keys)\n    this.components = {}\n    // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n    if (pathname !== '/_error') {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n      }\n    }\n\n    this.components['/_app'] = {\n      Component: App as ComponentType,\n      styleSheets: [\n        /* /_app does not need its stylesheets managed */\n      ],\n    }\n\n    // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n    this.events = Router.events\n\n    this.pageLoader = pageLoader\n    // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n    const autoExportDynamic =\n      isDynamicRoute(pathname) && self.__NEXT_DATA__.autoExport\n\n    this.basePath = process.env.__NEXT_ROUTER_BASEPATH || ''\n    this.sub = subscription\n    this.clc = null\n    this._wrapApp = wrapApp\n    // make sure to ignore extra popState in safari on navigating\n    // back from external site\n    this.isSsr = true\n    this.isLocaleDomain = false\n    this.isReady = !!(\n      self.__NEXT_DATA__.gssp ||\n      self.__NEXT_DATA__.gip ||\n      self.__NEXT_DATA__.isExperimentalCompile ||\n      (self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp) ||\n      (!autoExportDynamic &&\n        !self.location.search &&\n        !process.env.__NEXT_HAS_REWRITES)\n    )\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales\n      this.defaultLocale = defaultLocale\n      this.domainLocales = domainLocales\n      this.isLocaleDomain = !!detectDomainLocale(\n        domainLocales,\n        self.location.hostname\n      )\n    }\n\n    this.state = {\n      route,\n      pathname,\n      query,\n      asPath: autoExportDynamic ? pathname : as,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback,\n    }\n\n    this._initialMatchesMiddlewarePromise = Promise.resolve(false)\n\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options: TransitionOptions = { locale }\n        const asPath = getURL()\n\n        this._initialMatchesMiddlewarePromise = matchesMiddleware({\n          router: this,\n          locale,\n          asPath,\n        }).then((matches) => {\n          // if middleware matches we leave resolving to the change function\n          // as the server needs to resolve for correct priority\n          ;(options as any)._shouldResolveHref = as !== pathname\n\n          this.changeState(\n            'replaceState',\n            matches\n              ? asPath\n              : formatWithValidation({\n                  pathname: addBasePath(pathname),\n                  query,\n                }),\n            asPath,\n            options\n          )\n          return matches\n        })\n      }\n\n      window.addEventListener('popstate', this.onPopState)\n\n      // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual'\n        }\n      }\n    }\n  }\n\n  onPopState = (e: PopStateEvent): void => {\n    const { isFirstPopStateEvent } = this\n    this.isFirstPopStateEvent = false\n\n    const state = e.state as HistoryState\n\n    if (!state) {\n      // We get state as undefined for two reasons.\n      //  1. With older safari (< 8) and older chrome (< 34)\n      //  2. When the URL changed with #\n      //\n      // In the both cases, we don't need to proceed and change the route.\n      // (as it's already changed)\n      // But we can simply replace the state with the new changes.\n      // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n      // So, doing the following for (1) does no harm.\n      const { pathname, query } = this\n      this.changeState(\n        'replaceState',\n        formatWithValidation({ pathname: addBasePath(pathname), query }),\n        getURL()\n      )\n      return\n    }\n\n    // __NA is used to identify if the history entry can be handled by the app-router.\n    if (state.__NA) {\n      window.location.reload()\n      return\n    }\n\n    if (!state.__N) {\n      return\n    }\n\n    // Safari fires popstateevent when reopening the browser.\n    if (\n      isFirstPopStateEvent &&\n      this.locale === state.options.locale &&\n      state.as === this.asPath\n    ) {\n      return\n    }\n\n    let forcedScroll: { x: number; y: number } | undefined\n    const { url, as, options, key } = state\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      if (manualScrollRestoration) {\n        if (this._key !== key) {\n          // Snapshot current scroll position:\n          try {\n            sessionStorage.setItem(\n              '__next_scroll_' + this._key,\n              JSON.stringify({ x: self.pageXOffset, y: self.pageYOffset })\n            )\n          } catch {}\n\n          // Restore old scroll position:\n          try {\n            const v = sessionStorage.getItem('__next_scroll_' + key)\n            forcedScroll = JSON.parse(v!)\n          } catch {\n            forcedScroll = { x: 0, y: 0 }\n          }\n        }\n      }\n    }\n    this._key = key\n\n    const { pathname } = parseRelativeUrl(url)\n\n    // Make sure we don't re-render on initial load,\n    // can be caused by navigating back from an external site\n    if (\n      this.isSsr &&\n      as === addBasePath(this.asPath) &&\n      pathname === addBasePath(this.pathname)\n    ) {\n      return\n    }\n\n    // If the downstream application returns falsy, return.\n    // They will then be responsible for handling the event.\n    if (this._bps && !this._bps(state)) {\n      return\n    }\n\n    this.change(\n      'replaceState',\n      url,\n      as,\n      Object.assign<{}, TransitionOptions, TransitionOptions>({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale,\n        // @ts-ignore internal value not exposed on types\n        _h: 0,\n      }),\n      forcedScroll\n    )\n  }\n\n  reload(): void {\n    window.location.reload()\n  }\n\n  /**\n   * Go back in history\n   */\n  back() {\n    window.history.back()\n  }\n\n  /**\n   * Go forward in history\n   */\n  forward() {\n    window.history.forward()\n  }\n\n  /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */\n  push(url: Url, as?: Url, options: TransitionOptions = {}) {\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem(\n            '__next_scroll_' + this._key,\n            JSON.stringify({ x: self.pageXOffset, y: self.pageYOffset })\n          )\n        } catch {}\n      }\n    }\n    ;({ url, as } = prepareUrlAs(this, url, as))\n    return this.change('pushState', url, as, options)\n  }\n\n  /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */\n  replace(url: Url, as?: Url, options: TransitionOptions = {}) {\n    ;({ url, as } = prepareUrlAs(this, url, as))\n    return this.change('replaceState', url, as, options)\n  }\n\n  async _bfl(\n    as: string,\n    resolvedAs?: string,\n    locale?: string | false,\n    skipNavigate?: boolean\n  ) {\n    if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {\n      if (!this._bfl_s && !this._bfl_d) {\n        const { BloomFilter } =\n          require('../../lib/bloom-filter') as typeof import('../../lib/bloom-filter')\n\n        type Filter = ReturnType<\n          import('../../lib/bloom-filter').BloomFilter['export']\n        >\n        let staticFilterData: Filter | undefined\n        let dynamicFilterData: Filter | undefined\n\n        try {\n          ;({\n            __routerFilterStatic: staticFilterData,\n            __routerFilterDynamic: dynamicFilterData,\n          } = (await getClientBuildManifest()) as any as {\n            __routerFilterStatic?: Filter\n            __routerFilterDynamic?: Filter\n          })\n        } catch (err) {\n          // failed to load build manifest hard navigate\n          // to be safe\n          console.error(err)\n          if (skipNavigate) {\n            return true\n          }\n          handleHardNavigation({\n            url: addBasePath(\n              addLocale(as, locale || this.locale, this.defaultLocale)\n            ),\n            router: this,\n          })\n          return new Promise(() => {})\n        }\n\n        const routerFilterSValue: Filter | false = process.env\n          .__NEXT_CLIENT_ROUTER_S_FILTER as any\n\n        if (!staticFilterData && routerFilterSValue) {\n          staticFilterData = routerFilterSValue ? routerFilterSValue : undefined\n        }\n\n        const routerFilterDValue: Filter | false = process.env\n          .__NEXT_CLIENT_ROUTER_D_FILTER as any\n\n        if (!dynamicFilterData && routerFilterDValue) {\n          dynamicFilterData = routerFilterDValue\n            ? routerFilterDValue\n            : undefined\n        }\n\n        if (staticFilterData?.numHashes) {\n          this._bfl_s = new BloomFilter(\n            staticFilterData.numItems,\n            staticFilterData.errorRate\n          )\n          this._bfl_s.import(staticFilterData)\n        }\n\n        if (dynamicFilterData?.numHashes) {\n          this._bfl_d = new BloomFilter(\n            dynamicFilterData.numItems,\n            dynamicFilterData.errorRate\n          )\n          this._bfl_d.import(dynamicFilterData)\n        }\n      }\n\n      let matchesBflStatic = false\n      let matchesBflDynamic = false\n      const pathsToCheck: Array<{ as?: string; allowMatchCurrent?: boolean }> =\n        [{ as }, { as: resolvedAs }]\n\n      for (const { as: curAs, allowMatchCurrent } of pathsToCheck) {\n        if (curAs) {\n          const asNoSlash = removeTrailingSlash(\n            new URL(curAs, 'http://n').pathname\n          )\n          const asNoSlashLocale = addBasePath(\n            addLocale(asNoSlash, locale || this.locale)\n          )\n\n          if (\n            allowMatchCurrent ||\n            asNoSlash !==\n              removeTrailingSlash(new URL(this.asPath, 'http://n').pathname)\n          ) {\n            matchesBflStatic =\n              matchesBflStatic ||\n              !!this._bfl_s?.contains(asNoSlash) ||\n              !!this._bfl_s?.contains(asNoSlashLocale)\n\n            for (const normalizedAS of [asNoSlash, asNoSlashLocale]) {\n              // if any sub-path of as matches a dynamic filter path\n              // it should be hard navigated\n              const curAsParts = normalizedAS.split('/')\n              for (\n                let i = 0;\n                !matchesBflDynamic && i < curAsParts.length + 1;\n                i++\n              ) {\n                const currentPart = curAsParts.slice(0, i).join('/')\n                if (currentPart && this._bfl_d?.contains(currentPart)) {\n                  matchesBflDynamic = true\n                  break\n                }\n              }\n            }\n\n            // if the client router filter is matched then we trigger\n            // a hard navigation\n            if (matchesBflStatic || matchesBflDynamic) {\n              if (skipNavigate) {\n                return true\n              }\n              handleHardNavigation({\n                url: addBasePath(\n                  addLocale(as, locale || this.locale, this.defaultLocale)\n                ),\n                router: this,\n              })\n              return new Promise(() => {})\n            }\n          }\n        }\n      }\n    }\n    return false\n  }\n\n  private async change(\n    method: HistoryMethod,\n    url: string,\n    as: string,\n    options: TransitionOptions,\n    forcedScroll?: { x: number; y: number }\n  ): Promise<boolean> {\n    if (!isLocalURL(url)) {\n      handleHardNavigation({ url, router: this })\n      return false\n    }\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n    const isQueryUpdating = (options as any)._h === 1\n\n    if (!isQueryUpdating && !options.shallow) {\n      await this._bfl(as, undefined, options.locale)\n    }\n\n    let shouldResolveHref =\n      isQueryUpdating ||\n      (options as any)._shouldResolveHref ||\n      parsePath(url).pathname === parsePath(as).pathname\n\n    const nextState = {\n      ...this.state,\n    }\n\n    // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n    // or a navigation has occurred\n    const readyStateChange = this.isReady !== true\n    this.isReady = true\n    const isSsr = this.isSsr\n\n    if (!isQueryUpdating) {\n      this.isSsr = false\n    }\n\n    // if a route transition is already in progress before\n    // the query updating is triggered ignore query updating\n    if (isQueryUpdating && this.clc) {\n      return false\n    }\n\n    const prevLocale = nextState.locale\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      nextState.locale =\n        options.locale === false\n          ? this.defaultLocale\n          : options.locale || nextState.locale\n\n      if (typeof options.locale === 'undefined') {\n        options.locale = nextState.locale\n      }\n\n      const parsedAs = parseRelativeUrl(\n        hasBasePath(as) ? removeBasePath(as) : as\n      )\n      const localePathResult = normalizeLocalePath(\n        parsedAs.pathname,\n        this.locales\n      )\n\n      if (localePathResult.detectedLocale) {\n        nextState.locale = localePathResult.detectedLocale\n        parsedAs.pathname = addBasePath(parsedAs.pathname)\n        as = formatWithValidation(parsedAs)\n        url = addBasePath(\n          normalizeLocalePath(\n            hasBasePath(url) ? removeBasePath(url) : url,\n            this.locales\n          ).pathname\n        )\n      }\n      let didNavigate = false\n\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if the locale isn't configured hard navigate to show 404 page\n        if (!this.locales?.includes(nextState.locale!)) {\n          parsedAs.pathname = addLocale(parsedAs.pathname, nextState.locale)\n          handleHardNavigation({\n            url: formatWithValidation(parsedAs),\n            router: this,\n          })\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true\n        }\n      }\n\n      const detectedDomain = detectDomainLocale(\n        this.domainLocales,\n        undefined,\n        nextState.locale\n      )\n\n      // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (\n          !didNavigate &&\n          detectedDomain &&\n          this.isLocaleDomain &&\n          self.location.hostname !== detectedDomain.domain\n        ) {\n          const asNoBasePath = removeBasePath(as)\n          handleHardNavigation({\n            url: `http${detectedDomain.http ? '' : 's'}://${\n              detectedDomain.domain\n            }${addBasePath(\n              `${\n                nextState.locale === detectedDomain.defaultLocale\n                  ? ''\n                  : `/${nextState.locale}`\n              }${asNoBasePath === '/' ? '' : asNoBasePath}` || '/'\n            )}`,\n            router: this,\n          })\n          // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n          didNavigate = true\n        }\n      }\n\n      if (didNavigate) {\n        return new Promise(() => {})\n      }\n    }\n\n    // marking route changes as a navigation start entry\n    if (ST) {\n      performance.mark('routeChange')\n    }\n\n    const { shallow = false, scroll = true } = options\n    const routeProps = { shallow }\n\n    if (this._inFlightRoute && this.clc) {\n      if (!isSsr) {\n        Router.events.emit(\n          'routeChangeError',\n          buildCancellationError(),\n          this._inFlightRoute,\n          routeProps\n        )\n      }\n      this.clc()\n      this.clc = null\n    }\n\n    as = addBasePath(\n      addLocale(\n        hasBasePath(as) ? removeBasePath(as) : as,\n        options.locale,\n        this.defaultLocale\n      )\n    )\n    const cleanedAs = removeLocale(\n      hasBasePath(as) ? removeBasePath(as) : as,\n      nextState.locale\n    )\n    this._inFlightRoute = as\n\n    const localeChange = prevLocale !== nextState.locale\n\n    // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n\n    if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs\n      Router.events.emit('hashChangeStart', as, routeProps)\n      // TODO: do we need the resolved href when only a hash change?\n      this.changeState(method, url, as, {\n        ...options,\n        scroll: false,\n      })\n      if (scroll) {\n        this.scrollToHash(cleanedAs)\n      }\n      try {\n        await this.set(nextState, this.components[nextState.route], null)\n      } catch (err) {\n        if (isError(err) && err.cancelled) {\n          Router.events.emit('routeChangeError', err, cleanedAs, routeProps)\n        }\n        throw err\n      }\n\n      Router.events.emit('hashChangeComplete', as, routeProps)\n      return true\n    }\n\n    let parsed = parseRelativeUrl(url)\n    let { pathname, query } = parsed\n\n    // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n    let pages: string[], rewrites: any\n    try {\n      ;[pages, { __rewrites: rewrites }] = await Promise.all([\n        this.pageLoader.getPageList(),\n        getClientBuildManifest(),\n        this.pageLoader.getMiddleware(),\n      ])\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      handleHardNavigation({ url: as, router: this })\n      return false\n    }\n\n    // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState'\n    }\n\n    // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n    let resolvedAs = as\n\n    // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n    pathname = pathname\n      ? removeTrailingSlash(removeBasePath(pathname))\n      : pathname\n\n    let route = removeTrailingSlash(pathname)\n    const parsedAsPathname = as.startsWith('/') && parseRelativeUrl(as).pathname\n\n    // if we detected the path as app route during prefetching\n    // trigger hard navigation\n    if ((this.components[pathname] as any)?.__appRouter) {\n      handleHardNavigation({ url: as, router: this })\n      return new Promise(() => {})\n    }\n\n    const isMiddlewareRewrite = !!(\n      parsedAsPathname &&\n      route !== parsedAsPathname &&\n      (!isDynamicRoute(route) ||\n        !getRouteMatcher(getRouteRegex(route))(parsedAsPathname))\n    )\n\n    // we don't attempt resolve asPath when we need to execute\n    // middleware as the resolving will occur server-side\n    const isMiddlewareMatch =\n      !options.shallow &&\n      (await matchesMiddleware({\n        asPath: as,\n        locale: nextState.locale,\n        router: this,\n      }))\n\n    if (isQueryUpdating && isMiddlewareMatch) {\n      shouldResolveHref = false\n    }\n\n    if (shouldResolveHref && pathname !== '/_error') {\n      ;(options as any)._shouldResolveHref = true\n\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n        const rewritesResult = resolveRewrites(\n          addBasePath(addLocale(cleanedAs, nextState.locale), true),\n          pages,\n          rewrites,\n          query,\n          (p: string) => resolveDynamicRoute(p, pages),\n          this.locales\n        )\n\n        if (rewritesResult.externalDest) {\n          handleHardNavigation({ url: as, router: this })\n          return true\n        }\n        if (!isMiddlewareMatch) {\n          resolvedAs = rewritesResult.asPath\n        }\n\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref\n          parsed.pathname = addBasePath(pathname)\n\n          if (!isMiddlewareMatch) {\n            url = formatWithValidation(parsed)\n          }\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages)\n\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname\n          parsed.pathname = addBasePath(pathname)\n\n          if (!isMiddlewareMatch) {\n            url = formatWithValidation(parsed)\n          }\n        }\n      }\n    }\n\n    if (!isLocalURL(as)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(\n          `Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` +\n            `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`\n        )\n      }\n      handleHardNavigation({ url: as, router: this })\n      return false\n    }\n\n    resolvedAs = removeLocale(removeBasePath(resolvedAs), nextState.locale)\n\n    route = removeTrailingSlash(pathname)\n    let routeMatch: Params | false = false\n\n    if (isDynamicRoute(route)) {\n      const parsedAs = parseRelativeUrl(resolvedAs)\n      const asPathname = parsedAs.pathname\n\n      const routeRegex = getRouteRegex(route)\n      routeMatch = getRouteMatcher(routeRegex)(asPathname)\n      const shouldInterpolate = route === asPathname\n      const interpolatedAs = shouldInterpolate\n        ? interpolateAs(route, asPathname, query)\n        : ({} as { result: undefined; params: undefined })\n\n      if (!routeMatch || (shouldInterpolate && !interpolatedAs.result)) {\n        const missingParams = Object.keys(routeRegex.groups).filter(\n          (param) => !query[param] && !routeRegex.groups[param].optional\n        )\n\n        if (missingParams.length > 0 && !isMiddlewareMatch) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(\n              `${\n                shouldInterpolate\n                  ? `Interpolating href`\n                  : `Mismatching \\`as\\` and \\`href\\``\n              } failed to manually provide ` +\n                `the params: ${missingParams.join(\n                  ', '\n                )} in the \\`href\\`'s \\`query\\``\n            )\n          }\n\n          throw new Error(\n            (shouldInterpolate\n              ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(\n                  ', '\n                )}) to be interpolated properly. `\n              : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) +\n              `Read more: https://nextjs.org/docs/messages/${\n                shouldInterpolate\n                  ? 'href-interpolation-failed'\n                  : 'incompatible-href-as'\n              }`\n          )\n        }\n      } else if (shouldInterpolate) {\n        as = formatWithValidation(\n          Object.assign({}, parsedAs, {\n            pathname: interpolatedAs.result,\n            query: omit(query, interpolatedAs.params!),\n          })\n        )\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch)\n      }\n    }\n\n    if (!isQueryUpdating) {\n      Router.events.emit('routeChangeStart', as, routeProps)\n    }\n\n    const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error'\n\n    try {\n      let routeInfo = await this.getRouteInfo({\n        route,\n        pathname,\n        query,\n        as,\n        resolvedAs,\n        routeProps,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview,\n        hasMiddleware: isMiddlewareMatch,\n        unstable_skipClientCache: options.unstable_skipClientCache,\n        isQueryUpdating: isQueryUpdating && !this.isFallback,\n        isMiddlewareRewrite,\n      })\n\n      if (!isQueryUpdating && !options.shallow) {\n        await this._bfl(\n          as,\n          'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined,\n          nextState.locale\n        )\n      }\n\n      if ('route' in routeInfo && isMiddlewareMatch) {\n        pathname = routeInfo.route || route\n        route = pathname\n\n        if (!routeProps.shallow) {\n          query = Object.assign({}, routeInfo.query || {}, query)\n        }\n\n        const cleanedParsedPathname = hasBasePath(parsed.pathname)\n          ? removeBasePath(parsed.pathname)\n          : parsed.pathname\n\n        if (routeMatch && pathname !== cleanedParsedPathname) {\n          Object.keys(routeMatch).forEach((key) => {\n            if (routeMatch && query[key] === routeMatch[key]) {\n              delete query[key]\n            }\n          })\n        }\n\n        if (isDynamicRoute(pathname)) {\n          const prefixedAs =\n            !routeProps.shallow && routeInfo.resolvedAs\n              ? routeInfo.resolvedAs\n              : addBasePath(\n                  addLocale(\n                    new URL(as, location.href).pathname,\n                    nextState.locale\n                  ),\n                  true\n                )\n\n          let rewriteAs = prefixedAs\n\n          if (hasBasePath(rewriteAs)) {\n            rewriteAs = removeBasePath(rewriteAs)\n          }\n\n          if (process.env.__NEXT_I18N_SUPPORT) {\n            const localeResult = normalizeLocalePath(rewriteAs, this.locales)\n            nextState.locale = localeResult.detectedLocale || nextState.locale\n            rewriteAs = localeResult.pathname\n          }\n          const routeRegex = getRouteRegex(pathname)\n          const curRouteMatch = getRouteMatcher(routeRegex)(\n            new URL(rewriteAs, location.href).pathname\n          )\n\n          if (curRouteMatch) {\n            Object.assign(query, curRouteMatch)\n          }\n        }\n      }\n\n      // If the routeInfo brings a redirect we simply apply it.\n      if ('type' in routeInfo) {\n        if (routeInfo.type === 'redirect-internal') {\n          return this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n        } else {\n          handleHardNavigation({ url: routeInfo.destination, router: this })\n          return new Promise(() => {})\n        }\n      }\n\n      const component: any = routeInfo.Component\n      if (component && component.unstable_scriptLoader) {\n        const scripts = [].concat(component.unstable_scriptLoader())\n\n        scripts.forEach((script: any) => {\n          handleClientScriptLoad(script.props)\n        })\n      }\n\n      // handle redirect on client-transition\n      if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n        if (\n          routeInfo.props.pageProps &&\n          routeInfo.props.pageProps.__N_REDIRECT\n        ) {\n          // Use the destination from redirect without adding locale\n          options.locale = false\n\n          const destination = routeInfo.props.pageProps.__N_REDIRECT\n\n          // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n          if (\n            destination.startsWith('/') &&\n            routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false\n          ) {\n            const parsedHref = parseRelativeUrl(destination)\n            parsedHref.pathname = resolveDynamicRoute(\n              parsedHref.pathname,\n              pages\n            )\n\n            const { url: newUrl, as: newAs } = prepareUrlAs(\n              this,\n              destination,\n              destination\n            )\n            return this.change(method, newUrl, newAs, options)\n          }\n          handleHardNavigation({ url: destination, router: this })\n          return new Promise(() => {})\n        }\n\n        nextState.isPreview = !!routeInfo.props.__N_PREVIEW\n\n        // handle SSG data 404\n        if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute\n\n          try {\n            await this.fetchComponent('/404')\n            notFoundRoute = '/404'\n          } catch (_) {\n            notFoundRoute = '/_error'\n          }\n\n          routeInfo = await this.getRouteInfo({\n            route: notFoundRoute,\n            pathname: notFoundRoute,\n            query,\n            as,\n            resolvedAs,\n            routeProps: { shallow: false },\n            locale: nextState.locale,\n            isPreview: nextState.isPreview,\n            isNotFound: true,\n          })\n\n          if ('type' in routeInfo) {\n            throw new Error(`Unexpected middleware effect on /404`)\n          }\n        }\n      }\n\n      if (\n        isQueryUpdating &&\n        this.pathname === '/_error' &&\n        self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 &&\n        routeInfo.props?.pageProps\n      ) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        routeInfo.props.pageProps.statusCode = 500\n      }\n\n      // shallow routing is only allowed for same page URL changes.\n      const isValidShallowRoute =\n        options.shallow && nextState.route === (routeInfo.route ?? route)\n\n      const shouldScroll =\n        options.scroll ?? (!isQueryUpdating && !isValidShallowRoute)\n      const resetScroll = shouldScroll ? { x: 0, y: 0 } : null\n      const upcomingScrollState = forcedScroll ?? resetScroll\n\n      // the new state that the router gonna set\n      const upcomingRouterState = {\n        ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false,\n      }\n\n      // When the page being rendered is the 404 page, we should only update the\n      // query parameters. Route changes here might add the basePath when it\n      // wasn't originally present. This is also why this block is before the\n      // below `changeState` call which updates the browser's history (changing\n      // the URL).\n      if (isQueryUpdating && isErrorRoute) {\n        routeInfo = await this.getRouteInfo({\n          route: this.pathname,\n          pathname: this.pathname,\n          query,\n          as,\n          resolvedAs,\n          routeProps: { shallow: false },\n          locale: nextState.locale,\n          isPreview: nextState.isPreview,\n          isQueryUpdating: isQueryUpdating && !this.isFallback,\n        })\n\n        if ('type' in routeInfo) {\n          throw new Error(`Unexpected middleware effect on ${this.pathname}`)\n        }\n\n        if (\n          this.pathname === '/_error' &&\n          self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 &&\n          routeInfo.props?.pageProps\n        ) {\n          // ensure statusCode is still correct for static 500 page\n          // when updating query information\n          routeInfo.props.pageProps.statusCode = 500\n        }\n\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n        } catch (err) {\n          if (isError(err) && err.cancelled) {\n            Router.events.emit('routeChangeError', err, cleanedAs, routeProps)\n          }\n          throw err\n        }\n\n        return true\n      }\n\n      Router.events.emit('beforeHistoryChange', as, routeProps)\n      this.changeState(method, url, as, options)\n\n      // for query updates we can skip it if the state is unchanged and we don't\n      // need to scroll\n      // https://github.com/vercel/next.js/issues/37139\n      const canSkipUpdating =\n        isQueryUpdating &&\n        !upcomingScrollState &&\n        !readyStateChange &&\n        !localeChange &&\n        compareRouterStates(upcomingRouterState, this.state)\n\n      if (!canSkipUpdating) {\n        try {\n          await this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n        } catch (e: any) {\n          if (e.cancelled) routeInfo.error = routeInfo.error || e\n          else throw e\n        }\n\n        if (routeInfo.error) {\n          if (!isQueryUpdating) {\n            Router.events.emit(\n              'routeChangeError',\n              routeInfo.error,\n              cleanedAs,\n              routeProps\n            )\n          }\n\n          throw routeInfo.error\n        }\n\n        if (process.env.__NEXT_I18N_SUPPORT) {\n          if (nextState.locale) {\n            document.documentElement.lang = nextState.locale\n          }\n        }\n\n        if (!isQueryUpdating) {\n          Router.events.emit('routeChangeComplete', as, routeProps)\n        }\n\n        // A hash mark # is the optional last part of a URL\n        const hashRegex = /#.+$/\n        if (shouldScroll && hashRegex.test(as)) {\n          this.scrollToHash(as)\n        }\n      }\n\n      return true\n    } catch (err) {\n      if (isError(err) && err.cancelled) {\n        return false\n      }\n      throw err\n    }\n  }\n\n  changeState(\n    method: HistoryMethod,\n    url: string,\n    as: string,\n    options: TransitionOptions = {}\n  ): void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`)\n        return\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`)\n        return\n      }\n    }\n\n    if (method !== 'pushState' || getURL() !== as) {\n      this._shallow = options.shallow\n      window.history[method](\n        {\n          url,\n          as,\n          options,\n          __N: true,\n          key: (this._key = method !== 'pushState' ? this._key : createKey()),\n        } as HistoryState,\n        // Most browsers currently ignores this parameter, although they may use it in the future.\n        // Passing the empty string here should be safe against future changes to the method.\n        // https://developer.mozilla.org/docs/Web/API/History/replaceState\n        '',\n        as\n      )\n    }\n  }\n\n  async handleRouteInfoError(\n    err: Error & { code?: any; cancelled?: boolean },\n    pathname: string,\n    query: ParsedUrlQuery,\n    as: string,\n    routeProps: RouteProperties,\n    loadErrorFail?: boolean\n  ): Promise<CompletePrivateRouteInfo> {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err\n    }\n\n    if (isAssetError(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps)\n\n      // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n\n      // So, doing a hard reload is the proper way to deal with this.\n      handleHardNavigation({\n        url: as,\n        router: this,\n      })\n\n      // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n      throw buildCancellationError()\n    }\n\n    console.error(err)\n\n    try {\n      let props: Record<string, any> | undefined\n      const { page: Component, styleSheets } =\n        await this.fetchComponent('/_error')\n\n      const routeInfo: CompletePrivateRouteInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err,\n      }\n\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query,\n          } as any)\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr)\n          routeInfo.props = {}\n        }\n      }\n\n      return routeInfo\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError(\n        isError(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''),\n        pathname,\n        query,\n        as,\n        routeProps,\n        true\n      )\n    }\n  }\n\n  async getRouteInfo({\n    route: requestedRoute,\n    pathname,\n    query,\n    as,\n    resolvedAs,\n    routeProps,\n    locale,\n    hasMiddleware,\n    isPreview,\n    unstable_skipClientCache,\n    isQueryUpdating,\n    isMiddlewareRewrite,\n    isNotFound,\n  }: {\n    route: string\n    pathname: string\n    query: ParsedUrlQuery\n    as: string\n    resolvedAs: string\n    hasMiddleware?: boolean\n    routeProps: RouteProperties\n    locale: string | undefined\n    isPreview: boolean\n    unstable_skipClientCache?: boolean\n    isQueryUpdating?: boolean\n    isMiddlewareRewrite?: boolean\n    isNotFound?: boolean\n  }) {\n    /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */\n    let route = requestedRoute\n\n    try {\n      let existingInfo: PrivateRouteInfo | undefined = this.components[route]\n      if (routeProps.shallow && existingInfo && this.route === route) {\n        return existingInfo\n      }\n\n      const handleCancelled = getCancelledHandler({ route, router: this })\n\n      if (hasMiddleware) {\n        existingInfo = undefined\n      }\n\n      let cachedRouteInfo =\n        existingInfo &&\n        !('initial' in existingInfo) &&\n        process.env.NODE_ENV !== 'development'\n          ? existingInfo\n          : undefined\n\n      const isBackground = isQueryUpdating\n      const fetchNextDataParams: FetchNextDataParams = {\n        dataHref: this.pageLoader.getDataHref({\n          href: formatWithValidation({ pathname, query }),\n          skipInterpolation: true,\n          asPath: isNotFound ? '/404' : resolvedAs,\n          locale,\n        }),\n        hasMiddleware: true,\n        isServerRender: this.isSsr,\n        parseJSON: true,\n        inflightCache: isBackground ? this.sbc : this.sdc,\n        persistCache: !isPreview,\n        isPrefetch: false,\n        unstable_skipClientCache,\n        isBackground,\n      }\n\n      let data:\n        | WithMiddlewareEffectsOutput\n        | (Pick<WithMiddlewareEffectsOutput, 'json'> &\n            Omit<Partial<WithMiddlewareEffectsOutput>, 'json'>)\n        | null =\n        isQueryUpdating && !isMiddlewareRewrite\n          ? null\n          : await withMiddlewareEffects({\n              fetchData: () => fetchNextData(fetchNextDataParams),\n              asPath: isNotFound ? '/404' : resolvedAs,\n              locale: locale,\n              router: this,\n            }).catch((err) => {\n              // we don't hard error during query updating\n              // as it's un-necessary and doesn't need to be fatal\n              // unless it is a fallback route and the props can't\n              // be loaded\n              if (isQueryUpdating) {\n                return null\n              }\n              throw err\n            })\n\n      // when rendering error routes we don't apply middleware\n      // effects\n      if (data && (pathname === '/_error' || pathname === '/404')) {\n        data.effect = undefined\n      }\n\n      if (isQueryUpdating) {\n        if (!data) {\n          data = { json: self.__NEXT_DATA__.props }\n        } else {\n          data.json = self.__NEXT_DATA__.props\n        }\n      }\n\n      handleCancelled()\n\n      if (\n        data?.effect?.type === 'redirect-internal' ||\n        data?.effect?.type === 'redirect-external'\n      ) {\n        return data.effect\n      }\n\n      if (data?.effect?.type === 'rewrite') {\n        const resolvedRoute = removeTrailingSlash(data.effect.resolvedHref)\n        const pages = await this.pageLoader.getPageList()\n\n        // during query updating the page must match although during\n        // client-transition a redirect that doesn't match a page\n        // can be returned and this should trigger a hard navigation\n        // which is valid for incremental migration\n        if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n          route = resolvedRoute\n          pathname = data.effect.resolvedHref\n          query = { ...query, ...data.effect.parsedAs.query }\n          resolvedAs = removeBasePath(\n            normalizeLocalePath(data.effect.parsedAs.pathname, this.locales)\n              .pathname\n          )\n\n          // Check again the cache with the new destination.\n          existingInfo = this.components[route]\n          if (\n            routeProps.shallow &&\n            existingInfo &&\n            this.route === route &&\n            !hasMiddleware\n          ) {\n            // If we have a match with the current route due to rewrite,\n            // we can copy the existing information to the rewritten one.\n            // Then, we return the information along with the matched route.\n            return { ...existingInfo, route }\n          }\n        }\n      }\n\n      if (isAPIRoute(route)) {\n        handleHardNavigation({ url: as, router: this })\n        return new Promise<never>(() => {})\n      }\n\n      const routeInfo =\n        cachedRouteInfo ||\n        (await this.fetchComponent(route).then<CompletePrivateRouteInfo>(\n          (res) => ({\n            Component: res.page,\n            styleSheets: res.styleSheets,\n            __N_SSG: res.mod.__N_SSG,\n            __N_SSP: res.mod.__N_SSP,\n          })\n        ))\n\n      if (process.env.NODE_ENV !== 'production') {\n        const { isValidElementType } =\n          require('next/dist/compiled/react-is') as typeof import('next/dist/compiled/react-is')\n        if (!isValidElementType(routeInfo.Component)) {\n          throw new Error(\n            `The default export is not a React Component in page: \"${pathname}\"`\n          )\n        }\n      }\n      const wasBailedPrefetch = data?.response?.headers.get('x-middleware-skip')\n\n      const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP\n\n      // For non-SSG prefetches that bailed before sending data\n      // we clear the cache to fetch full response\n      if (wasBailedPrefetch && data?.dataHref) {\n        delete this.sdc[data.dataHref]\n      }\n\n      const { props, cacheKey } = await this._getData(async () => {\n        if (shouldFetchData) {\n          if (data?.json && !wasBailedPrefetch) {\n            return { cacheKey: data.cacheKey, props: data.json }\n          }\n\n          const dataHref = data?.dataHref\n            ? data.dataHref\n            : this.pageLoader.getDataHref({\n                href: formatWithValidation({ pathname, query }),\n                asPath: resolvedAs,\n                locale,\n              })\n\n          const fetched = await fetchNextData({\n            dataHref,\n            isServerRender: this.isSsr,\n            parseJSON: true,\n            inflightCache: wasBailedPrefetch ? {} : this.sdc,\n            persistCache: !isPreview,\n            isPrefetch: false,\n            unstable_skipClientCache,\n          })\n\n          return {\n            cacheKey: fetched.cacheKey,\n            props: fetched.json || {},\n          }\n        }\n\n        return {\n          headers: {},\n          props: await this.getInitialProps(\n            routeInfo.Component,\n            // we provide AppTree later so this needs to be `any`\n            {\n              pathname,\n              query,\n              asPath: as,\n              locale,\n              locales: this.locales,\n              defaultLocale: this.defaultLocale,\n            } as any\n          ),\n        }\n      })\n\n      // Only bust the data cache for SSP routes although\n      // middleware can skip cache per request with\n      // x-middleware-cache: no-cache as well\n      if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n        delete this.sdc[cacheKey]\n      }\n\n      // we kick off a HEAD request in the background\n      // when a non-prefetch request is made to signal revalidation\n      if (\n        !this.isPreview &&\n        routeInfo.__N_SSG &&\n        process.env.NODE_ENV !== 'development' &&\n        !isQueryUpdating\n      ) {\n        fetchNextData(\n          Object.assign({}, fetchNextDataParams, {\n            isBackground: true,\n            persistCache: false,\n            inflightCache: this.sbc,\n          })\n        ).catch(() => {})\n      }\n\n      props.pageProps = Object.assign({}, props.pageProps)\n      routeInfo.props = props\n      routeInfo.route = route\n      routeInfo.query = query\n      routeInfo.resolvedAs = resolvedAs\n      this.components[route] = routeInfo\n\n      return routeInfo\n    } catch (err) {\n      return this.handleRouteInfoError(\n        getProperError(err),\n        pathname,\n        query,\n        as,\n        routeProps\n      )\n    }\n  }\n\n  private set(\n    state: typeof this.state,\n    data: PrivateRouteInfo,\n    resetScroll: { x: number; y: number } | null\n  ): Promise<void> {\n    this.state = state\n\n    return this.sub(\n      data,\n      this.components['/_app'].Component as AppComponent,\n      resetScroll\n    )\n  }\n\n  /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */\n  beforePopState(cb: BeforePopStateCallback) {\n    this._bps = cb\n  }\n\n  onlyAHashChange(as: string): boolean {\n    if (!this.asPath) return false\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2)\n    const [newUrlNoHash, newHash] = as.split('#', 2)\n\n    // Makes sure we scroll to the provided hash if the url/hash are the same\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true\n    }\n\n    // If the urls are change, there's more than a hash change\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false\n    }\n\n    // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n    return oldHash !== newHash\n  }\n\n  scrollToHash(as: string): void {\n    const [, hash = ''] = as.split('#', 2)\n\n    disableSmoothScrollDuringRouteTransition(\n      () => {\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n          window.scrollTo(0, 0)\n          return\n        }\n\n        // Decode hash to make non-latin anchor works.\n        const rawHash = decodeURIComponent(hash)\n        // First we check if the element by id is found\n        const idEl = document.getElementById(rawHash)\n        if (idEl) {\n          idEl.scrollIntoView()\n          return\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(rawHash)[0]\n        if (nameEl) {\n          nameEl.scrollIntoView()\n        }\n      },\n      {\n        onlyHashChange: this.onlyAHashChange(as),\n      }\n    )\n  }\n\n  urlIsNew(asPath: string): boolean {\n    return this.asPath !== asPath\n  }\n\n  /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */\n  async prefetch(\n    url: string,\n    asPath: string = url,\n    options: PrefetchOptions = {}\n  ): Promise<void> {\n    // Prefetch is not supported in development mode because it would trigger on-demand-entries\n    if (process.env.NODE_ENV !== 'production') {\n      return\n    }\n\n    if (typeof window !== 'undefined' && isBot(window.navigator.userAgent)) {\n      // No prefetches for bots that render the link since they are typically navigating\n      // links via the equivalent of a hard navigation and hence never utilize these\n      // prefetches.\n      return\n    }\n    let parsed = parseRelativeUrl(url)\n    const urlPathname = parsed.pathname\n\n    let { pathname, query } = parsed\n    const originalPathname = pathname\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = normalizeLocalePath!(pathname, this.locales).pathname\n        parsed.pathname = pathname\n        url = formatWithValidation(parsed)\n\n        let parsedAs = parseRelativeUrl(asPath)\n        const localePathResult = normalizeLocalePath!(\n          parsedAs.pathname,\n          this.locales\n        )\n        parsedAs.pathname = localePathResult.pathname\n        options.locale = localePathResult.detectedLocale || this.defaultLocale\n        asPath = formatWithValidation(parsedAs)\n      }\n    }\n\n    const pages = await this.pageLoader.getPageList()\n    let resolvedAs = asPath\n\n    const locale =\n      typeof options.locale !== 'undefined'\n        ? options.locale || undefined\n        : this.locale\n\n    const isMiddlewareMatch = await matchesMiddleware({\n      asPath: asPath,\n      locale: locale,\n      router: this,\n    })\n\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n      let rewrites: any\n      ;({ __rewrites: rewrites } = await getClientBuildManifest())\n\n      const rewritesResult = resolveRewrites(\n        addBasePath(addLocale(asPath, this.locale), true),\n        pages,\n        rewrites,\n        parsed.query,\n        (p: string) => resolveDynamicRoute(p, pages),\n        this.locales\n      )\n\n      if (rewritesResult.externalDest) {\n        return\n      }\n\n      if (!isMiddlewareMatch) {\n        resolvedAs = removeLocale(\n          removeBasePath(rewritesResult.asPath),\n          this.locale\n        )\n      }\n\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref\n        parsed.pathname = pathname\n\n        if (!isMiddlewareMatch) {\n          url = formatWithValidation(parsed)\n        }\n      }\n    }\n    parsed.pathname = resolveDynamicRoute(parsed.pathname, pages)\n\n    if (isDynamicRoute(parsed.pathname)) {\n      pathname = parsed.pathname\n      parsed.pathname = pathname\n      Object.assign(\n        query,\n        getRouteMatcher(getRouteRegex(parsed.pathname))(\n          parsePath(asPath).pathname\n        ) || {}\n      )\n\n      if (!isMiddlewareMatch) {\n        url = formatWithValidation(parsed)\n      }\n    }\n\n    const data =\n      process.env.__NEXT_MIDDLEWARE_PREFETCH === 'strict'\n        ? null\n        : await withMiddlewareEffects({\n            fetchData: () =>\n              fetchNextData({\n                dataHref: this.pageLoader.getDataHref({\n                  href: formatWithValidation({\n                    pathname: originalPathname,\n                    query,\n                  }),\n                  skipInterpolation: true,\n                  asPath: resolvedAs,\n                  locale,\n                }),\n                hasMiddleware: true,\n                isServerRender: false,\n                parseJSON: true,\n                inflightCache: this.sdc,\n                persistCache: !this.isPreview,\n                isPrefetch: true,\n              }),\n            asPath: asPath,\n            locale: locale,\n            router: this,\n          })\n\n    /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */\n    if (data?.effect.type === 'rewrite') {\n      parsed.pathname = data.effect.resolvedHref\n      pathname = data.effect.resolvedHref\n      query = { ...query, ...data.effect.parsedAs.query }\n      resolvedAs = data.effect.parsedAs.pathname\n      url = formatWithValidation(parsed)\n    }\n\n    /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */\n    if (data?.effect.type === 'redirect-external') {\n      return\n    }\n\n    const route = removeTrailingSlash(pathname)\n\n    if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n      this.components[urlPathname] = { __appRouter: true } as any\n    }\n\n    await Promise.all([\n      this.pageLoader._isSsg(route).then((isSsg) => {\n        return isSsg\n          ? fetchNextData({\n              dataHref: data?.json\n                ? data?.dataHref\n                : this.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    locale: locale,\n                  }),\n              isServerRender: false,\n              parseJSON: true,\n              inflightCache: this.sdc,\n              persistCache: !this.isPreview,\n              isPrefetch: true,\n              unstable_skipClientCache:\n                options.unstable_skipClientCache ||\n                (options.priority &&\n                  !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE),\n            })\n              .then(() => false)\n              .catch(() => false)\n          : false\n      }),\n      this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route),\n    ])\n  }\n\n  async fetchComponent(route: string) {\n    const handleCancelled = getCancelledHandler({ route, router: this })\n\n    try {\n      const componentResult = await this.pageLoader.loadPage(route)\n      handleCancelled()\n\n      return componentResult\n    } catch (err) {\n      handleCancelled()\n      throw err\n    }\n  }\n\n  _getData<T>(fn: () => Promise<T>): Promise<T> {\n    let cancelled = false\n    const cancel = () => {\n      cancelled = true\n    }\n    this.clc = cancel\n    return fn().then((data) => {\n      if (cancel === this.clc) {\n        this.clc = null\n      }\n\n      if (cancelled) {\n        const err: any = new Error('Loading initial props cancelled')\n        err.cancelled = true\n        throw err\n      }\n\n      return data\n    })\n  }\n\n  getInitialProps(\n    Component: ComponentType,\n    ctx: NextPageContext\n  ): Promise<Record<string, any>> {\n    const { Component: App } = this.components['/_app']\n    const AppTree = this._wrapApp(App as AppComponent)\n    ctx.AppTree = AppTree\n    return loadGetInitialProps<AppContextType<Router>>(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx,\n    })\n  }\n\n  get route(): string {\n    return this.state.route\n  }\n\n  get pathname(): string {\n    return this.state.pathname\n  }\n\n  get query(): ParsedUrlQuery {\n    return this.state.query\n  }\n\n  get asPath(): string {\n    return this.state.asPath\n  }\n\n  get locale(): string | undefined {\n    return this.state.locale\n  }\n\n  get isFallback(): boolean {\n    return this.state.isFallback\n  }\n\n  get isPreview(): boolean {\n    return this.state.isPreview\n  }\n}\n"],"names":["resolveRewrites","createKey","Router","matchesMiddleware","buildCancellationError","Object","assign","cancelled","options","asPathname","parsePath","Promise","resolve","router","pageLoader","getMiddleware","matchers","asPath","pathname","cleanedAs","hasBasePath","removeBasePath","asWithBasePathAndLocale","addBasePath","addLocale","locale","some","m","RegExp","regexp","test","stripOrigin","url","origin","getLocationOrigin","startsWith","substring","length","prepareUrlAs","as","resolveHref","resolvedHref","resolvedAs","hrefWasAbsolute","asWasAbsolute","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","removeTrailingSlash","denormalizePagePath","includes","page","isDynamicRoute","getRouteRegex","re","withMiddlewareEffects","effect","fetchData","getMiddlewareData","source","response","nextConfig","basePath","i18n","locales","trailingSlash","Boolean","rewriteHeader","headers","get","rewriteTarget","matchedPath","MATCHED_PATH_HEADER","process","parsedRewriteTarget","parseRelativeUrl","pathnameInfo","getNextPathnameInfo","parseData","fsPathname","all","getPageList","getClientBuildManifest","then","__rewrites","rewrites","normalizeLocalePath","parsedSource","undefined","resolvedPathname","matches","getRouteMatcher","query","type","parsedAs","src","destination","formatNextPathnameInfo","defaultLocale","buildId","hash","redirectTarget","newAs","newUrl","data","dataHref","json","text","cacheKey","manualScrollRestoration","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","tryToParseAsJSON","JSON","parse","error","fetchNextData","inflightCache","isPrefetch","hasMiddleware","isServerRender","parseJSON","persistCache","isBackground","unstable_skipClientCache","URL","location","href","getData","params","fetchRetry","attempts","fetch","credentials","method","ok","status","purpose","notFound","markAssetError","env","NODE_ENV","catch","err","message","Math","random","toString","slice","handleHardNavigation","getCancelledHandler","route","cancel","clc","handleCancelled","initialProps","App","wrapApp","Component","subscription","isFallback","domainLocales","isPreview","sdc","sbc","isFirstPopStateEvent","_key","onPopState","e","forcedScroll","state","changeState","formatWithValidation","getURL","__NA","reload","__N","key","stringify","x","self","pageXOffset","y","pageYOffset","getItem","isSsr","_bps","change","shallow","_shallow","_h","components","initial","props","__N_SSG","__N_SSP","styleSheets","events","autoExportDynamic","__NEXT_DATA__","autoExport","_wrapApp","isLocaleDomain","isReady","gssp","gip","isExperimentalCompile","appGip","gsp","search","__NEXT_HAS_REWRITES","_initialMatchesMiddlewarePromise","_shouldResolveHref","addEventListener","scrollRestoration","back","forward","push","replace","_bfl","skipNavigate","staticFilterData","dynamicFilterData","matchesBflStatic","matchesBflDynamic","pathsToCheck","curAs","allowMatchCurrent","curAsParts","i","normalizedAS","_bfl_s","_bfl_d","require","__routerFilterStatic","__routerFilterDynamic","numHashes","BloomFilter","numItems","errorRate","import","asNoSlashLocale","asNoSlash","contains","split","currentPart","join","isQueryUpdating","shouldResolveHref","nextState","readyStateChange","detectedDomain","scroll","localeChange","parsedAsPathname","isMiddlewareRewrite","isMiddlewareMatch","rewritesResult","routeRegex","interpolatedAs","missingParams","isErrorRoute","routeInfo","cleanedParsedPathname","rewriteAs","curRouteMatch","component","localeResult","parsedHref","scripts","shouldScroll","_","upcomingRouterState","canSkipUpdating","isLocalURL","prevLocale","ST","mark","routeProps","_inFlightRoute","emit","removeLocale","onlyAHashChange","set","isError","parsed","urlIsNew","__appRouter","routeMatch","shouldInterpolate","interpolateAs","result","omit","keys","groups","filter","param","optional","getRouteInfo","forEach","prefixedAs","unstable_scriptLoader","concat","script","handleClientScriptLoad","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","__N_PREVIEW","fetchComponent","notFoundRoute","isNotFound","statusCode","isValidShallowRoute","upcomingScrollState","resetScroll","compareRouterStates","hashRegex","scrollToHash","handleRouteInfoError","loadErrorFail","isAssetError","getInitialProps","routeInfoErr","requestedRoute","fetchNextDataParams","wasBailedPrefetch","shouldFetchData","existingInfo","cachedRouteInfo","getDataHref","skipInterpolation","resolvedRoute","isAPIRoute","res","mod","_getData","fetched","getProperError","sub","cb","oldUrlNoHash","oldHash","newUrlNoHash","newHash","disableSmoothScrollDuringRouteTransition","scrollTo","rawHash","decodeURIComponent","idEl","document","getElementById","scrollIntoView","nameEl","getElementsByName","onlyHashChange","prefetch","localePathResult","isBot","navigator","userAgent","urlPathname","p","externalDest","matchedPage","originalPathname","_isSsg","isSsg","priority","loadPage","componentResult","fn","ctx","AppTree","loadGetInitialProps","mitt"],"sourceRoot":"","ignoreList":[]}