{"version":3,"file":"static/chunks/207-7b78ac4aa31e0a9d.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/fill-cache-with-new-subtree-data.ts","webpack://_N_E/../../../../src/client/components/router-reducer/fill-lazy-items-till-leaf-with-head.ts","webpack://_N_E/../../../../src/client/components/router-reducer/apply-router-state-patch-to-tree.ts","webpack://_N_E/../../../../src/client/components/router-reducer/handle-mutable.ts","webpack://_N_E/../../../../src/client/components/router-reducer/clear-cache-node-data-for-segment-path.ts","webpack://_N_E/../../../../src/client/components/router-reducer/create-initial-router-state.ts","webpack://_N_E/../../../../src/client/components/router-reducer/fetch-server-response.ts","webpack://_N_E/../../../../src/client/components/router-reducer/invalidate-cache-by-router-state.ts","webpack://_N_E/../../../../src/client/components/router-reducer/is-navigating-to-new-root-layout.ts","webpack://_N_E/../../../../src/client/components/router-reducer/invalidate-cache-below-flight-segmentpath.ts","webpack://_N_E/../../../../src/client/components/router-reducer/compute-changed-path.ts","webpack://_N_E/../../../../src/client/components/router-reducer/handle-segment-mismatch.ts","webpack://_N_E/../../../../src/client/components/router-reducer/apply-flight-data.ts","webpack://_N_E/../../../src/client/components/render-from-template-context.tsx","webpack://_N_E/../../../../src/client/components/router-reducer/create-router-cache-key.ts","webpack://_N_E/../../../../src/client/components/router-reducer/aliased-prefetch-navigations.ts","webpack://_N_E/../../../../src/client/components/router-reducer/create-href-from-url.ts"],"sourcesContent":["import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { Segment } from '../../../server/app-render/types'\nimport { invalidateCacheByRouterState } from './invalidate-cache-by-router-state'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\n/**\n * Common logic for filling cache with new sub tree data.\n */\nfunction fillCacheHelper(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry: PrefetchCacheEntry | undefined,\n  fillLazyItems: boolean\n): void {\n  const {\n    segmentPath,\n    seedData: cacheNodeSeedData,\n    tree: treePatch,\n    head,\n  } = flightData\n  let newCacheNode = newCache\n  let existingCacheNode = existingCache\n\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n\n    // segmentPath is a repeating tuple of parallelRouteKey and segment\n    // we know we've hit the last entry we've reached our final pair\n    const isLastEntry = i === segmentPath.length - 2\n    const cacheKey = createRouterCacheKey(segment)\n\n    const existingChildSegmentMap =\n      existingCacheNode.parallelRoutes.get(parallelRouteKey)\n\n    if (!existingChildSegmentMap) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    let childSegmentMap = newCacheNode.parallelRoutes.get(parallelRouteKey)\n    if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n      childSegmentMap = new Map(existingChildSegmentMap)\n      newCacheNode.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n    }\n\n    const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n    let childCacheNode = childSegmentMap.get(cacheKey)\n\n    if (isLastEntry) {\n      if (\n        cacheNodeSeedData &&\n        (!childCacheNode ||\n          !childCacheNode.lazyData ||\n          childCacheNode === existingChildCacheNode)\n      ) {\n        const incomingSegment = cacheNodeSeedData[0]\n        const rsc = cacheNodeSeedData[1]\n        const loading = cacheNodeSeedData[3]\n\n        childCacheNode = {\n          lazyData: null,\n          // When `fillLazyItems` is false, we only want to fill the RSC data for the layout,\n          // not the page segment.\n          rsc:\n            fillLazyItems || incomingSegment !== PAGE_SEGMENT_KEY ? rsc : null,\n          prefetchRsc: null,\n          head: null,\n          prefetchHead: null,\n          loading,\n          parallelRoutes:\n            fillLazyItems && existingChildCacheNode\n              ? new Map(existingChildCacheNode.parallelRoutes)\n              : new Map(),\n          navigatedAt,\n        }\n\n        if (existingChildCacheNode && fillLazyItems) {\n          invalidateCacheByRouterState(\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch\n          )\n        }\n        if (fillLazyItems) {\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            childCacheNode,\n            existingChildCacheNode,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            prefetchEntry\n          )\n        }\n\n        childSegmentMap.set(cacheKey, childCacheNode)\n      }\n      continue\n    }\n\n    if (!childCacheNode || !existingChildCacheNode) {\n      // Bailout because the existing cache does not have the path to the leaf node\n      // Will trigger lazy fetch in layout-router because of missing segment\n      continue\n    }\n\n    if (childCacheNode === existingChildCacheNode) {\n      childCacheNode = {\n        lazyData: childCacheNode.lazyData,\n        rsc: childCacheNode.rsc,\n        prefetchRsc: childCacheNode.prefetchRsc,\n        head: childCacheNode.head,\n        prefetchHead: childCacheNode.prefetchHead,\n        parallelRoutes: new Map(childCacheNode.parallelRoutes),\n        loading: childCacheNode.loading,\n      } as CacheNode\n      childSegmentMap.set(cacheKey, childCacheNode)\n    }\n\n    // Move deeper into the cache nodes\n    newCacheNode = childCacheNode\n    existingCacheNode = existingChildCacheNode\n  }\n}\n\n/**\n * Fill cache with rsc based on flightDataPath\n */\nexport function fillCacheWithNewSubTreeData(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(\n    navigatedAt,\n    newCache,\n    existingCache,\n    flightData,\n    prefetchEntry,\n    true\n  )\n}\n\nexport function fillCacheWithNewSubTreeDataButOnlyLoading(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): void {\n  fillCacheHelper(\n    navigatedAt,\n    newCache,\n    existingCache,\n    flightData,\n    prefetchEntry,\n    false\n  )\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  CacheNodeSeedData,\n} from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n} from './router-reducer-types'\n\nexport function fillLazyItemsTillLeafWithHead(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode | undefined,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null,\n  head: React.ReactNode,\n  prefetchEntry: PrefetchCacheEntry | undefined\n): void {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    newCache.head = head\n    return\n  }\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    // TODO: We should traverse the cacheNodeSeedData tree instead of the router\n    // state tree. Ideally, they would always be the same shape, but because of\n    // the loading.js pattern, cacheNodeSeedData sometimes only represents a\n    // partial tree. That's why this node is sometimes null. Once PPR lands,\n    // loading.js will no longer have special behavior and we can traverse the\n    // data tree instead.\n    //\n    // We should also consider merging the router state tree and the data tree\n    // in the response format, so that we don't have to send the keys twice.\n    // Then the client can convert them into separate representations.\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n    if (existingCache) {\n      const existingParallelRoutesCacheNode =\n        existingCache.parallelRoutes.get(key)\n      if (existingParallelRoutesCacheNode) {\n        const hasReusablePrefetch =\n          prefetchEntry?.kind === 'auto' &&\n          prefetchEntry.status === PrefetchCacheEntryStatus.reusable\n\n        let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n        const existingCacheNode = parallelRouteCacheNode.get(cacheKey)\n        let newCacheNode: CacheNode\n        if (parallelSeedData !== null) {\n          // New data was sent from the server.\n          const seedNode = parallelSeedData[1]\n          const loading = parallelSeedData[3]\n          newCacheNode = {\n            lazyData: null,\n            rsc: seedNode,\n            // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n            // this path during a navigation, but until PPR is fully implemented\n            // yet it's possible the existing node does have a non-null\n            // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n            // old behavior â€” no PPR value.\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            loading,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            navigatedAt,\n          }\n        } else if (hasReusablePrefetch && existingCacheNode) {\n          // No new data was sent from the server, but the existing cache node\n          // was prefetched, so we should reuse that.\n          newCacheNode = {\n            lazyData: existingCacheNode.lazyData,\n            rsc: existingCacheNode.rsc,\n            // This is a PPR-only field. Unlike the previous branch, since we're\n            // just cloning the existing cache node, we might as well keep the\n            // PPR value, if it exists.\n            prefetchRsc: existingCacheNode.prefetchRsc,\n            head: existingCacheNode.head,\n            prefetchHead: existingCacheNode.prefetchHead,\n            parallelRoutes: new Map(existingCacheNode.parallelRoutes),\n            loading: existingCacheNode.loading,\n          } as CacheNode\n        } else {\n          // No data available for this node. This will trigger a lazy fetch\n          // during render.\n          newCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            prefetchHead: null,\n            parallelRoutes: new Map(existingCacheNode?.parallelRoutes),\n            loading: null,\n            navigatedAt,\n          }\n        }\n\n        // Overrides the cache key with the new cache node.\n        parallelRouteCacheNode.set(cacheKey, newCacheNode)\n        // Traverse deeper to apply the head / fill lazy items till the head.\n        fillLazyItemsTillLeafWithHead(\n          navigatedAt,\n          newCacheNode,\n          existingCacheNode,\n          parallelRouteState,\n          parallelSeedData ? parallelSeedData : null,\n          head,\n          prefetchEntry\n        )\n\n        newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n        continue\n      }\n    }\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const seedNode = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        rsc: seedNode,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      newCacheNode,\n      undefined,\n      parallelRouteState,\n      parallelSeedData,\n      head,\n      prefetchEntry\n    )\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n\n/**\n * Deep merge of the two router states. Parallel route keys are preserved if the patch doesn't have them.\n */\nfunction applyPatch(\n  initialTree: FlightRouterState,\n  patchTree: FlightRouterState\n): FlightRouterState {\n  const [initialSegment, initialParallelRoutes] = initialTree\n  const [patchSegment, patchParallelRoutes] = patchTree\n\n  // if the applied patch segment is __DEFAULT__ then it can be ignored in favor of the initial tree\n  // this is because the __DEFAULT__ segment is used as a placeholder on navigation\n  if (\n    patchSegment === DEFAULT_SEGMENT_KEY &&\n    initialSegment !== DEFAULT_SEGMENT_KEY\n  ) {\n    return initialTree\n  }\n\n  if (matchSegment(initialSegment, patchSegment)) {\n    const newParallelRoutes: FlightRouterState[1] = {}\n    for (const key in initialParallelRoutes) {\n      const isInPatchTreeParallelRoutes =\n        typeof patchParallelRoutes[key] !== 'undefined'\n      if (isInPatchTreeParallelRoutes) {\n        newParallelRoutes[key] = applyPatch(\n          initialParallelRoutes[key],\n          patchParallelRoutes[key]\n        )\n      } else {\n        newParallelRoutes[key] = initialParallelRoutes[key]\n      }\n    }\n\n    for (const key in patchParallelRoutes) {\n      if (newParallelRoutes[key]) {\n        continue\n      }\n\n      newParallelRoutes[key] = patchParallelRoutes[key]\n    }\n\n    const tree: FlightRouterState = [initialSegment, newParallelRoutes]\n\n    // Copy over the existing tree\n    if (initialTree[2]) {\n      tree[2] = initialTree[2]\n    }\n\n    if (initialTree[3]) {\n      tree[3] = initialTree[3]\n    }\n\n    if (initialTree[4]) {\n      tree[4] = initialTree[4]\n    }\n\n    return tree\n  }\n\n  return patchTree\n}\n\n/**\n * Apply the router state from the Flight response, but skip patching default segments.\n * Useful for patching the router cache when navigating, where we persist the existing default segment if there isn't a new one.\n * Creates a new router state tree.\n */\nexport function applyRouterStatePatchToTree(\n  flightSegmentPath: FlightSegmentPath,\n  flightRouterState: FlightRouterState,\n  treePatch: FlightRouterState,\n  path: string\n): FlightRouterState | null {\n  const [segment, parallelRoutes, url, refetch, isRootLayout] =\n    flightRouterState\n\n  // Root refresh\n  if (flightSegmentPath.length === 1) {\n    const tree: FlightRouterState = applyPatch(flightRouterState, treePatch)\n\n    addRefreshMarkerToActiveParallelSegments(tree, path)\n\n    return tree\n  }\n\n  const [currentSegment, parallelRouteKey] = flightSegmentPath\n\n  // Tree path returned from the server should always match up with the current tree in the browser\n  if (!matchSegment(currentSegment, segment)) {\n    return null\n  }\n\n  const lastSegment = flightSegmentPath.length === 2\n\n  let parallelRoutePatch\n  if (lastSegment) {\n    parallelRoutePatch = applyPatch(parallelRoutes[parallelRouteKey], treePatch)\n  } else {\n    parallelRoutePatch = applyRouterStatePatchToTree(\n      getNextFlightSegmentPath(flightSegmentPath),\n      parallelRoutes[parallelRouteKey],\n      treePatch,\n      path\n    )\n\n    if (parallelRoutePatch === null) {\n      return null\n    }\n  }\n\n  const tree: FlightRouterState = [\n    flightSegmentPath[0],\n    {\n      ...parallelRoutes,\n      [parallelRouteKey]: parallelRoutePatch,\n    },\n    url,\n    refetch,\n  ]\n\n  // Current segment is the root layout\n  if (isRootLayout) {\n    tree[4] = true\n  }\n\n  addRefreshMarkerToActiveParallelSegments(tree, path)\n\n  return tree\n}\n","import { computeChangedPath } from './compute-changed-path'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n} from './router-reducer-types'\n\nfunction isNotUndefined<T>(value: T): value is Exclude<T, undefined> {\n  return typeof value !== 'undefined'\n}\n\nexport function handleMutable(\n  state: ReadonlyReducerState,\n  mutable: Mutable\n): ReducerState {\n  // shouldScroll is true by default, can override to false.\n  const shouldScroll = mutable.shouldScroll ?? true\n\n  let nextUrl = state.nextUrl\n\n  if (isNotUndefined(mutable.patchedTree)) {\n    // If we received a patched tree, we need to compute the changed path.\n    const changedPath = computeChangedPath(state.tree, mutable.patchedTree)\n    if (changedPath) {\n      // If the tree changed, we need to update the nextUrl\n      nextUrl = changedPath\n    } else if (!nextUrl) {\n      // if the tree ends up being the same (ie, no changed path), and we don't have a nextUrl, then we should use the canonicalUrl\n      nextUrl = state.canonicalUrl\n    }\n    // otherwise this will be a no-op and continue to use the existing nextUrl\n  }\n\n  return {\n    // Set href.\n    canonicalUrl: isNotUndefined(mutable.canonicalUrl)\n      ? mutable.canonicalUrl === state.canonicalUrl\n        ? state.canonicalUrl\n        : mutable.canonicalUrl\n      : state.canonicalUrl,\n    pushRef: {\n      pendingPush: isNotUndefined(mutable.pendingPush)\n        ? mutable.pendingPush\n        : state.pushRef.pendingPush,\n      mpaNavigation: isNotUndefined(mutable.mpaNavigation)\n        ? mutable.mpaNavigation\n        : state.pushRef.mpaNavigation,\n      preserveCustomHistoryState: isNotUndefined(\n        mutable.preserveCustomHistoryState\n      )\n        ? mutable.preserveCustomHistoryState\n        : state.pushRef.preserveCustomHistoryState,\n    },\n    // All navigation requires scroll and focus management to trigger.\n    focusAndScrollRef: {\n      apply: shouldScroll\n        ? isNotUndefined(mutable?.scrollableSegments)\n          ? true\n          : state.focusAndScrollRef.apply\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          false,\n      onlyHashChange: mutable.onlyHashChange || false,\n      hashFragment: shouldScroll\n        ? // Empty hash should trigger default behavior of scrolling layout into view.\n          // #top is handled in layout-router.\n          mutable.hashFragment && mutable.hashFragment !== ''\n          ? // Remove leading # and decode hash to make non-latin hashes work.\n            decodeURIComponent(mutable.hashFragment.slice(1))\n          : state.focusAndScrollRef.hashFragment\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          null,\n      segmentPaths: shouldScroll\n        ? mutable?.scrollableSegments ?? state.focusAndScrollRef.segmentPaths\n        : // If shouldScroll is false then we should not apply scroll and focus management.\n          [],\n    },\n    // Apply cache.\n    cache: mutable.cache ? mutable.cache : state.cache,\n    prefetchCache: mutable.prefetchCache\n      ? mutable.prefetchCache\n      : state.prefetchCache,\n    // Apply patched router state.\n    tree: isNotUndefined(mutable.patchedTree)\n      ? mutable.patchedTree\n      : state.tree,\n    nextUrl,\n  }\n}\n","import type { FlightSegmentPath } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * This will clear the CacheNode data for a particular segment path. This will cause a lazy-fetch in layout router to fill in new data.\n */\nexport function clearCacheNodeDataForSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n\n  const [parallelRouteKey, segment] = flightSegmentPath\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap?.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  // In case of last segment start off the fetch at this level and don't copy further down.\n  if (isLastEntry) {\n    if (\n      !childCacheNode ||\n      !childCacheNode.lazyData ||\n      childCacheNode === existingChildCacheNode\n    ) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      })\n    }\n    return\n  }\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Start fetch in the place where the existing cache doesn't have the data yet.\n    if (!childCacheNode) {\n      childSegmentMap.set(cacheKey, {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      })\n    }\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n      loading: childCacheNode.loading,\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  return clearCacheNodeDataForSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightDataPath } from '../../../server/app-render/types'\n\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { extractPathFromFlightRouterState } from './compute-changed-path'\nimport {\n  createSeededPrefetchCacheEntry,\n  STATIC_STALETIME_MS,\n} from './prefetch-cache-utils'\nimport { PrefetchKind, type PrefetchCacheEntry } from './router-reducer-types'\nimport { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\nimport { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n\nexport interface InitialRouterStateParameters {\n  navigatedAt: number\n  initialCanonicalUrlParts: string[]\n  initialParallelRoutes: CacheNode['parallelRoutes']\n  initialFlightData: FlightDataPath[]\n  location: Location | null\n  couldBeIntercepted: boolean\n  postponed: boolean\n  prerendered: boolean\n}\n\nexport function createInitialRouterState({\n  navigatedAt,\n  initialFlightData,\n  initialCanonicalUrlParts,\n  initialParallelRoutes,\n  location,\n  couldBeIntercepted,\n  postponed,\n  prerendered,\n}: InitialRouterStateParameters) {\n  // When initialized on the server, the canonical URL is provided as an array of parts.\n  // This is to ensure that when the RSC payload streamed to the client, crawlers don't interpret it\n  // as a URL that should be crawled.\n  const initialCanonicalUrl = initialCanonicalUrlParts.join('/')\n\n  const normalizedFlightData = getFlightDataPartsFromPath(initialFlightData[0])\n  const {\n    tree: initialTree,\n    seedData: initialSeedData,\n    head: initialHead,\n  } = normalizedFlightData\n  // For the SSR render, seed data should always be available (we only send back a `null` response\n  // in the case of a `loading` segment, pre-PPR.)\n  const rsc = initialSeedData?.[1]\n  const loading = initialSeedData?.[3] ?? null\n\n  const cache: CacheNode = {\n    lazyData: null,\n    rsc,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    // The cache gets seeded during the first render. `initialParallelRoutes` ensures the cache from the first render is there during the second render.\n    parallelRoutes: initialParallelRoutes,\n    loading,\n    navigatedAt,\n  }\n\n  const canonicalUrl =\n    // location.href is read as the initial value for canonicalUrl in the browser\n    // This is safe to do as canonicalUrl can't be rendered, it's only used to control the history updates in the useEffect further down in this file.\n    location\n      ? // window.location does not have the same type as URL but has all the fields createHrefFromUrl needs.\n        createHrefFromUrl(location)\n      : initialCanonicalUrl\n\n  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n\n  const prefetchCache = new Map<string, PrefetchCacheEntry>()\n\n  // When the cache hasn't been seeded yet we fill the cache with the head.\n  if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      undefined,\n      initialTree,\n      initialSeedData,\n      initialHead,\n      undefined\n    )\n  }\n\n  const initialState = {\n    tree: initialTree,\n    cache,\n    prefetchCache,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // First render needs to preserve the previous window.history.state\n      // to avoid it being overwritten on navigation back/forward with MPA Navigation.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: {\n      apply: false,\n      onlyHashChange: false,\n      hashFragment: null,\n      segmentPaths: [],\n    },\n    canonicalUrl,\n    nextUrl:\n      // the || operator is intentional, the pathname can be an empty string\n      (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n      null,\n  }\n\n  if (process.env.NODE_ENV !== 'development' && location) {\n    // Seed the prefetch cache with this page's data.\n    // This is to prevent needlessly re-prefetching a page that is already reusable,\n    // and will avoid triggering a loading state/data fetch stall when navigating back to the page.\n    // We don't currently do this in development because links aren't prefetched in development\n    // so having a mismatch between prefetch/no prefetch provides inconsistent behavior based on which page\n    // was loaded first.\n    const url = new URL(\n      `${location.pathname}${location.search}`,\n      location.origin\n    )\n\n    createSeededPrefetchCacheEntry({\n      url,\n      data: {\n        flightData: [normalizedFlightData],\n        canonicalUrl: undefined,\n        couldBeIntercepted: !!couldBeIntercepted,\n        prerendered,\n        postponed,\n        // TODO: The initial RSC payload includes both static and dynamic data\n        // in the same response, even if PPR is enabled. So if there's any\n        // dynamic data at all, we can't set a stale time. In the future we may\n        // add a way to split a single Flight stream into static and dynamic\n        // parts. But in the meantime we should at least make this work for\n        // fully static pages.\n        staleTime:\n          // In the old router, there was only a single configurable staleTime (experimental.staleTimes)\n          // As an abundance of caution, this will only set the initial staleTime to the configured value\n          // if we're not leveraging the segment cache, which has its own prefetching semantics.\n          prerendered && !process.env.__NEXT_CLIENT_SEGMENT_CACHE\n            ? STATIC_STALETIME_MS\n            : -1,\n      },\n      tree: initialState.tree,\n      prefetchCache: initialState.prefetchCache,\n      nextUrl: initialState.nextUrl,\n      kind: prerendered ? PrefetchKind.FULL : PrefetchKind.AUTO,\n    })\n  }\n\n  return initialState\n}\n","'use client'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\n\nimport type {\n  FlightRouterState,\n  NavigationFlightResponse,\n} from '../../../server/app-render/types'\n\nimport type { NEXT_ROUTER_SEGMENT_PREFETCH_HEADER } from '../app-router-headers'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_RSC_UNION_QUERY,\n  NEXT_URL,\n  RSC_HEADER,\n  RSC_CONTENT_TYPE_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_DID_POSTPONE_HEADER,\n  NEXT_ROUTER_STALE_TIME_HEADER,\n} from '../app-router-headers'\nimport { callServer } from '../../app-call-server'\nimport { findSourceMapURL } from '../../app-find-source-map-url'\nimport { PrefetchKind } from './router-reducer-types'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../flight-data-helpers'\nimport { getAppBuildId } from '../../app-build-id'\nimport { setCacheBustingSearchParam } from './set-cache-busting-search-param'\nimport { urlToUrlWithoutFlightMarker } from '../../route-params'\n\nconst createFromReadableStream =\n  createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n\nexport interface FetchServerResponseOptions {\n  readonly flightRouterState: FlightRouterState\n  readonly nextUrl: string | null\n  readonly prefetchKind?: PrefetchKind\n  readonly isHmrRefresh?: boolean\n}\n\nexport type FetchServerResponseResult = {\n  flightData: NormalizedFlightData[] | string\n  canonicalUrl: URL | undefined\n  couldBeIntercepted: boolean\n  prerendered: boolean\n  postponed: boolean\n  staleTime: number\n}\n\nexport type RequestHeaders = {\n  [RSC_HEADER]?: '1'\n  [NEXT_ROUTER_STATE_TREE_HEADER]?: string\n  [NEXT_URL]?: string\n  [NEXT_ROUTER_PREFETCH_HEADER]?: '1' | '2'\n  [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]?: string\n  'x-deployment-id'?: string\n  [NEXT_HMR_REFRESH_HEADER]?: '1'\n  // A header that is only added in test mode to assert on fetch priority\n  'Next-Test-Fetch-Priority'?: RequestInit['priority']\n}\n\nfunction doMpaNavigation(url: string): FetchServerResponseResult {\n  return {\n    flightData: urlToUrlWithoutFlightMarker(\n      new URL(url, location.origin)\n    ).toString(),\n    canonicalUrl: undefined,\n    couldBeIntercepted: false,\n    prerendered: false,\n    postponed: false,\n    staleTime: -1,\n  }\n}\n\nlet abortController = new AbortController()\n\nif (typeof window !== 'undefined') {\n  // Abort any in-flight requests when the page is unloaded, e.g. due to\n  // reloading the page or performing hard navigations. This allows us to ignore\n  // what would otherwise be a thrown TypeError when the browser cancels the\n  // requests.\n  window.addEventListener('pagehide', () => {\n    abortController.abort()\n  })\n\n  // Use a fresh AbortController instance on pageshow, e.g. when navigating back\n  // and the JavaScript execution context is restored by the browser.\n  window.addEventListener('pageshow', () => {\n    abortController = new AbortController()\n  })\n}\n\n/**\n * Fetch the flight data for the provided url. Takes in the current router state\n * to decide what to render server-side.\n */\nexport async function fetchServerResponse(\n  url: URL,\n  options: FetchServerResponseOptions\n): Promise<FetchServerResponseResult> {\n  const { flightRouterState, nextUrl, prefetchKind } = options\n\n  const headers: RequestHeaders = {\n    // Enable flight response\n    [RSC_HEADER]: '1',\n    // Provide the current router state\n    [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n      flightRouterState,\n      options.isHmrRefresh\n    ),\n  }\n\n  /**\n   * Three cases:\n   * - `prefetchKind` is `undefined`, it means it's a normal navigation, so we want to prefetch the page data fully\n   * - `prefetchKind` is `full` - we want to prefetch the whole page so same as above\n   * - `prefetchKind` is `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully\n   */\n  if (prefetchKind === PrefetchKind.AUTO) {\n    headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n  }\n\n  if (process.env.NODE_ENV === 'development' && options.isHmrRefresh) {\n    headers[NEXT_HMR_REFRESH_HEADER] = '1'\n  }\n\n  if (nextUrl) {\n    headers[NEXT_URL] = nextUrl\n  }\n\n  try {\n    // When creating a \"temporary\" prefetch (the \"on-demand\" prefetch that gets created on navigation, if one doesn't exist)\n    // we send the request with a \"high\" priority as it's in response to a user interaction that could be blocking a transition.\n    // Otherwise, all other prefetches are sent with a \"low\" priority.\n    // We use \"auto\" for in all other cases to match the existing default, as this function is shared outside of prefetching.\n    const fetchPriority = prefetchKind\n      ? prefetchKind === PrefetchKind.TEMPORARY\n        ? 'high'\n        : 'low'\n      : 'auto'\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        // In \"output: export\" mode, we can't rely on headers to distinguish\n        // between HTML and RSC requests. Instead, we append an extra prefix\n        // to the request.\n        url = new URL(url)\n        if (url.pathname.endsWith('/')) {\n          url.pathname += 'index.txt'\n        } else {\n          url.pathname += '.txt'\n        }\n      }\n    }\n\n    const res = await createFetch(\n      url,\n      headers,\n      fetchPriority,\n      abortController.signal\n    )\n\n    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n    const canonicalUrl = res.redirected ? responseUrl : undefined\n\n    const contentType = res.headers.get('content-type') || ''\n    const interception = !!res.headers.get('vary')?.includes(NEXT_URL)\n    const postponed = !!res.headers.get(NEXT_DID_POSTPONE_HEADER)\n    const staleTimeHeaderSeconds = res.headers.get(\n      NEXT_ROUTER_STALE_TIME_HEADER\n    )\n    const staleTime =\n      staleTimeHeaderSeconds !== null\n        ? parseInt(staleTimeHeaderSeconds, 10) * 1000\n        : -1\n    let isFlightResponse = contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n\n    if (process.env.NODE_ENV === 'production') {\n      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n        if (!isFlightResponse) {\n          isFlightResponse = contentType.startsWith('text/plain')\n        }\n      }\n    }\n\n    // If fetch returns something different than flight response handle it like a mpa navigation\n    // If the fetch was not 200, we also handle it like a mpa navigation\n    if (!isFlightResponse || !res.ok || !res.body) {\n      // in case the original URL came with a hash, preserve it before redirecting to the new URL\n      if (url.hash) {\n        responseUrl.hash = url.hash\n      }\n\n      return doMpaNavigation(responseUrl.toString())\n    }\n\n    // We may navigate to a page that requires a different Webpack runtime.\n    // In prod, every page will have the same Webpack runtime.\n    // In dev, the Webpack runtime is minimal for each page.\n    // We need to ensure the Webpack runtime is updated before executing client-side JS of the new page.\n    if (process.env.NODE_ENV !== 'production' && !process.env.TURBOPACK) {\n      await (\n        require('../../dev/hot-reloader/app/hot-reloader-app') as typeof import('../../dev/hot-reloader/app/hot-reloader-app')\n      ).waitForWebpackRuntimeHotUpdate()\n    }\n\n    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n    const flightStream = postponed\n      ? createUnclosingPrefetchStream(res.body)\n      : res.body\n    const response = await (createFromNextReadableStream(\n      flightStream\n    ) as Promise<NavigationFlightResponse>)\n\n    if (getAppBuildId() !== response.b) {\n      return doMpaNavigation(res.url)\n    }\n\n    return {\n      flightData: normalizeFlightData(response.f),\n      canonicalUrl: canonicalUrl,\n      couldBeIntercepted: interception,\n      prerendered: response.S,\n      postponed,\n      staleTime,\n    }\n  } catch (err) {\n    if (!abortController.signal.aborted) {\n      console.error(\n        `Failed to fetch RSC payload for ${url}. Falling back to browser navigation.`,\n        err\n      )\n    }\n\n    // If fetch fails handle it like a mpa navigation\n    // TODO-APP: Add a test for the case where a CORS request fails, e.g. external url redirect coming from the response.\n    // See https://github.com/vercel/next.js/issues/43605#issuecomment-1451617521 for a reproduction.\n    return {\n      flightData: url.toString(),\n      canonicalUrl: undefined,\n      couldBeIntercepted: false,\n      prerendered: false,\n      postponed: false,\n      staleTime: -1,\n    }\n  }\n}\n\n// This is a subset of the standard Response type. We use a custom type for\n// this so we can limit which details about the response leak into the rest of\n// the codebase. For example, there's some custom logic for manually following\n// redirects, so \"redirected\" in this type could be a composite of multiple\n// browser fetch calls; however, this fact should not leak to the caller.\nexport type RSCResponse = {\n  ok: boolean\n  redirected: boolean\n  headers: Headers\n  body: ReadableStream<Uint8Array> | null\n  status: number\n  url: string\n}\n\nexport async function createFetch(\n  url: URL,\n  headers: RequestHeaders,\n  fetchPriority: 'auto' | 'high' | 'low' | null,\n  signal?: AbortSignal\n): Promise<RSCResponse> {\n  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n  // cache busting search param) from the request so they're\n  // maximally cacheable.\n\n  if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {\n    headers['Next-Test-Fetch-Priority'] = fetchPriority\n  }\n\n  if (process.env.NEXT_DEPLOYMENT_ID) {\n    headers['x-deployment-id'] = process.env.NEXT_DEPLOYMENT_ID\n  }\n\n  const fetchOptions: RequestInit = {\n    // Backwards compat for older browsers. `same-origin` is the default in modern browsers.\n    credentials: 'same-origin',\n    headers,\n    priority: fetchPriority || undefined,\n    signal,\n  }\n  // `fetchUrl` is slightly different from `url` because we add a cache-busting\n  // search param to it. This should not leak outside of this function, so we\n  // track them separately.\n  let fetchUrl = new URL(url)\n  setCacheBustingSearchParam(fetchUrl, headers)\n  let browserResponse = await fetch(fetchUrl, fetchOptions)\n\n  // If the server responds with a redirect (e.g. 307), and the redirected\n  // location does not contain the cache busting search param set in the\n  // original request, the response is likely invalid â€” when following the\n  // redirect, the browser forwards the request headers, but since the cache\n  // busting search param is missing, the server will reject the request due to\n  // a mismatch.\n  //\n  // Ideally, we would be able to intercept the redirect response and perform it\n  // manually, instead of letting the browser automatically follow it, but this\n  // is not allowed by the fetch API.\n  //\n  // So instead, we must \"replay\" the redirect by fetching the new location\n  // again, but this time we'll append the cache busting search param to prevent\n  // a mismatch.\n  //\n  // TODO: We can optimize Next.js's built-in middleware APIs by returning a\n  // custom status code, to prevent the browser from automatically following it.\n  //\n  // This does not affect Server Action-based redirects; those are encoded\n  // differently, as part of the Flight body. It only affects redirects that\n  // occur in a middleware or a third-party proxy.\n\n  let redirected = browserResponse.redirected\n  if (process.env.__NEXT_CLIENT_VALIDATE_RSC_REQUEST_HEADERS) {\n    // This is to prevent a redirect loop. Same limit used by Chrome.\n    const MAX_REDIRECTS = 20\n    for (let n = 0; n < MAX_REDIRECTS; n++) {\n      if (!browserResponse.redirected) {\n        // The server did not perform a redirect.\n        break\n      }\n      const responseUrl = new URL(browserResponse.url, fetchUrl)\n      if (responseUrl.origin !== fetchUrl.origin) {\n        // The server redirected to an external URL. The rest of the logic below\n        // is not relevant, because it only applies to internal redirects.\n        break\n      }\n      if (\n        responseUrl.searchParams.get(NEXT_RSC_UNION_QUERY) ===\n        fetchUrl.searchParams.get(NEXT_RSC_UNION_QUERY)\n      ) {\n        // The redirected URL already includes the cache busting search param.\n        // This was probably intentional. Regardless, there's no reason to\n        // issue another request to this URL because it already has the param\n        // value that we would have added below.\n        break\n      }\n      // The RSC request was redirected. Assume the response is invalid.\n      //\n      // Append the cache busting search param to the redirected URL and\n      // fetch again.\n      fetchUrl = new URL(responseUrl)\n      setCacheBustingSearchParam(fetchUrl, headers)\n      browserResponse = await fetch(fetchUrl, fetchOptions)\n      // We just performed a manual redirect, so this is now true.\n      redirected = true\n    }\n  }\n\n  // Remove the cache busting search param from the response URL, to prevent it\n  // from leaking outside of this function.\n  const responseUrl = new URL(browserResponse.url, fetchUrl)\n  responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n\n  const rscResponse: RSCResponse = {\n    url: responseUrl.href,\n\n    // This is true if any redirects occurred, either automatically by the\n    // browser, or manually by us. So it's different from\n    // `browserResponse.redirected`, which only tells us whether the browser\n    // followed a redirect, and only for the last response in the chain.\n    redirected,\n\n    // These can be copied from the last browser response we received. We\n    // intentionally only expose the subset of fields that are actually used\n    // elsewhere in the codebase.\n    ok: browserResponse.ok,\n    headers: browserResponse.headers,\n    body: browserResponse.body,\n    status: browserResponse.status,\n  }\n\n  return rscResponse\n}\n\nexport function createFromNextReadableStream(\n  flightStream: ReadableStream<Uint8Array>\n): Promise<unknown> {\n  return createFromReadableStream(flightStream, {\n    callServer,\n    findSourceMapURL,\n  })\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightRouterState } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\n\n/**\n * Invalidate cache one level down from the router state.\n */\nexport function invalidateCacheByRouterState(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState\n): void {\n  // Remove segment that we got data for so that it is filled in during rendering of rsc.\n  for (const key in routerState[1]) {\n    const segmentForParallelRoute = routerState[1][key][0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n    const existingParallelRoutesCacheNode =\n      existingCache.parallelRoutes.get(key)\n    if (existingParallelRoutesCacheNode) {\n      let parallelRouteCacheNode = new Map(existingParallelRoutesCacheNode)\n      parallelRouteCacheNode.delete(cacheKey)\n      newCache.parallelRoutes.set(key, parallelRouteCacheNode)\n    }\n  }\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\n\nexport function isNavigatingToNewRootLayout(\n  currentTree: FlightRouterState,\n  nextTree: FlightRouterState\n): boolean {\n  // Compare segments\n  const currentTreeSegment = currentTree[0]\n  const nextTreeSegment = nextTree[0]\n\n  // If any segment is different before we find the root layout, the root layout has changed.\n  // E.g. /same/(group1)/layout.js -> /same/(group2)/layout.js\n  // First segment is 'same' for both, keep looking. (group1) changed to (group2) before the root layout was found, it must have changed.\n  if (Array.isArray(currentTreeSegment) && Array.isArray(nextTreeSegment)) {\n    // Compare dynamic param name and type but ignore the value, different values would not affect the current root layout\n    // /[name] - /slug1 and /slug2, both values (slug1 & slug2) still has the same layout /[name]/layout.js\n    if (\n      currentTreeSegment[0] !== nextTreeSegment[0] ||\n      currentTreeSegment[2] !== nextTreeSegment[2]\n    ) {\n      return true\n    }\n  } else if (currentTreeSegment !== nextTreeSegment) {\n    return true\n  }\n\n  // Current tree root layout found\n  if (currentTree[4]) {\n    // If the next tree doesn't have the root layout flag, it must have changed.\n    return !nextTree[4]\n  }\n  // Current tree didn't have its root layout here, must have changed.\n  if (nextTree[4]) {\n    return true\n  }\n  // We can't assume it's `parallelRoutes.children` here in case the root layout is `app/@something/layout.js`\n  // But it's not possible to be more than one parallelRoutes before the root layout is found\n  // TODO-APP: change to traverse all parallel routes\n  const currentTreeChild = Object.values(currentTree[1])[0]\n  const nextTreeChild = Object.values(nextTree[1])[0]\n  if (!currentTreeChild || !nextTreeChild) return true\n  return isNavigatingToNewRootLayout(currentTreeChild, nextTreeChild)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { FlightSegmentPath } from '../../../server/app-render/types'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\n\n/**\n * Fill cache up to the end of the flightSegmentPath, invalidating anything below it.\n */\nexport function invalidateCacheBelowFlightSegmentPath(\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath\n): void {\n  const isLastEntry = flightSegmentPath.length <= 2\n  const [parallelRouteKey, segment] = flightSegmentPath\n\n  const cacheKey = createRouterCacheKey(segment)\n\n  const existingChildSegmentMap =\n    existingCache.parallelRoutes.get(parallelRouteKey)\n\n  if (!existingChildSegmentMap) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  let childSegmentMap = newCache.parallelRoutes.get(parallelRouteKey)\n  if (!childSegmentMap || childSegmentMap === existingChildSegmentMap) {\n    childSegmentMap = new Map(existingChildSegmentMap)\n    newCache.parallelRoutes.set(parallelRouteKey, childSegmentMap)\n  }\n\n  // In case of last entry don't copy further down.\n  if (isLastEntry) {\n    childSegmentMap.delete(cacheKey)\n    return\n  }\n\n  const existingChildCacheNode = existingChildSegmentMap.get(cacheKey)\n  let childCacheNode = childSegmentMap.get(cacheKey)\n\n  if (!childCacheNode || !existingChildCacheNode) {\n    // Bailout because the existing cache does not have the path to the leaf node\n    // Will trigger lazy fetch in layout-router because of missing segment\n    return\n  }\n\n  if (childCacheNode === existingChildCacheNode) {\n    childCacheNode = {\n      lazyData: childCacheNode.lazyData,\n      rsc: childCacheNode.rsc,\n      prefetchRsc: childCacheNode.prefetchRsc,\n      head: childCacheNode.head,\n      prefetchHead: childCacheNode.prefetchHead,\n      parallelRoutes: new Map(childCacheNode.parallelRoutes),\n    } as CacheNode\n    childSegmentMap.set(cacheKey, childCacheNode)\n  }\n\n  invalidateCacheBelowFlightSegmentPath(\n    childCacheNode,\n    existingChildCacheNode,\n    getNextFlightSegmentPath(flightSegmentPath)\n  )\n}\n","import type {\n  FlightRouterState,\n  Segment,\n} from '../../../server/app-render/types'\nimport { INTERCEPTION_ROUTE_MARKERS } from '../../../shared/lib/router/utils/interception-routes'\nimport type { Params } from '../../../server/request/params'\nimport {\n  isGroupSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\n\nconst removeLeadingSlash = (segment: string): string => {\n  return segment[0] === '/' ? segment.slice(1) : segment\n}\n\nconst segmentToPathname = (segment: Segment): string => {\n  if (typeof segment === 'string') {\n    // 'children' is not a valid path -- it's technically a parallel route that corresponds with the current segment's page\n    // if we don't skip it, then the computed pathname might be something like `/children` which doesn't make sense.\n    if (segment === 'children') return ''\n\n    return segment\n  }\n\n  return segment[1]\n}\n\nfunction normalizeSegments(segments: string[]): string {\n  return (\n    segments.reduce((acc, segment) => {\n      segment = removeLeadingSlash(segment)\n      if (segment === '' || isGroupSegment(segment)) {\n        return acc\n      }\n\n      return `${acc}/${segment}`\n    }, '') || '/'\n  )\n}\n\nexport function extractPathFromFlightRouterState(\n  flightRouterState: FlightRouterState\n): string | undefined {\n  const segment = Array.isArray(flightRouterState[0])\n    ? flightRouterState[0][1]\n    : flightRouterState[0]\n\n  if (\n    segment === DEFAULT_SEGMENT_KEY ||\n    INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m))\n  )\n    return undefined\n\n  if (segment.startsWith(PAGE_SEGMENT_KEY)) return ''\n\n  const segments = [segmentToPathname(segment)]\n  const parallelRoutes = flightRouterState[1] ?? {}\n\n  const childrenPath = parallelRoutes.children\n    ? extractPathFromFlightRouterState(parallelRoutes.children)\n    : undefined\n\n  if (childrenPath !== undefined) {\n    segments.push(childrenPath)\n  } else {\n    for (const [key, value] of Object.entries(parallelRoutes)) {\n      if (key === 'children') continue\n\n      const childPath = extractPathFromFlightRouterState(value)\n\n      if (childPath !== undefined) {\n        segments.push(childPath)\n      }\n    }\n  }\n\n  return normalizeSegments(segments)\n}\n\nfunction computeChangedPathImpl(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const [segmentA, parallelRoutesA] = treeA\n  const [segmentB, parallelRoutesB] = treeB\n\n  const normalizedSegmentA = segmentToPathname(segmentA)\n  const normalizedSegmentB = segmentToPathname(segmentB)\n\n  if (\n    INTERCEPTION_ROUTE_MARKERS.some(\n      (m) =>\n        normalizedSegmentA.startsWith(m) || normalizedSegmentB.startsWith(m)\n    )\n  ) {\n    return ''\n  }\n\n  if (!matchSegment(segmentA, segmentB)) {\n    // once we find where the tree changed, we compute the rest of the path by traversing the tree\n    return extractPathFromFlightRouterState(treeB) ?? ''\n  }\n\n  for (const parallelRouterKey in parallelRoutesA) {\n    if (parallelRoutesB[parallelRouterKey]) {\n      const changedPath = computeChangedPathImpl(\n        parallelRoutesA[parallelRouterKey],\n        parallelRoutesB[parallelRouterKey]\n      )\n      if (changedPath !== null) {\n        return `${segmentToPathname(segmentB)}/${changedPath}`\n      }\n    }\n  }\n\n  return null\n}\n\nexport function computeChangedPath(\n  treeA: FlightRouterState,\n  treeB: FlightRouterState\n): string | null {\n  const changedPath = computeChangedPathImpl(treeA, treeB)\n\n  if (changedPath == null || changedPath === '/') {\n    return changedPath\n  }\n\n  // lightweight normalization to remove route groups\n  return normalizeSegments(changedPath.split('/'))\n}\n\n/**\n * Recursively extracts dynamic parameters from FlightRouterState.\n */\nexport function getSelectedParams(\n  currentTree: FlightRouterState,\n  params: Params = {}\n): Params {\n  const parallelRoutes = currentTree[1]\n\n  for (const parallelRoute of Object.values(parallelRoutes)) {\n    const segment = parallelRoute[0]\n    const isDynamicParameter = Array.isArray(segment)\n    const segmentValue = isDynamicParameter ? segment[1] : segment\n    if (!segmentValue || segmentValue.startsWith(PAGE_SEGMENT_KEY)) continue\n\n    // Ensure catchAll and optional catchall are turned into an array\n    const isCatchAll =\n      isDynamicParameter && (segment[2] === 'c' || segment[2] === 'oc')\n\n    if (isCatchAll) {\n      params[segment[0]] = segment[1].split('/')\n    } else if (isDynamicParameter) {\n      params[segment[0]] = segment[1]\n    }\n\n    params = getSelectedParams(parallelRoute, params)\n  }\n\n  return params\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\nimport { handleExternalUrl } from './reducers/navigate-reducer'\nimport type {\n  ReadonlyReducerState,\n  ReducerActions,\n} from './router-reducer-types'\n\n/**\n * Handles the case where the client router attempted to patch the tree but, due to a mismatch, the patch failed.\n * This will perform an MPA navigation to return the router to a valid state.\n */\nexport function handleSegmentMismatch(\n  state: ReadonlyReducerState,\n  action: ReducerActions,\n  treePatch: FlightRouterState\n) {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\n      'Performing hard navigation because your application experienced an unrecoverable error. If this keeps occurring, please file a Next.js issue.\\n\\n' +\n        'Reason: Segment mismatch\\n' +\n        `Last Action: ${action.type}\\n\\n` +\n        `Current Tree: ${JSON.stringify(state.tree)}\\n\\n` +\n        `Tree Patch Payload: ${JSON.stringify(treePatch)}`\n    )\n  }\n\n  return handleExternalUrl(state, {}, state.canonicalUrl, true)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-head'\nimport { fillCacheWithNewSubTreeData } from './fill-cache-with-new-subtree-data'\nimport type { PrefetchCacheEntry } from './router-reducer-types'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\n\nexport function applyFlightData(\n  navigatedAt: number,\n  existingCache: CacheNode,\n  cache: CacheNode,\n  flightData: NormalizedFlightData,\n  prefetchEntry?: PrefetchCacheEntry\n): boolean {\n  // The one before last item is the router state tree patch\n  const { tree: treePatch, seedData, head, isRootRender } = flightData\n\n  // Handles case where prefetch only returns the router tree patch without rendered components.\n  if (seedData === null) {\n    return false\n  }\n\n  if (isRootRender) {\n    const rsc = seedData[1]\n    const loading = seedData[3]\n    cache.loading = loading\n    cache.rsc = rsc\n    // This is a PPR-only field. When PPR is enabled, we shouldn't hit\n    // this path during a navigation, but until PPR is fully implemented\n    // yet it's possible the existing node does have a non-null\n    // `prefetchRsc`. As an incremental step, we'll just de-opt to the\n    // old behavior â€” no PPR value.\n    cache.prefetchRsc = null\n    fillLazyItemsTillLeafWithHead(\n      navigatedAt,\n      cache,\n      existingCache,\n      treePatch,\n      seedData,\n      head,\n      prefetchEntry\n    )\n  } else {\n    // Copy rsc for the root node of the cache.\n    cache.rsc = existingCache.rsc\n    // This is a PPR-only field. Unlike the previous branch, since we're\n    // just cloning the existing cache node, we might as well keep the\n    // PPR value, if it exists.\n    cache.prefetchRsc = existingCache.prefetchRsc\n    cache.parallelRoutes = new Map(existingCache.parallelRoutes)\n    cache.loading = existingCache.loading\n    // Create a copy of the existing cache with the rsc applied.\n    fillCacheWithNewSubTreeData(\n      navigatedAt,\n      cache,\n      existingCache,\n      flightData,\n      prefetchEntry\n    )\n  }\n\n  return true\n}\n","'use client'\n\nimport React, { useContext, type JSX } from 'react'\nimport { TemplateContext } from '../../shared/lib/app-router-context.shared-runtime'\n\nexport default function RenderFromTemplateContext(): JSX.Element {\n  const children = useContext(TemplateContext)\n  return <>{children}</>\n}\n","import type { Segment } from '../../../server/app-render/types'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\nexport function createRouterCacheKey(\n  segment: Segment,\n  withoutSearchParameters: boolean = false\n) {\n  // if the segment is an array, it means it's a dynamic segment\n  // for example, ['lang', 'en', 'd']. We need to convert it to a string to store it as a cache node key.\n  if (Array.isArray(segment)) {\n    return `${segment[0]}|${segment[1]}|${segment[2]}`\n  }\n\n  // Page segments might have search parameters, ie __PAGE__?foo=bar\n  // When `withoutSearchParameters` is true, we only want to return the page segment\n  if (withoutSearchParameters && segment.startsWith(PAGE_SEGMENT_KEY)) {\n    return PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../../../shared/lib/segment'\nimport type { NormalizedFlightData } from '../../flight-data-helpers'\nimport { createEmptyCacheNode } from '../app-router'\nimport { applyRouterStatePatchToTree } from './apply-router-state-patch-to-tree'\nimport { createHrefFromUrl } from './create-href-from-url'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport { fillCacheWithNewSubTreeDataButOnlyLoading } from './fill-cache-with-new-subtree-data'\nimport { handleMutable } from './handle-mutable'\nimport { generateSegmentsFromPatch } from './reducers/navigate-reducer'\nimport type { Mutable, ReadonlyReducerState } from './router-reducer-types'\n\n/**\n * This is a stop-gap until per-segment caching is implemented. It leverages the `aliased` flag that is added\n * to prefetch entries when it's determined that the loading state from that entry should be used for this navigation.\n * This function takes the aliased entry and only applies the loading state to the updated cache node.\n * We should remove this once per-segment fetching is implemented as ideally the prefetch cache will contain a\n * more granular segment map and so the router will be able to simply re-use the loading segment for the new navigation.\n */\nexport function handleAliasedPrefetchEntry(\n  navigatedAt: number,\n  state: ReadonlyReducerState,\n  flightData: string | NormalizedFlightData[],\n  url: URL,\n  mutable: Mutable\n) {\n  let currentTree = state.tree\n  let currentCache = state.cache\n  const href = createHrefFromUrl(url)\n  let applied\n  let scrollableSegments: FlightSegmentPath[] = []\n\n  if (typeof flightData === 'string') {\n    return false\n  }\n\n  for (const normalizedFlightData of flightData) {\n    // If the segment doesn't have a loading component, we don't need to do anything.\n    if (!hasLoadingComponentInSeedData(normalizedFlightData.seedData)) {\n      continue\n    }\n\n    let treePatch = normalizedFlightData.tree\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    const { seedData, isRootRender, pathToSegment } = normalizedFlightData\n    // TODO-APP: remove ''\n    const flightSegmentPathWithLeadingEmpty = ['', ...pathToSegment]\n\n    // Segments are keyed by searchParams (e.g. __PAGE__?{\"foo\":\"bar\"}). We might return a less specific, param-less entry,\n    // so we ensure that the final tree contains the correct searchParams (reflected in the URL) are provided in the updated FlightRouterState tree.\n    // We only do this on the first read, as otherwise we'd be overwriting the searchParams that may have already been set\n    treePatch = addSearchParamsToPageSegments(\n      treePatch,\n      Object.fromEntries(url.searchParams)\n    )\n\n    let newTree = applyRouterStatePatchToTree(\n      flightSegmentPathWithLeadingEmpty,\n      currentTree,\n      treePatch,\n      href\n    )\n\n    const newCache = createEmptyCacheNode()\n\n    // The prefetch cache entry was aliased -- this signals that we only fill in the cache with the\n    // loading state and not the actual parallel route seed data.\n    if (isRootRender && seedData) {\n      // Fill in the cache with the new loading / rsc data\n      const rsc = seedData[1]\n      const loading = seedData[3]\n      newCache.loading = loading\n      newCache.rsc = rsc\n\n      // Construct a new tree and apply the aliased loading state for each parallel route\n      fillNewTreeWithOnlyLoadingSegments(\n        navigatedAt,\n        newCache,\n        currentCache,\n        treePatch,\n        seedData\n      )\n    } else {\n      // Copy rsc for the root node of the cache.\n      newCache.rsc = currentCache.rsc\n      newCache.prefetchRsc = currentCache.prefetchRsc\n      newCache.loading = currentCache.loading\n      newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n      // copy the loading state only into the leaf node (the part that changed)\n      fillCacheWithNewSubTreeDataButOnlyLoading(\n        navigatedAt,\n        newCache,\n        currentCache,\n        normalizedFlightData\n      )\n    }\n\n    // If we don't have an updated tree, there's no reason to update the cache, as the tree\n    // dictates what cache nodes to render.\n    if (newTree) {\n      currentTree = newTree\n      currentCache = newCache\n      applied = true\n    }\n\n    for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n      const scrollableSegmentPath = [\n        ...normalizedFlightData.pathToSegment,\n        ...subSegment,\n      ]\n      // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n      if (\n        scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n        DEFAULT_SEGMENT_KEY\n      ) {\n        scrollableSegments.push(scrollableSegmentPath)\n      }\n    }\n  }\n\n  if (!applied) {\n    return false\n  }\n\n  mutable.patchedTree = currentTree\n  mutable.cache = currentCache\n  mutable.canonicalUrl = href\n  mutable.hashFragment = url.hash\n  mutable.scrollableSegments = scrollableSegments\n\n  return handleMutable(state, mutable)\n}\n\nfunction hasLoadingComponentInSeedData(seedData: CacheNodeSeedData | null) {\n  if (!seedData) return false\n\n  const parallelRoutes = seedData[2]\n  const loading = seedData[3]\n\n  if (loading) {\n    return true\n  }\n\n  for (const key in parallelRoutes) {\n    if (hasLoadingComponentInSeedData(parallelRoutes[key])) {\n      return true\n    }\n  }\n\n  return false\n}\n\nfunction fillNewTreeWithOnlyLoadingSegments(\n  navigatedAt: number,\n  newCache: CacheNode,\n  existingCache: CacheNode,\n  routerState: FlightRouterState,\n  cacheNodeSeedData: CacheNodeSeedData | null\n) {\n  const isLastSegment = Object.keys(routerState[1]).length === 0\n  if (isLastSegment) {\n    return\n  }\n\n  for (const key in routerState[1]) {\n    const parallelRouteState = routerState[1][key]\n    const segmentForParallelRoute = parallelRouteState[0]\n    const cacheKey = createRouterCacheKey(segmentForParallelRoute)\n\n    const parallelSeedData =\n      cacheNodeSeedData !== null && cacheNodeSeedData[2][key] !== undefined\n        ? cacheNodeSeedData[2][key]\n        : null\n\n    let newCacheNode: CacheNode\n    if (parallelSeedData !== null) {\n      // New data was sent from the server.\n      const rsc = parallelSeedData[1]\n      const loading = parallelSeedData[3]\n      newCacheNode = {\n        lazyData: null,\n        // copy the layout but null the page segment as that's not meant to be used\n        rsc: segmentForParallelRoute.includes(PAGE_SEGMENT_KEY) ? null : rsc,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading,\n        navigatedAt,\n      }\n    } else {\n      // No data available for this node. This will trigger a lazy fetch\n      // during render.\n      newCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n    }\n\n    const existingParallelRoutes = newCache.parallelRoutes.get(key)\n    if (existingParallelRoutes) {\n      existingParallelRoutes.set(cacheKey, newCacheNode)\n    } else {\n      newCache.parallelRoutes.set(key, new Map([[cacheKey, newCacheNode]]))\n    }\n\n    fillNewTreeWithOnlyLoadingSegments(\n      navigatedAt,\n      newCacheNode,\n      existingCache,\n      parallelRouteState,\n      parallelSeedData\n    )\n  }\n}\n\n/**\n * Add search params to the page segments in the flight router state\n * Page segments that are associated with search params have a page segment key\n * followed by a query string. This function will add those params to the page segment.\n * This is useful if we return an aliased prefetch entry (ie, won't have search params)\n * but the canonical router URL has search params.\n */\nexport function addSearchParamsToPageSegments(\n  flightRouterState: FlightRouterState,\n  searchParams: Record<string, string | string[] | undefined>\n): FlightRouterState {\n  const [segment, parallelRoutes, ...rest] = flightRouterState\n\n  // If it's a page segment, modify the segment by adding search params\n  if (segment.includes(PAGE_SEGMENT_KEY)) {\n    const newSegment = addSearchParamsIfPageSegment(segment, searchParams)\n    return [newSegment, parallelRoutes, ...rest]\n  }\n\n  // Otherwise, recurse through the parallel routes and return a new tree\n  const updatedParallelRoutes: { [key: string]: FlightRouterState } = {}\n\n  for (const [key, parallelRoute] of Object.entries(parallelRoutes)) {\n    updatedParallelRoutes[key] = addSearchParamsToPageSegments(\n      parallelRoute,\n      searchParams\n    )\n  }\n\n  return [segment, updatedParallelRoutes, ...rest]\n}\n","export function createHrefFromUrl(\n  url: Pick<URL, 'pathname' | 'search' | 'hash'>,\n  includeHash: boolean = true\n): string {\n  return url.pathname + url.search + (includeHash ? url.hash : '')\n}\n"],"names":["fillCacheWithNewSubTreeData","fillCacheWithNewSubTreeDataButOnlyLoading","fillCacheHelper","navigatedAt","newCache","existingCache","flightData","prefetchEntry","fillLazyItems","segmentPath","seedData","treePatch","tree","head","newCacheNode","existingCacheNode","i","length","parallelRouteKey","segment","isLastEntry","cacheKey","createRouterCacheKey","existingChildSegmentMap","parallelRoutes","get","childSegmentMap","Map","set","existingChildCacheNode","childCacheNode","cacheNodeSeedData","lazyData","incomingSegment","rsc","loading","PAGE_SEGMENT_KEY","prefetchRsc","prefetchHead","invalidateCacheByRouterState","fillLazyItemsTillLeafWithHead","routerState","isLastSegment","Object","keys","key","parallelRouteState","segmentForParallelRoute","parallelSeedData","existingParallelRoutesCacheNode","hasReusablePrefetch","kind","status","PrefetchCacheEntryStatus","reusable","parallelRouteCacheNode","seedNode","existingParallelRoutes","undefined","applyRouterStatePatchToTree","flightSegmentPath","flightRouterState","path","parallelRoutePatch","url","refetch","isRootLayout","applyPatch","addRefreshMarkerToActiveParallelSegments","currentSegment","matchSegment","lastSegment","getNextFlightSegmentPath","initialTree","patchTree","initialSegment","initialParallelRoutes","patchSegment","patchParallelRoutes","DEFAULT_SEGMENT_KEY","newParallelRoutes","handleMutable","isNotUndefined","value","state","mutable","shouldScroll","nextUrl","patchedTree","changedPath","computeChangedPath","canonicalUrl","pushRef","pendingPush","mpaNavigation","preserveCustomHistoryState","focusAndScrollRef","apply","scrollableSegments","onlyHashChange","hashFragment","decodeURIComponent","slice","segmentPaths","cache","prefetchCache","clearCacheNodeDataForSegmentPath","createInitialRouterState","initialSeedData","extractPathFromFlightRouterState","initialFlightData","initialCanonicalUrlParts","location","couldBeIntercepted","postponed","prerendered","initialCanonicalUrl","join","normalizedFlightData","getFlightDataPartsFromPath","initialHead","createHrefFromUrl","size","initialState","pathname","process","URL","search","origin","createSeededPrefetchCacheEntry","data","staleTime","STATIC_STALETIME_MS","PrefetchKind","FULL","AUTO","createFetch","createFromNextReadableStream","fetchServerResponse","createFromReadableStream","createFromReadableStreamBrowser","doMpaNavigation","urlToUrlWithoutFlightMarker","toString","abortController","AbortController","options","prefetchKind","res","fetchPriority","contentType","interception","staleTimeHeaderSeconds","isFlightResponse","response","err","headers","RSC_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","prepareFlightRouterStateForRequest","isHmrRefresh","NEXT_ROUTER_PREFETCH_HEADER","NEXT_URL","TEMPORARY","endsWith","signal","responseUrl","redirected","includes","NEXT_DID_POSTPONE_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","parseInt","startsWith","RSC_CONTENT_TYPE_HEADER","ok","body","hash","env","reader","createUnclosingPrefetchStream","flightStream","ReadableStream","pull","read","done","controller","enqueue","getAppBuildId","b","normalizeFlightData","f","S","aborted","fetchOptions","fetchUrl","browserResponse","MAX_REDIRECTS","n","rscResponse","credentials","priority","setCacheBustingSearchParam","fetch","searchParams","NEXT_RSC_UNION_QUERY","delete","href","callServer","findSourceMapURL","window","addEventListener","abort","isNavigatingToNewRootLayout","currentTree","nextTree","currentTreeSegment","nextTreeSegment","Array","isArray","currentTreeChild","values","nextTreeChild","invalidateCacheBelowFlightSegmentPath","getSelectedParams","params","parallelRoute","isDynamicParameter","segmentValue","split","segmentToPathname","normalizeSegments","segments","reduce","acc","removeLeadingSlash","isGroupSegment","INTERCEPTION_ROUTE_MARKERS","some","m","childrenPath","children","push","entries","childPath","treeA","treeB","computeChangedPathImpl","segmentA","parallelRoutesA","segmentB","parallelRoutesB","normalizedSegmentA","normalizedSegmentB","parallelRouterKey","handleSegmentMismatch","action","handleExternalUrl","applyFlightData","isRootRender","RenderFromTemplateContext","useContext","TemplateContext","withoutSearchParameters","addSearchParamsToPageSegments","handleAliasedPrefetchEntry","currentCache","applied","hasLoadingComponentInSeedData","fromEntries","pathToSegment","flightSegmentPathWithLeadingEmpty","newTree","createEmptyCacheNode","fillNewTreeWithOnlyLoadingSegments","generateSegmentsFromPatch","subSegment","scrollableSegmentPath","rest","addSearchParamsIfPageSegment","updatedParallelRoutes","includeHash"],"sourceRoot":"","ignoreList":[]}