{"version":3,"file":"static/chunks/1101-bede68def8abc9b6.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/set-cache-busting-search-param.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/prefetch-cache-utils.ts","webpack://_N_E/../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/prefetch-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/get-segment-value.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/router-reducer-types.ts","webpack://_N_E/../../../../src/client/components/router-reducer/ppr-navigations.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/restore-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/should-hard-navigate.ts","webpack://_N_E/../../../../src/client/components/router-reducer/router-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","import type { FlightRouterState } from '../../../../server/app-render/types'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n","import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../server/app-render/types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport {\n  PrefetchKind,\n  type ReadonlyReducerState,\n  type ReducerState,\n  type ServerActionAction,\n  type ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const res = await fetch(state.canonicalUrl, {\n    method: 'POST',\n    headers: {\n      Accept: RSC_CONTENT_TYPE_HEADER,\n      [ACTION_HEADER]: actionId,\n      [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n        state.tree\n      ),\n      ...(process.env.NEXT_DEPLOYMENT_ID\n        ? {\n            'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,\n          }\n        : {}),\n      ...(nextUrl\n        ? {\n            [NEXT_URL]: nextUrl,\n          }\n        : {}),\n    },\n    body,\n  })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      { callServer, findSourceMapURL, temporaryReferences }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[3]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            undefined\n          )\n\n          mutable.cache = cache\n          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n            revalidateEntireCache(state.nextUrl, newTree)\n          } else {\n            mutable.prefetchCache = new Map()\n          }\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE && !actionRevalidated) {\n          // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n          // with the FlightData that we got from the server action for the target page, so that it's\n          // available when the page is navigated to and doesn't need to be re-fetched.\n          // We only do this if the server action didn't revalidate any data, as in that case the\n          // client cache will be cleared and the data will be re-fetched anyway.\n          // NOTE: We don't do this in the Segment Cache implementation.\n          // Dynamic data should never be placed into the cache, unless it's\n          // \"converted\" to static data using <Link prefetch={true}>. What we\n          // do instead is re-prefetch links and forms whenever the cache is\n          // invalidated.\n          createSeededPrefetchCacheEntry({\n            url: redirectLocation,\n            data: {\n              flightData,\n              canonicalUrl: undefined,\n              couldBeIntercepted: false,\n              prerendered: false,\n              postponed: false,\n              // TODO: We should be able to set this if the server action\n              // returned a fully static response.\n              staleTime: -1,\n            },\n            tree: state.tree,\n            prefetchCache: state.prefetchCache,\n            nextUrl: state.nextUrl,\n            kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,\n          })\n          mutable.prefetchCache = state.prefetchCache\n        }\n\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        reject(\n          getRedirectError(\n            hasBasePath(redirectHref)\n              ? removeBasePath(redirectHref)\n              : redirectHref,\n            redirectType || RedirectType.push\n          )\n        )\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n","import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\n\nconst INTERCEPTION_CACHE_KEY_MARKER = '%'\n\nexport type AliasedPrefetchCacheEntry = PrefetchCacheEntry & {\n  /** This is a special property that indicates a prefetch entry associated with a different URL\n   * was returned rather than the requested URL. This signals to the router that it should only\n   * apply the part that doesn't depend on searchParams (specifically the loading state).\n   */\n  aliased?: boolean\n}\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKeyImpl(\n  url: URL,\n  includeSearchParams: boolean,\n  prefix?: string | null\n) {\n  // Initially we only use the pathname as the cache key. We don't want to include\n  // search params so that multiple URLs with the same search parameter can re-use\n  // loading states.\n  let pathnameFromUrl = url.pathname\n\n  // RSC responses can differ based on search params, specifically in the case where we aren't\n  // returning a partial response (ie with `PrefetchKind.AUTO`).\n  // In the auto case, since loading.js & layout.js won't have access to search params,\n  // we can safely re-use that cache entry. But for full prefetches, we should not\n  // re-use the cache entry as the response may differ.\n  if (includeSearchParams) {\n    // if we have a full prefetch, we can include the search param in the key,\n    // as we'll be getting back a full response. The server might have read the search\n    // params when generating the full response.\n    pathnameFromUrl += url.search\n  }\n\n  if (prefix) {\n    return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\nfunction createPrefetchCacheKey(\n  url: URL,\n  kind: PrefetchKind | undefined,\n  nextUrl?: string | null\n) {\n  return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)\n}\n\nfunction getExistingCacheEntry(\n  url: URL,\n  kind: PrefetchKind = PrefetchKind.TEMPORARY,\n  nextUrl: string | null,\n  prefetchCache: Map<string, PrefetchCacheEntry>,\n  allowAliasing: boolean\n): AliasedPrefetchCacheEntry | undefined {\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  for (const maybeNextUrl of [nextUrl, null]) {\n    const cacheKeyWithParams = createPrefetchCacheKeyImpl(\n      url,\n      true,\n      maybeNextUrl\n    )\n    const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(\n      url,\n      false,\n      maybeNextUrl\n    )\n\n    // First, we check if we have a cache entry that exactly matches the URL\n    const cacheKeyToUse = url.search\n      ? cacheKeyWithParams\n      : cacheKeyWithoutParams\n\n    const existingEntry = prefetchCache.get(cacheKeyToUse)\n    if (existingEntry && allowAliasing) {\n      // We know we're returning an aliased entry when the pathname matches but the search params don't,\n      const isAliased =\n        existingEntry.url.pathname === url.pathname &&\n        existingEntry.url.search !== url.search\n\n      if (isAliased) {\n        return {\n          ...existingEntry,\n          aliased: true,\n        }\n      }\n\n      return existingEntry\n    }\n\n    // If the request contains search params, and we're not doing a full prefetch, we can return the\n    // param-less entry if it exists.\n    // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n    // but lets us arrive there quicker in the param-full case.\n    const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      allowAliasing &&\n      url.search &&\n      kind !== PrefetchKind.FULL &&\n      entryWithoutParams &&\n      // We shouldn't return the aliased entry if it was relocated to a new cache key.\n      // Since it's rewritten, it could respond with a completely different loading state.\n      !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n    ) {\n      return { ...entryWithoutParams, aliased: true }\n    }\n  }\n\n  // If we've gotten to this point, we didn't find a specific cache entry that matched\n  // the request URL.\n  // We attempt a partial match by checking if there's a cache entry with the same pathname.\n  // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n  // This will signal to the router that it should only apply the loading state on the prefetched data.\n  if (\n    process.env.NODE_ENV !== 'development' &&\n    kind !== PrefetchKind.FULL &&\n    allowAliasing\n  ) {\n    for (const cacheEntry of prefetchCache.values()) {\n      if (\n        cacheEntry.url.pathname === url.pathname &&\n        // We shouldn't return the aliased entry if it was relocated to a new cache key.\n        // Since it's rewritten, it could respond with a completely different loading state.\n        !cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n      ) {\n        return { ...cacheEntry, aliased: true }\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  prefetchCache,\n  kind,\n  allowAliasing = true,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'> & {\n  url: URL\n  kind?: PrefetchKind\n  allowAliasing: boolean\n}): AliasedPrefetchCacheEntry {\n  const existingCacheEntry = getExistingCacheEntry(\n    url,\n    kind,\n    nextUrl,\n    prefetchCache,\n    allowAliasing\n  )\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n      // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n      // are seeded but without a prefetch intent)\n      existingCacheEntry.data.then((prefetchResponse) => {\n        const isFullPrefetch =\n          Array.isArray(prefetchResponse.flightData) &&\n          prefetchResponse.flightData.some((flightData) => {\n            // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n            return flightData.isRootRender && flightData.seedData !== null\n          })\n\n        if (!isFullPrefetch) {\n          return createLazyPrefetchEntry({\n            tree,\n            url,\n            nextUrl,\n            prefetchCache,\n            // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n            // rather than assuming the same intent as the previous entry, to be consistent with how we\n            // lazily create prefetch entries when intent is left unspecified.\n            kind: kind ?? PrefetchKind.TEMPORARY,\n          })\n        }\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n  existingCacheKey,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n  existingCacheKey: string\n}) {\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(\n    url,\n    existingCacheEntry.kind,\n    nextUrl\n  )\n  prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })\n  prefetchCache.delete(existingCacheKey)\n\n  return newCacheKey\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createSeededPrefetchCacheEntry({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  data,\n  kind,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  data: FetchServerResponseResult\n  kind: PrefetchKind\n}) {\n  // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n  // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = data.couldBeIntercepted\n    ? createPrefetchCacheKey(url, kind, nextUrl)\n    : createPrefetchCacheKey(url, kind)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    staleTime: data.staleTime,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  } satisfies PrefetchCacheEntry\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url, kind)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, {\n      flightRouterState: tree,\n      nextUrl,\n      prefetchKind: kind,\n    }).then((prefetchResponse) => {\n      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n      // to avoid drift between this cache key prefixing logic\n      // (which is currently directly influenced by the server response)\n      let newCacheKey\n\n      if (prefetchResponse.couldBeIntercepted) {\n        // Determine if we need to prefix the cache key with the nextUrl\n        newCacheKey = prefixExistingPrefetchCacheEntry({\n          url,\n          existingCacheKey: prefetchCacheKey,\n          nextUrl,\n          prefetchCache,\n        })\n      }\n\n      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n      // staleTime.\n      if (prefetchResponse.prerendered) {\n        const existingCacheEntry = prefetchCache.get(\n          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n          newCacheKey ?? prefetchCacheKey\n        )\n        if (existingCacheEntry) {\n          existingCacheEntry.kind = PrefetchKind.FULL\n          if (prefetchResponse.staleTime !== -1) {\n            // This is the stale time that was collected by the server during\n            // static generation. Use this in place of the default stale time.\n            existingCacheEntry.staleTime = prefetchResponse.staleTime\n          }\n        }\n      }\n\n      return prefetchResponse\n    })\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === PrefetchKind.AUTO) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === PrefetchKind.FULL) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  navigatedAt: number\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  navigatedAt,\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then(({ flightData }) => {\n      if (typeof flightData !== 'string') {\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(\n            navigatedAt,\n            updatedCache,\n            updatedCache,\n            flightDataPath\n          )\n        }\n      } else {\n        // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      navigatedAt,\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n","import type {\n  PrefetchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport { PromiseQueue } from '../../promise-queue'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nexport const prefetchQueue = new PromiseQueue(5)\n\nexport const prefetchReducer = process.env.__NEXT_CLIENT_SEGMENT_CACHE\n  ? identityReducerWhenSegmentCacheIsEnabled\n  : prefetchReducerImpl\n\nfunction identityReducerWhenSegmentCacheIsEnabled<T>(state: T): T {\n  // Unlike the old implementation, the Segment Cache doesn't store its data in\n  // the router reducer state.\n  //\n  // This shouldn't be reachable because we wrap the prefetch API in a check,\n  // too, which prevents the action from being dispatched. But it's here for\n  // clarity + code elimination.\n  return state\n}\n\nfunction prefetchReducerImpl(\n  state: ReadonlyReducerState,\n  action: PrefetchAction\n): ReducerState {\n  // let's prune the prefetch cache before we do anything else\n  prunePrefetchCache(state.prefetchCache)\n\n  const { url } = action\n\n  getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    prefetchCache: state.prefetchCache,\n    kind: action.kind,\n    tree: state.tree,\n    allowAliasing: true,\n  })\n\n  return state\n}\n","import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  const navigatedAt = Date.now()\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n        const applied = applyFlightData(\n          navigatedAt,\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n","import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\nimport { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'\nimport {\n  navigate as navigateUsingSegmentCache,\n  NavigationResultTag,\n  type NavigationResult,\n} from '../../segment-cache'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =\n    action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // (Very Early Experimental Feature) Segment Cache\n    //\n    // Bypass the normal prefetch cache and use the new per-segment cache\n    // implementation instead. This is only supported if PPR is enabled, too.\n    //\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const result = navigateUsingSegmentCache(\n      url,\n      state.cache,\n      state.tree,\n      state.nextUrl,\n      shouldScroll\n    )\n    return handleNavigationResult(url, state, mutable, pendingPush, result)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    prefetchCache: state.prefetchCache,\n    allowAliasing,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) => {\n      const navigatedAt = Date.now()\n\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = navigatedAt\n        isFirstRead = true\n      }\n\n      if (prefetchValues.aliased) {\n        // When alias is enabled, search param may not be included in the canonicalUrl.\n        // But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.\n        const urlWithCanonicalPathname = new URL(url.href)\n        if (canonicalUrlOverride) {\n          urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname\n        }\n\n        const result = handleAliasedPrefetchEntry(\n          navigatedAt,\n          state,\n          flightData,\n          urlWithCanonicalPathname,\n          mutable\n        )\n\n        // We didn't return new router state because we didn't apply the aliased entry for some reason.\n        // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n        // will create an on-demand prefetch entry.\n        if (result === false) {\n          return navigateReducer(state, { ...action, allowAliasing: false })\n        }\n\n        return result\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      const updatedCanonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n\n      const onlyHashChange =\n        !!hash &&\n        state.canonicalUrl.split('#', 1)[0] ===\n          updatedCanonicalUrl.split('#', 1)[0]\n\n      // If only the hash has changed, the server hasn't sent us any new data. We can just update\n      // the mutable properties responsible for URL and scroll handling and return early.\n      if (onlyHashChange) {\n        mutable.onlyHashChange = true\n        mutable.canonicalUrl = updatedCanonicalUrl\n        mutable.shouldScroll = shouldScroll\n        mutable.hashFragment = hash\n        mutable.scrollableSegments = []\n        return handleMutable(state, mutable)\n      }\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const normalizedFlightData of flightData) {\n        const {\n          pathToSegment: flightSegmentPath,\n          seedData,\n          head,\n          isHeadPartial,\n          isRootRender,\n        } = normalizedFlightData\n        let treePatch = normalizedFlightData.tree\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (\n            // This is just a paranoid check. When a route is PPRed, the server\n            // will send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via startPPRNavigation. The current structure is just\n            // an incremental step.\n            seedData &&\n            isRootRender &&\n            postponed\n          ) {\n            const task = startPPRNavigation(\n              navigatedAt,\n              currentCache,\n              currentTree,\n              treePatch,\n              seedData,\n              head,\n              isHeadPartial,\n              false,\n              scrollableSegments\n            )\n\n            if (task !== null) {\n              if (task.route === null) {\n                // Detected a change to the root layout. Perform an full-\n                // page navigation.\n                return handleExternalUrl(state, mutable, href, pendingPush)\n              }\n              // Use the tree computed by startPPRNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n              if (newCache !== null) {\n                // We've created a new Cache Node tree that contains a prefetched\n                // version of the next page. This can be rendered instantly.\n                mutable.cache = newCache\n              }\n              const dynamicRequestTree = task.dynamicRequestTree\n              if (dynamicRequestTree !== null) {\n                // The prefetched tree has dynamic holes in it. We initiate a\n                // dynamic request to fill them in.\n                //\n                // Do not block on the result. We'll immediately render the Cache\n                // Node tree and suspend on the dynamic parts. When the request\n                // comes in, we'll fill in missing data and ping React to\n                // re-render. Unlike the lazy fetching model in the non-PPR\n                // implementation, this is modeled as a single React update +\n                // streaming, rather than multiple top-level updates. (However,\n                // even in the new model, we'll still need to sometimes update the\n                // root multiple times per navigation, like if the server sends us\n                // a different response than we expected. For now, we revert back\n                // to the lazy fetching mechanism in that case.)\n                const dynamicRequest = fetchServerResponse(\n                  new URL(updatedCanonicalUrl, url.origin),\n                  {\n                    flightRouterState: dynamicRequestTree,\n                    nextUrl: state.nextUrl,\n                  }\n                )\n\n                listenForDynamicRequest(task, dynamicRequest)\n                // We store the dynamic request on the `lazyData` property of the CacheNode\n                // because we're not going to await the dynamic request here. Since we're not blocking\n                // on the dynamic request, `layout-router` will\n                // task.node.lazyData = dynamicRequest\n              } else {\n                // The prefetched tree does not contain dynamic holes  it's\n                // fully static. We can skip the dynamic request.\n              }\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = treePatch\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n              return handleExternalUrl(state, mutable, href, pendingPush)\n            }\n\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n\n              // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = navigatedAt\n            } else {\n              applied = applyFlightData(\n                navigatedAt,\n                currentCache,\n                cache,\n                normalizedFlightData,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n              // If we applied the cache, we update the \"current cache\" value so any other\n              // segments in the FlightDataPath will be able to reference the updated cache.\n              currentCache = cache\n            }\n\n            for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n              const scrollableSegmentPath = [\n                ...flightSegmentPath,\n                ...subSegment,\n              ]\n              // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n              if (\n                scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n                DEFAULT_SEGMENT_KEY\n              ) {\n                scrollableSegments.push(scrollableSegmentPath)\n              }\n            }\n          }\n\n          currentTree = newTree\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = updatedCanonicalUrl\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const {\n    serverResponse: { flightData, canonicalUrl: canonicalUrlOverride },\n    navigatedAt,\n  } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof flightData === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      flightData,\n      state.pushRef.pendingPush\n    )\n  }\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    const canonicalUrlOverrideHref = canonicalUrlOverride\n      ? createHrefFromUrl(canonicalUrlOverride)\n      : undefined\n\n    if (canonicalUrlOverrideHref) {\n      mutable.canonicalUrl = canonicalUrlOverrideHref\n    }\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  FlightSegmentPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport type {\n  CacheNode,\n  ChildSegmentMap,\n  HeadData,\n  LoadingModuleData,\n  ReadyCacheNode,\n} from '../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\nimport { matchSegment } from '../match-segments'\nimport { createRouterCacheKey } from './create-router-cache-key'\nimport type { FetchServerResponseResult } from './fetch-server-response'\nimport { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\nimport { DYNAMIC_STALETIME_MS } from './prefetch-cache-utils'\n\n// This is yet another tree type that is used to track pending promises that\n// need to be fulfilled once the dynamic data is received. The terminal nodes of\n// this tree represent the new Cache Node trees that were created during this\n// request. We can't use the Cache Node tree or Route State tree directly\n// because those include reused nodes, too. This tree is discarded as soon as\n// the navigation response is received.\ntype SPANavigationTask = {\n  // The router state that corresponds to the tree that this Task represents.\n  route: FlightRouterState\n  // The CacheNode that corresponds to the tree that this Task represents. If\n  // `children` is null (i.e. if this is a terminal task node), then `node`\n  // represents a brand new Cache Node tree, which way or may not need to be\n  // filled with dynamic data from the server.\n  node: CacheNode | null\n  // The tree sent to the server during the dynamic request. This is the\n  // same as `route`, except with the `refetch` marker set on dynamic segments.\n  // If all the segments are static, then this will be null, and no server\n  // request is required.\n  dynamicRequestTree: FlightRouterState | null\n  children: Map<string, SPANavigationTask> | null\n}\n\n// A special type used to bail out and trigger a full-page navigation.\ntype MPANavigationTask = {\n  // MPA tasks are distinguised from SPA tasks by having a null `route`.\n  route: null\n  node: null\n  dynamicRequestTree: null\n  children: null\n}\n\nconst MPA_NAVIGATION_TASK: MPANavigationTask = {\n  route: null,\n  node: null,\n  dynamicRequestTree: null,\n  children: null,\n}\n\nexport type Task = SPANavigationTask | MPANavigationTask\n\n// Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n// optimistic result of a navigation, using both the current Cache Node tree and\n// data that was prefetched prior to navigation.\n//\n// At the moment we call this function, we haven't yet received the navigation\n// response from the server. It could send back something completely different\n// from the tree that was prefetched  due to rewrites, default routes, parallel\n// routes, etc.\n//\n// But in most cases, it will return the same tree that we prefetched, just with\n// the dynamic holes filled in. So we optimistically assume this will happen,\n// and accept that the real result could be arbitrarily different.\n//\n// We'll reuse anything that was already in the previous tree, since that's what\n// the server does.\n//\n// New segments (ones that don't appear in the old tree) are assigned an\n// unresolved promise. The data for these promises will be fulfilled later, when\n// the navigation response is received.\n//\n// The tree can be rendered immediately after it is created (that's why this is\n// a synchronous function). Any new trees that do not have prefetch data will\n// suspend during rendering, until the dynamic data streams in.\n//\n// Returns a Task object, which contains both the updated Cache Node and a path\n// to the pending subtrees that need to be resolved by the navigation response.\n//\n// A return value of `null` means there were no changes, and the previous tree\n// can be reused without initiating a server request.\nexport function startPPRNavigation(\n  navigatedAt: number,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  const segmentPath: Array<FlightSegmentPath> = []\n  return updateCacheNodeOnNavigation(\n    navigatedAt,\n    oldCacheNode,\n    oldRouterState,\n    newRouterState,\n    false,\n    prefetchData,\n    prefetchHead,\n    isPrefetchHeadPartial,\n    isSamePageNavigation,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction updateCacheNodeOnNavigation(\n  navigatedAt: number,\n  oldCacheNode: CacheNode,\n  oldRouterState: FlightRouterState,\n  newRouterState: FlightRouterState,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  isSamePageNavigation: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task | null {\n  // Diff the old and new trees to reuse the shared layouts.\n  const oldRouterStateChildren = oldRouterState[1]\n  const newRouterStateChildren = newRouterState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  if (!didFindRootLayout) {\n    // We're currently traversing the part of the tree that was also part of\n    // the previous route. If we discover a root layout, then we don't need to\n    // trigger an MPA navigation. See beginRenderingNewRouteTree for context.\n    const isRootLayout = newRouterState[4] === true\n    if (isRootLayout) {\n      // Found a matching root layout.\n      didFindRootLayout = true\n    }\n  }\n\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n\n  // Clone the current set of segment children, even if they aren't active in\n  // the new tree.\n  // TODO: We currently retain all the inactive segments indefinitely, until\n  // there's an explicit refresh, or a parent layout is lazily refreshed. We\n  // rely on this for popstate navigations, which update the Router State Tree\n  // but do not eagerly perform a data fetch, because they expect the segment\n  // data to already be in the Cache Node tree. For highly static sites that\n  // are mostly read-only, this may happen only rarely, causing memory to\n  // leak. We should figure out a better model for the lifetime of inactive\n  // segments, so we can maintain instant back/forward navigations without\n  // leaking memory indefinitely.\n  const prefetchParallelRoutes = new Map(oldParallelRoutes)\n\n  // As we diff the trees, we may sometimes modify (copy-on-write, not mutate)\n  // the Route Tree that was returned by the server  for example, in the case\n  // of default parallel routes, we preserve the currently active segment. To\n  // avoid mutating the original tree, we clone the router state children along\n  // the return path.\n  let patchedRouterStateChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let taskChildren = null\n\n  // Most navigations require a request to fetch additional data from the\n  // server, either because the data was not already prefetched, or because the\n  // target route contains dynamic data that cannot be prefetched.\n  //\n  // However, if the target route is fully static, and it's already completely\n  // loaded into the segment cache, then we can skip the server request.\n  //\n  // This starts off as `false`, and is set to `true` if any of the child\n  // routes requires a dynamic request.\n  let needsDynamicRequest = false\n  // As we traverse the children, we'll construct a FlightRouterState that can\n  // be sent to the server to request the dynamic data. If it turns out that\n  // nothing in the subtree is dynamic (i.e. needsDynamicRequest is false at the\n  // end), then this will be discarded.\n  // TODO: We can probably optimize the format of this data structure to only\n  // include paths that are dynamic. Instead of reusing the\n  // FlightRouterState type.\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n\n  for (let parallelRouteKey in newRouterStateChildren) {\n    const newRouterStateChild: FlightRouterState =\n      newRouterStateChildren[parallelRouteKey]\n    const oldRouterStateChild: FlightRouterState | void =\n      oldRouterStateChildren[parallelRouteKey]\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    const prefetchDataChild: CacheNodeSeedData | void | null =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const newSegmentChild = newRouterStateChild[0]\n    const newSegmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      newSegmentChild,\n    ])\n    const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n\n    const oldSegmentChild =\n      oldRouterStateChild !== undefined ? oldRouterStateChild[0] : undefined\n\n    const oldCacheNodeChild =\n      oldSegmentMapChild !== undefined\n        ? oldSegmentMapChild.get(newSegmentKeyChild)\n        : undefined\n\n    let taskChild: Task | null\n    if (newSegmentChild === DEFAULT_SEGMENT_KEY) {\n      // This is another kind of leaf segment  a default route.\n      //\n      // Default routes have special behavior. When there's no matching segment\n      // for a parallel route, Next.js preserves the currently active segment\n      // during a client navigation  but not for initial render. The server\n      // leaves it to the client to account for this. So we need to handle\n      // it here.\n      if (oldRouterStateChild !== undefined) {\n        // Reuse the existing Router State for this segment. We spawn a \"task\"\n        // just to keep track of the updated router state; unlike most, it's\n        // already fulfilled and won't be affected by the dynamic response.\n        taskChild = spawnReusedTask(oldRouterStateChild)\n      } else {\n        // There's no currently active segment. Switch to the \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else if (\n      isSamePageNavigation &&\n      // Check if this is a page segment.\n      // TODO: We're not consistent about how we do this check. Some places\n      // check if the segment starts with PAGE_SEGMENT_KEY, but most seem to\n      // check if there any any children, which is why I'm doing it here. We\n      // should probably encode an empty children set as `null` though. Either\n      // way, we should update all the checks to be consistent.\n      Object.keys(newRouterStateChild[1]).length === 0\n    ) {\n      // We special case navigations to the exact same URL as the current\n      // location. It's a common UI pattern for apps to refresh when you click a\n      // link to the current page. So when this happens, we refresh the dynamic\n      // data in the page segments.\n      //\n      // Note that this does not apply if the any part of the hash or search\n      // query has changed. This might feel a bit weird but it makes more sense\n      // when you consider that the way to trigger this behavior is to click\n      // the same link multiple times.\n      //\n      // TODO: We should probably refresh the *entire* route when this case\n      // occurs, not just the page segments. Essentially treating it the same as\n      // a refresh() triggered by an action, which is the more explicit way of\n      // modeling the UI pattern described above.\n      //\n      // Also note that this only refreshes the dynamic data, not static/\n      // cached data. If the page segment is fully static and prefetched, the\n      // request is skipped. (This is also how refresh() works.)\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    } else if (\n      oldRouterStateChild !== undefined &&\n      oldSegmentChild !== undefined &&\n      matchSegment(newSegmentChild, oldSegmentChild)\n    ) {\n      if (\n        oldCacheNodeChild !== undefined &&\n        oldRouterStateChild !== undefined\n      ) {\n        // This segment exists in both the old and new trees. Recursively update\n        // the children.\n        taskChild = updateCacheNodeOnNavigation(\n          navigatedAt,\n          oldCacheNodeChild,\n          oldRouterStateChild,\n          newRouterStateChild,\n          didFindRootLayout,\n          prefetchDataChild,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          isSamePageNavigation,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      } else {\n        // There's no existing Cache Node for this segment. Switch to the\n        // \"create\" path.\n        taskChild = beginRenderingNewRouteTree(\n          navigatedAt,\n          oldRouterStateChild,\n          newRouterStateChild,\n          oldCacheNodeChild,\n          didFindRootLayout,\n          prefetchDataChild !== undefined ? prefetchDataChild : null,\n          prefetchHead,\n          isPrefetchHeadPartial,\n          newSegmentPathChild,\n          scrollableSegmentsResult\n        )\n      }\n    } else {\n      // This is a new tree. Switch to the \"create\" path.\n      taskChild = beginRenderingNewRouteTree(\n        navigatedAt,\n        oldRouterStateChild,\n        newRouterStateChild,\n        oldCacheNodeChild,\n        didFindRootLayout,\n        prefetchDataChild !== undefined ? prefetchDataChild : null,\n        prefetchHead,\n        isPrefetchHeadPartial,\n        newSegmentPathChild,\n        scrollableSegmentsResult\n      )\n    }\n\n    if (taskChild !== null) {\n      // Recursively propagate up the child tasks.\n\n      if (taskChild.route === null) {\n        // One of the child tasks discovered a change to the root layout.\n        // Immediately unwind from this recursive traversal.\n        return MPA_NAVIGATION_TASK\n      }\n\n      if (taskChildren === null) {\n        taskChildren = new Map()\n      }\n      taskChildren.set(parallelRouteKey, taskChild)\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(newSegmentKeyChild, newCacheNodeChild)\n        prefetchParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n\n      // The child tree's route state may be different from the prefetched\n      // route sent by the server. We need to clone it as we traverse back up\n      // the tree.\n      const taskChildRoute = taskChild.route\n      patchedRouterStateChildren[parallelRouteKey] = taskChildRoute\n\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = taskChildRoute\n      }\n    } else {\n      // The child didn't change. We can use the prefetched router state.\n      patchedRouterStateChildren[parallelRouteKey] = newRouterStateChild\n      dynamicRequestTreeChildren[parallelRouteKey] = newRouterStateChild\n    }\n  }\n\n  if (taskChildren === null) {\n    // No new tasks were spawned.\n    return null\n  }\n\n  const newCacheNode: ReadyCacheNode = {\n    lazyData: null,\n    rsc: oldCacheNode.rsc,\n    // We intentionally aren't updating the prefetchRsc field, since this node\n    // is already part of the current tree, because it would be weird for\n    // prefetch data to be newer than the final data. It probably won't ever be\n    // observable anyway, but it could happen if the segment is unmounted then\n    // mounted again, because LayoutRouter will momentarily switch to rendering\n    // prefetchRsc, via useDeferredValue.\n    prefetchRsc: oldCacheNode.prefetchRsc,\n    head: oldCacheNode.head,\n    prefetchHead: oldCacheNode.prefetchHead,\n    loading: oldCacheNode.loading,\n\n    // Everything is cloned except for the children, which we computed above.\n    parallelRoutes: prefetchParallelRoutes,\n\n    navigatedAt,\n  }\n\n  return {\n    // Return a cloned copy of the router state with updated children.\n    route: patchRouterStateWithNewChildren(\n      newRouterState,\n      patchedRouterStateChildren\n    ),\n    node: newCacheNode,\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(\n          newRouterState,\n          dynamicRequestTreeChildren\n        )\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction beginRenderingNewRouteTree(\n  navigatedAt: number,\n  oldRouterState: FlightRouterState | void,\n  newRouterState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  didFindRootLayout: boolean,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): Task {\n  if (!didFindRootLayout) {\n    // The route tree changed before we reached a layout. (The highest-level\n    // layout in a route tree is referred to as the \"root\" layout.) This could\n    // mean that we're navigating between two different root layouts. When this\n    // happens, we perform a full-page (MPA-style) navigation.\n    //\n    // However, the algorithm for deciding where to start rendering a route\n    // (i.e. the one performed in order to reach this function) is stricter\n    // than the one used to detect a change in the root layout. So just because\n    // we're re-rendering a segment outside of the root layout does not mean we\n    // should trigger a full-page navigation.\n    //\n    // Specifically, we handle dynamic parameters differently: two segments are\n    // considered the same even if their parameter values are different.\n    //\n    // Refer to isNavigatingToNewRootLayout for details.\n    //\n    // Note that we only have to perform this extra traversal if we didn't\n    // already discover a root layout in the part of the tree that is unchanged.\n    // In the common case, this branch is skipped completely.\n    if (\n      oldRouterState === undefined ||\n      isNavigatingToNewRootLayout(oldRouterState, newRouterState)\n    ) {\n      // The root layout changed. Perform a full-page navigation.\n      return MPA_NAVIGATION_TASK\n    }\n  }\n  return createCacheNodeOnNavigation(\n    navigatedAt,\n    newRouterState,\n    existingCacheNode,\n    prefetchData,\n    possiblyPartialPrefetchHead,\n    isPrefetchHeadPartial,\n    segmentPath,\n    scrollableSegmentsResult\n  )\n}\n\nfunction createCacheNodeOnNavigation(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  existingCacheNode: CacheNode | void,\n  prefetchData: CacheNodeSeedData | null,\n  possiblyPartialPrefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Same traversal as updateCacheNodeNavigation, but we switch to this path\n  // once we reach the part of the tree that was not in the previous route. We\n  // don't need to diff against the old tree, we just need to create a new one.\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const routerStateChildren = routerState[1]\n  const isLeafSegment = Object.keys(routerStateChildren).length === 0\n\n  // Even we're rendering inside the \"new\" part of the target tree, we may have\n  // a locally cached segment that we can reuse. This may come from either 1)\n  // the CacheNode tree, which lives in React state and is populated by previous\n  // navigations; or 2) the prefetch cache, which is a separate cache that is\n  // populated by prefetches.\n  let rsc: React.ReactNode\n  let loading: LoadingModuleData | Promise<LoadingModuleData>\n  let head: HeadData | null\n  let cacheNodeNavigatedAt: number\n  if (\n    existingCacheNode !== undefined &&\n    // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n    // the experimental.staleTimes.dynamic config. When set, we'll avoid\n    // refetching dynamic data if it was fetched within the given threshold.\n    existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n  ) {\n    // We have an existing CacheNode for this segment, and it's not stale. We\n    // should reuse it rather than request a new one.\n    rsc = existingCacheNode.rsc\n    loading = existingCacheNode.loading\n    head = existingCacheNode.head\n\n    // Don't update the navigatedAt timestamp, since we're reusing stale data.\n    cacheNodeNavigatedAt = existingCacheNode.navigatedAt\n  } else if (prefetchData !== null) {\n    // There's no existing CacheNode for this segment, but we do have prefetch\n    // data. If the prefetch data is fully static (i.e. does not contain any\n    // dynamic holes), we don't need to request it from the server.\n    rsc = prefetchData[1]\n    loading = prefetchData[3]\n    head = isLeafSegment ? possiblyPartialPrefetchHead : null\n    // Even though we're accessing the data from the prefetch cache, this is\n    // conceptually a new segment, not a reused one. So we should update the\n    // navigatedAt timestamp.\n    cacheNodeNavigatedAt = navigatedAt\n    const isPrefetchRscPartial = prefetchData[4]\n    if (\n      // Check if the segment data is partial\n      isPrefetchRscPartial ||\n      // Check if the head is partial (only relevant if this is a leaf segment)\n      (isPrefetchHeadPartial && isLeafSegment)\n    ) {\n      // We only have partial data from this segment. Like missing segments, we\n      // must request the full data from the server.\n      return spawnPendingTask(\n        navigatedAt,\n        routerState,\n        prefetchData,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPath,\n        scrollableSegmentsResult\n      )\n    } else {\n      // The prefetch data is fully static, so we can omit it from the\n      // navigation request.\n    }\n  } else {\n    // There's no prefetch for this segment. Everything from this point will be\n    // requested from the server, even if there are static children below it.\n    // Create a terminal task node that will later be fulfilled by\n    // server response.\n    return spawnPendingTask(\n      navigatedAt,\n      routerState,\n      null,\n      possiblyPartialPrefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    )\n  }\n\n  // We already have a full segment we can render, so we don't need to request a\n  // new one from the server. Keep traversing down the tree until we reach\n  // something that requires a dynamic request.\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n  const taskChildren = new Map()\n  const existingCacheNodeChildren =\n    existingCacheNode !== undefined ? existingCacheNode.parallelRoutes : null\n  const cacheNodeChildren = new Map(existingCacheNodeChildren)\n  let dynamicRequestTreeChildren: {\n    [parallelRouteKey: string]: FlightRouterState\n  } = {}\n  let needsDynamicRequest = false\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  } else {\n    for (let parallelRouteKey in routerStateChildren) {\n      const routerStateChild: FlightRouterState =\n        routerStateChildren[parallelRouteKey]\n      const prefetchDataChild: CacheNodeSeedData | void | null =\n        prefetchDataChildren !== null\n          ? prefetchDataChildren[parallelRouteKey]\n          : null\n      const existingSegmentMapChild =\n        existingCacheNodeChildren !== null\n          ? existingCacheNodeChildren.get(parallelRouteKey)\n          : undefined\n      const segmentChild = routerStateChild[0]\n      const segmentPathChild = segmentPath.concat([\n        parallelRouteKey,\n        segmentChild,\n      ])\n      const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n      const existingCacheNodeChild =\n        existingSegmentMapChild !== undefined\n          ? existingSegmentMapChild.get(segmentKeyChild)\n          : undefined\n\n      const taskChild = createCacheNodeOnNavigation(\n        navigatedAt,\n        routerStateChild,\n        existingCacheNodeChild,\n        prefetchDataChild,\n        possiblyPartialPrefetchHead,\n        isPrefetchHeadPartial,\n        segmentPathChild,\n        scrollableSegmentsResult\n      )\n      taskChildren.set(parallelRouteKey, taskChild)\n      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n      if (dynamicRequestTreeChild !== null) {\n        // Something in the child tree is dynamic.\n        needsDynamicRequest = true\n        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n      } else {\n        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n      }\n      const newCacheNodeChild = taskChild.node\n      if (newCacheNodeChild !== null) {\n        const newSegmentMapChild: ChildSegmentMap = new Map()\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  return {\n    // Since we're inside a new route tree, unlike the\n    // `updateCacheNodeOnNavigation` path, the router state on the children\n    // tasks is always the same as the router state we pass in. So we don't need\n    // to clone/modify it.\n    route: routerState,\n    node: {\n      lazyData: null,\n      // Since this segment is already full, we don't need to use the\n      // `prefetchRsc` field.\n      rsc,\n      prefetchRsc: null,\n      head,\n      prefetchHead: null,\n      loading,\n      parallelRoutes: cacheNodeChildren,\n      navigatedAt: cacheNodeNavigatedAt,\n    },\n    dynamicRequestTree: needsDynamicRequest\n      ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n      : null,\n    children: taskChildren,\n  }\n}\n\nfunction patchRouterStateWithNewChildren(\n  baseRouterState: FlightRouterState,\n  newChildren: { [parallelRouteKey: string]: FlightRouterState }\n): FlightRouterState {\n  const clone: FlightRouterState = [baseRouterState[0], newChildren]\n  // Based on equivalent logic in apply-router-state-patch-to-tree, but should\n  // confirm whether we need to copy all of these fields. Not sure the server\n  // ever sends, e.g. the refetch marker.\n  if (2 in baseRouterState) {\n    clone[2] = baseRouterState[2]\n  }\n  if (3 in baseRouterState) {\n    clone[3] = baseRouterState[3]\n  }\n  if (4 in baseRouterState) {\n    clone[4] = baseRouterState[4]\n  }\n  return clone\n}\n\nfunction spawnPendingTask(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): SPANavigationTask {\n  // Create a task that will later be fulfilled by data from the server.\n\n  // Clone the prefetched route tree and the `refetch` marker to it. We'll send\n  // this to the server so it knows where to start rendering.\n  const dynamicRequestTree = patchRouterStateWithNewChildren(\n    routerState,\n    routerState[1]\n  )\n  dynamicRequestTree[3] = 'refetch'\n\n  const newTask: Task = {\n    route: routerState,\n\n    // Corresponds to the part of the route that will be rendered on the server.\n    node: createPendingCacheNode(\n      navigatedAt,\n      routerState,\n      prefetchData,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPath,\n      scrollableSegmentsResult\n    ),\n    // Because this is non-null, and it gets propagated up through the parent\n    // tasks, the root task will know that it needs to perform a server request.\n    dynamicRequestTree,\n    children: null,\n  }\n  return newTask\n}\n\nfunction spawnReusedTask(reusedRouterState: FlightRouterState): Task {\n  // Create a task that reuses an existing segment, e.g. when reusing\n  // the current active segment in place of a default route.\n  return {\n    route: reusedRouterState,\n    node: null,\n    dynamicRequestTree: null,\n    children: null,\n  }\n}\n\n// Writes a dynamic server response into the tree created by\n// updateCacheNodeOnNavigation. All pending promises that were spawned by the\n// navigation will be resolved, either with dynamic data from the server, or\n// `null` to indicate that the data is missing.\n//\n// A `null` value will trigger a lazy fetch during render, which will then patch\n// up the tree using the same mechanism as the non-PPR implementation\n// (serverPatchReducer).\n//\n// Usually, the server will respond with exactly the subset of data that we're\n// waiting for  everything below the nearest shared layout. But technically,\n// the server can return anything it wants.\n//\n// This does _not_ create a new tree; it modifies the existing one in place.\n// Which means it must follow the Suspense rules of cache safety.\nexport function listenForDynamicRequest(\n  task: SPANavigationTask,\n  responsePromise: Promise<FetchServerResponseResult>\n) {\n  responsePromise.then(\n    ({ flightData }: FetchServerResponseResult) => {\n      if (typeof flightData === 'string') {\n        // Happens when navigating to page in `pages` from `app`. We shouldn't\n        // get here because should have already handled this during\n        // the prefetch.\n        return\n      }\n      for (const normalizedFlightData of flightData) {\n        const {\n          segmentPath,\n          tree: serverRouterState,\n          seedData: dynamicData,\n          head: dynamicHead,\n        } = normalizedFlightData\n\n        if (!dynamicData) {\n          // This shouldn't happen. PPR should always send back a response.\n          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n          // this might return null.\n          continue\n        }\n\n        writeDynamicDataIntoPendingTask(\n          task,\n          segmentPath,\n          serverRouterState,\n          dynamicData,\n          dynamicHead\n        )\n      }\n\n      // Now that we've exhausted all the data we received from the server, if\n      // there are any remaining pending tasks in the tree, abort them now.\n      // If there's any missing data, it will trigger a lazy fetch.\n      abortTask(task, null)\n    },\n    (error: any) => {\n      // This will trigger an error during render\n      abortTask(task, error)\n    }\n  )\n}\n\nfunction writeDynamicDataIntoPendingTask(\n  rootTask: SPANavigationTask,\n  segmentPath: FlightSegmentPath,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData\n) {\n  // The data sent by the server represents only a subtree of the app. We need\n  // to find the part of the task tree that matches the server response, and\n  // fulfill it using the dynamic data.\n  //\n  // segmentPath represents the parent path of subtree. It's a repeating pattern\n  // of parallel route key and segment:\n  //\n  //   [string, Segment, string, Segment, string, Segment, ...]\n  //\n  // Iterate through the path and finish any tasks that match this payload.\n  let task = rootTask\n  for (let i = 0; i < segmentPath.length; i += 2) {\n    const parallelRouteKey: string = segmentPath[i]\n    const segment: Segment = segmentPath[i + 1]\n    const taskChildren = task.children\n    if (taskChildren !== null) {\n      const taskChild = taskChildren.get(parallelRouteKey)\n      if (taskChild !== undefined) {\n        const taskSegment = taskChild.route[0]\n        if (matchSegment(segment, taskSegment)) {\n          // Found a match for this task. Keep traversing down the task tree.\n          task = taskChild\n          continue\n        }\n      }\n    }\n    // We didn't find a child task that matches the server data. Exit. We won't\n    // abort the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n    return\n  }\n\n  finishTaskUsingDynamicDataPayload(\n    task,\n    serverRouterState,\n    dynamicData,\n    dynamicHead\n  )\n}\n\nfunction finishTaskUsingDynamicDataPayload(\n  task: SPANavigationTask,\n  serverRouterState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData\n) {\n  if (task.dynamicRequestTree === null) {\n    // Everything in this subtree is already complete. Bail out.\n    return\n  }\n\n  // dynamicData may represent a larger subtree than the task. Before we can\n  // finish the task, we need to line them up.\n  const taskChildren = task.children\n  const taskNode = task.node\n  if (taskChildren === null) {\n    // We've reached the leaf node of the pending task. The server data tree\n    // lines up the pending Cache Node tree. We can now switch to the\n    // normal algorithm.\n    if (taskNode !== null) {\n      finishPendingCacheNode(\n        taskNode,\n        task.route,\n        serverRouterState,\n        dynamicData,\n        dynamicHead\n      )\n      // Set this to null to indicate that this task is now complete.\n      task.dynamicRequestTree = null\n    }\n    return\n  }\n  // The server returned more data than we need to finish the task. Skip over\n  // the extra segments until we reach the leaf task node.\n  const serverChildren = serverRouterState[1]\n  const dynamicDataChildren = dynamicData[2]\n\n  for (const parallelRouteKey in serverRouterState) {\n    const serverRouterStateChild: FlightRouterState =\n      serverChildren[parallelRouteKey]\n    const dynamicDataChild: CacheNodeSeedData | null | void =\n      dynamicDataChildren[parallelRouteKey]\n\n    const taskChild = taskChildren.get(parallelRouteKey)\n    if (taskChild !== undefined) {\n      const taskSegment = taskChild.route[0]\n      if (\n        matchSegment(serverRouterStateChild[0], taskSegment) &&\n        dynamicDataChild !== null &&\n        dynamicDataChild !== undefined\n      ) {\n        // Found a match for this task. Keep traversing down the task tree.\n        return finishTaskUsingDynamicDataPayload(\n          taskChild,\n          serverRouterStateChild,\n          dynamicDataChild,\n          dynamicHead\n        )\n      }\n    }\n    // We didn't find a child task that matches the server data. We won't abort\n    // the task, though, because a different FlightDataPath may be able to\n    // fulfill it (see loop in listenForDynamicRequest). We only abort tasks\n    // once we've run out of data.\n  }\n}\n\nfunction createPendingCacheNode(\n  navigatedAt: number,\n  routerState: FlightRouterState,\n  prefetchData: CacheNodeSeedData | null,\n  prefetchHead: HeadData | null,\n  isPrefetchHeadPartial: boolean,\n  segmentPath: FlightSegmentPath,\n  scrollableSegmentsResult: Array<FlightSegmentPath>\n): ReadyCacheNode {\n  const routerStateChildren = routerState[1]\n  const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n\n  const parallelRoutes = new Map()\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const prefetchDataChild: CacheNodeSeedData | null | void =\n      prefetchDataChildren !== null\n        ? prefetchDataChildren[parallelRouteKey]\n        : null\n\n    const segmentChild = routerStateChild[0]\n    const segmentPathChild = segmentPath.concat([\n      parallelRouteKey,\n      segmentChild,\n    ])\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n\n    const newCacheNodeChild = createPendingCacheNode(\n      navigatedAt,\n      routerStateChild,\n      prefetchDataChild === undefined ? null : prefetchDataChild,\n      prefetchHead,\n      isPrefetchHeadPartial,\n      segmentPathChild,\n      scrollableSegmentsResult\n    )\n\n    const newSegmentMapChild: ChildSegmentMap = new Map()\n    newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n    parallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n  }\n\n  // The head is assigned to every leaf segment delivered by the server. Based\n  // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n  const isLeafSegment = parallelRoutes.size === 0\n\n  if (isLeafSegment) {\n    // The segment path of every leaf segment (i.e. page) is collected into\n    // a result array. This is used by the LayoutRouter to scroll to ensure that\n    // new pages are visible after a navigation.\n    // TODO: We should use a string to represent the segment path instead of\n    // an array. We already use a string representation for the path when\n    // accessing the Segment Cache, so we can use the same one.\n    scrollableSegmentsResult.push(segmentPath)\n  }\n\n  const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null\n  const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n  return {\n    lazyData: null,\n    parallelRoutes: parallelRoutes,\n\n    prefetchRsc: maybePrefetchRsc !== undefined ? maybePrefetchRsc : null,\n    prefetchHead: isLeafSegment ? prefetchHead : [null, null],\n\n    // TODO: Technically, a loading boundary could contain dynamic data. We must\n    // have separate `loading` and `prefetchLoading` fields to handle this, like\n    // we do for the segment data and head.\n    loading: maybePrefetchLoading !== undefined ? maybePrefetchLoading : null,\n\n    // Create a deferred promise. This will be fulfilled once the dynamic\n    // response is received from the server.\n    rsc: createDeferredRsc() as React.ReactNode,\n    head: isLeafSegment ? (createDeferredRsc() as React.ReactNode) : null,\n\n    navigatedAt,\n  }\n}\n\nfunction finishPendingCacheNode(\n  cacheNode: CacheNode,\n  taskState: FlightRouterState,\n  serverState: FlightRouterState,\n  dynamicData: CacheNodeSeedData,\n  dynamicHead: HeadData\n): void {\n  // Writes a dynamic response into an existing Cache Node tree. This does _not_\n  // create a new tree, it updates the existing tree in-place. So it must follow\n  // the Suspense rules of cache safety  it can resolve pending promises, but\n  // it cannot overwrite existing data. It can add segments to the tree (because\n  // a missing segment will cause the layout router to suspend).\n  // but it cannot delete them.\n  //\n  // We must resolve every promise in the tree, or else it will suspend\n  // indefinitely. If we did not receive data for a segment, we will resolve its\n  // data promise to `null` to trigger a lazy fetch during render.\n  const taskStateChildren = taskState[1]\n  const serverStateChildren = serverState[1]\n  const dataChildren = dynamicData[2]\n\n  // The router state that we traverse the tree with (taskState) is the same one\n  // that we used to construct the pending Cache Node tree. That way we're sure\n  // to resolve all the pending promises.\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in taskStateChildren) {\n    const taskStateChild: FlightRouterState =\n      taskStateChildren[parallelRouteKey]\n    const serverStateChild: FlightRouterState | void =\n      serverStateChildren[parallelRouteKey]\n    const dataChild: CacheNodeSeedData | null | void =\n      dataChildren[parallelRouteKey]\n\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    const taskSegmentChild = taskStateChild[0]\n    const taskSegmentKeyChild = createRouterCacheKey(taskSegmentChild)\n\n    const cacheNodeChild =\n      segmentMapChild !== undefined\n        ? segmentMapChild.get(taskSegmentKeyChild)\n        : undefined\n\n    if (cacheNodeChild !== undefined) {\n      if (\n        serverStateChild !== undefined &&\n        matchSegment(taskSegmentChild, serverStateChild[0])\n      ) {\n        if (dataChild !== undefined && dataChild !== null) {\n          // This is the happy path. Recursively update all the children.\n          finishPendingCacheNode(\n            cacheNodeChild,\n            taskStateChild,\n            serverStateChild,\n            dataChild,\n            dynamicHead\n          )\n        } else {\n          // The server never returned data for this segment. Trigger a lazy\n          // fetch during render. This shouldn't happen because the Route Tree\n          // and the Seed Data tree sent by the server should always be the same\n          // shape when part of the same server response.\n          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n        }\n      } else {\n        // The server never returned data for this segment. Trigger a lazy\n        // fetch during render.\n        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n      }\n    } else {\n      // The server response matches what was expected to receive, but there's\n      // no matching Cache Node in the task tree. This is a bug in the\n      // implementation because we should have created a node for every\n      // segment in the tree that's associated with this task.\n    }\n  }\n\n  // Use the dynamic data from the server to fulfill the deferred RSC promise\n  // on the Cache Node.\n  const rsc = cacheNode.rsc\n  const dynamicSegmentData = dynamicData[1]\n  if (rsc === null) {\n    // This is a lazy cache node. We can overwrite it. This is only safe\n    // because we know that the LayoutRouter suspends if `rsc` is `null`.\n    cacheNode.rsc = dynamicSegmentData\n  } else if (isDeferredRsc(rsc)) {\n    // This is a deferred RSC promise. We can fulfill it with the data we just\n    // received from the server. If it was already resolved by a different\n    // navigation, then this does nothing because we can't overwrite data.\n    rsc.resolve(dynamicSegmentData)\n  } else {\n    // This is not a deferred RSC promise, nor is it empty, so it must have\n    // been populated by a different navigation. We must not overwrite it.\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved with the dynamic head from\n  // the server.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(dynamicHead)\n  }\n}\n\nexport function abortTask(task: SPANavigationTask, error: any): void {\n  const cacheNode = task.node\n  if (cacheNode === null) {\n    // This indicates the task is already complete.\n    return\n  }\n\n  const taskChildren = task.children\n  if (taskChildren === null) {\n    // Reached the leaf task node. This is the root of a pending cache\n    // node tree.\n    abortPendingCacheNode(task.route, cacheNode, error)\n  } else {\n    // This is an intermediate task node. Keep traversing until we reach a\n    // task node with no children. That will be the root of the cache node tree\n    // that needs to be resolved.\n    for (const taskChild of taskChildren.values()) {\n      abortTask(taskChild, error)\n    }\n  }\n\n  // Set this to null to indicate that this task is now complete.\n  task.dynamicRequestTree = null\n}\n\nfunction abortPendingCacheNode(\n  routerState: FlightRouterState,\n  cacheNode: CacheNode,\n  error: any\n): void {\n  // For every pending segment in the tree, resolve its `rsc` promise to `null`\n  // to trigger a lazy fetch during render.\n  //\n  // Or, if an error object is provided, it will error instead.\n  const routerStateChildren = routerState[1]\n  const parallelRoutes = cacheNode.parallelRoutes\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentMapChild = parallelRoutes.get(parallelRouteKey)\n    if (segmentMapChild === undefined) {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n      continue\n    }\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n    if (cacheNodeChild !== undefined) {\n      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n    } else {\n      // This shouldn't happen because we're traversing the same tree that was\n      // used to construct the cache nodes in the first place.\n    }\n  }\n  const rsc = cacheNode.rsc\n  if (isDeferredRsc(rsc)) {\n    if (error === null) {\n      // This will trigger a lazy fetch during render.\n      rsc.resolve(null)\n    } else {\n      // This will trigger an error during rendering.\n      rsc.reject(error)\n    }\n  }\n\n  // Check if this is a leaf segment. If so, it will have a `head` property with\n  // a pending promise that needs to be resolved. If an error was provided, we\n  // will not resolve it with an error, since this is rendered at the root of\n  // the app. We want the segment to error, not the entire app.\n  const head = cacheNode.head\n  if (isDeferredRsc(head)) {\n    head.resolve(null)\n  }\n}\n\nexport function updateCacheNodeOnPopstateRestoration(\n  oldCacheNode: CacheNode,\n  routerState: FlightRouterState\n): ReadyCacheNode {\n  // A popstate navigation reads data from the local cache. It does not issue\n  // new network requests (unless the cache entries have been evicted). So, we\n  // update the cache to drop the prefetch data for any segment whose dynamic\n  // data was already received. This prevents an unnecessary flash back to PPR\n  // state during a back/forward navigation.\n  //\n  // This function clones the entire cache node tree and sets the `prefetchRsc`\n  // field to `null` to prevent it from being rendered. We can't mutate the node\n  // in place because this is a concurrent data structure.\n\n  const routerStateChildren = routerState[1]\n  const oldParallelRoutes = oldCacheNode.parallelRoutes\n  const newParallelRoutes = new Map(oldParallelRoutes)\n  for (let parallelRouteKey in routerStateChildren) {\n    const routerStateChild: FlightRouterState =\n      routerStateChildren[parallelRouteKey]\n    const segmentChild = routerStateChild[0]\n    const segmentKeyChild = createRouterCacheKey(segmentChild)\n    const oldSegmentMapChild = oldParallelRoutes.get(parallelRouteKey)\n    if (oldSegmentMapChild !== undefined) {\n      const oldCacheNodeChild = oldSegmentMapChild.get(segmentKeyChild)\n      if (oldCacheNodeChild !== undefined) {\n        const newCacheNodeChild = updateCacheNodeOnPopstateRestoration(\n          oldCacheNodeChild,\n          routerStateChild\n        )\n        const newSegmentMapChild = new Map(oldSegmentMapChild)\n        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n        newParallelRoutes.set(parallelRouteKey, newSegmentMapChild)\n      }\n    }\n  }\n\n  // Only show prefetched data if the dynamic data is still pending.\n  //\n  // Tehnically, what we're actually checking is whether the dynamic network\n  // response was received. But since it's a streaming response, this does not\n  // mean that all the dynamic data has fully streamed in. It just means that\n  // _some_ of the dynamic data was received. But as a heuristic, we assume that\n  // the rest dynamic data will stream in quickly, so it's still better to skip\n  // the prefetch state.\n  const rsc = oldCacheNode.rsc\n  const shouldUsePrefetch = isDeferredRsc(rsc) && rsc.status === 'pending'\n\n  return {\n    lazyData: null,\n    rsc,\n    head: oldCacheNode.head,\n\n    prefetchHead: shouldUsePrefetch ? oldCacheNode.prefetchHead : [null, null],\n    prefetchRsc: shouldUsePrefetch ? oldCacheNode.prefetchRsc : null,\n    loading: oldCacheNode.loading,\n\n    // These are the cloned children we computed above\n    parallelRoutes: newParallelRoutes,\n\n    navigatedAt: oldCacheNode.navigatedAt,\n  }\n}\n\nconst DEFERRED = Symbol()\n\ntype PendingDeferredRsc = Promise<React.ReactNode> & {\n  status: 'pending'\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype FulfilledDeferredRsc = Promise<React.ReactNode> & {\n  status: 'fulfilled'\n  value: React.ReactNode\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype RejectedDeferredRsc = Promise<React.ReactNode> & {\n  status: 'rejected'\n  reason: any\n  resolve: (value: React.ReactNode) => void\n  reject: (error: any) => void\n  tag: Symbol\n}\n\ntype DeferredRsc =\n  | PendingDeferredRsc\n  | FulfilledDeferredRsc\n  | RejectedDeferredRsc\n\n// This type exists to distinguish a DeferredRsc from a Flight promise. It's a\n// compromise to avoid adding an extra field on every Cache Node, which would be\n// awkward because the pre-PPR parts of codebase would need to account for it,\n// too. We can remove it once type Cache Node type is more settled.\nfunction isDeferredRsc(value: any): value is DeferredRsc {\n  return value && value.tag === DEFERRED\n}\n\nfunction createDeferredRsc(): PendingDeferredRsc {\n  let resolve: any\n  let reject: any\n  const pendingRsc = new Promise<React.ReactNode>((res, rej) => {\n    resolve = res\n    reject = rej\n  }) as PendingDeferredRsc\n  pendingRsc.status = 'pending'\n  pendingRsc.resolve = (value: React.ReactNode) => {\n    if (pendingRsc.status === 'pending') {\n      const fulfilledRsc: FulfilledDeferredRsc = pendingRsc as any\n      fulfilledRsc.status = 'fulfilled'\n      fulfilledRsc.value = value\n      resolve(value)\n    }\n  }\n  pendingRsc.reject = (error: any) => {\n    if (pendingRsc.status === 'pending') {\n      const rejectedRsc: RejectedDeferredRsc = pendingRsc as any\n      rejectedRsc.status = 'rejected'\n      rejectedRsc.reason = error\n      reject(error)\n    }\n  }\n  pendingRsc.tag = DEFERRED\n  return pendingRsc\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, tree } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  const treeToRestore = tree || state.tree\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    prefetchCache: state.prefetchCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightDataPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\n\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(\n  flightSegmentPath: FlightDataPath,\n  flightRouterState: FlightRouterState\n): boolean {\n  const [segment, parallelRoutes] = flightRouterState\n  // TODO-APP: Check if `as` can be replaced.\n  const [currentSegment, parallelRouteKey] = flightSegmentPath as [\n    Segment,\n    string,\n  ]\n\n  // Check if current segment matches the existing segment.\n  if (!matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true\n    }\n\n    // If the existing segment did not match soft navigation is triggered.\n    return false\n  }\n  const lastSegment = flightSegmentPath.length <= 2\n\n  if (lastSegment) {\n    return false\n  }\n\n  return shouldHardNavigate(\n    getNextFlightSegmentPath(flightSegmentPath),\n    parallelRoutes[parallelRouteKey]\n  )\n}\n","import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_PREFETCH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { prefetchReducer } from './reducers/prefetch-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_PREFETCH: {\n      return prefetchReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n","import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport { revalidateEntireCache } from '../../segment-cache'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  const navigatedAt = Date.now()\n  return cache.lazyData.then(\n    async ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const loading = cacheNodeSeedData[3]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            undefined\n          )\n          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n            revalidateEntireCache(state.nextUrl, newTree)\n          } else {\n            mutable.prefetchCache = new Map()\n          }\n        }\n\n        await refreshInactiveParallelSegments({\n          navigatedAt,\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","computeCacheBustingSearchParam","uniqueCacheKey","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","pairs","rawQuery","startsWith","slice","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","parallelRoutesKeys","key","unshift","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","cacheNode","item","serverActionReducer","createFromFetch","createFromFetchBrowser","NO_REVALIDATED_PARTS","paths","tag","cookie","state","action","resolve","reject","mutable","currentTree","tree","preserveCustomHistoryState","nextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","fetchServerAction","info","usedArgs","body","res","redirectHeader","redirectType","isPrerender","revalidatedParts","revalidatedHeader","contentType","isRscResponse","actionResult","actionFlightData","response","encodeReply","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","extractInfoFromServerReferenceId","type","omitUnusedArgs","fetch","canonicalUrl","method","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","prepareFlightRouterStateForRequest","process","unrecognizedActionHeader","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","location","_redirectType","RedirectType","replace","undefined","NEXT_IS_PRERENDER_HEADER","JSON","parse","e","redirectLocation","assignLocation","URL","window","href","status","text","message","Promise","callServer","findSourceMapURL","a","normalizeFlightData","f","then","cacheNodeSeedData","head","newTree","flightData","pushRef","pendingPush","redirectHref","createHrefFromUrl","handleExternalUrl","actionRevalidated","treePatch","normalizedFlightData","seedData","isRootRender","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","rsc","createEmptyCacheNode","prefetchRsc","loading","fillLazyItemsTillLeafWithHead","prefetchCache","Map","refreshInactiveParallelSegments","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","createSeededPrefetchCacheEntry","data","couldBeIntercepted","prerendered","postponed","staleTime","kind","PrefetchKind","FULL","AUTO","getRedirectError","hasBasePath","removeBasePath","handleMutable","DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","getOrCreatePrefetchCacheEntry","prunePrefetchCache","createPrefetchCacheKeyImpl","includeSearchParams","prefix","pathnameFromUrl","pathname","INTERCEPTION_CACHE_KEY_MARKER","createPrefetchCacheKey","existingCacheEntry","allowAliasing","getExistingCacheEntry","TEMPORARY","maybeNextUrl","cacheKeyWithParams","cacheKeyWithoutParams","cacheKeyToUse","existingEntry","isAliased","aliased","entryWithoutParams","includes","values","cacheEntry","getPrefetchEntryCacheStatus","prefetchResponse","isFullPrefetch","Array","isArray","some","createLazyPrefetchEntry","prefetchCacheKey","prefetchEntry","treeAtTimeOfPrefetch","prefetchTime","lastUsedTime","PrefetchCacheEntryStatus","fresh","set","prefetchQueue","enqueue","fetchServerResponse","flightRouterState","prefetchKind","newCacheKey","existingCacheKey","delete","prefetchCacheEntry","expired","Number","reusable","stale","addRefreshMarkerToActiveParallelSegments","path","refetchMarker","PAGE_SEGMENT_KEY","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","fetchPromises","fetchPromise","parallelFetchPromise","rootTree","refetchPath","has","add","origin","flightDataPath","applyFlightData","all","prefetchReducer","PromiseQueue","prefetchReducerImpl","identityReducerWhenSegmentCacheIsEnabled","hmrRefreshReducer","hmrRefreshReducerNoop","_action","hmrRefreshReducerImpl","generateSegmentsFromPatch","navigateReducer","isExternalUrl","navigateType","shouldScroll","toString","document","getElementById","prefetchValues","bump","canonicalUrlOverride","isFirstRead","urlWithCanonicalPathname","result","handleAliasedPrefetchEntry","updatedCanonicalUrl","onlyHashChange","hashFragment","scrollableSegments","currentCache","pathToSegment","isHeadPartial","flightSegmentPathWithLeadingEmpty","flightSegmentPath","task","startPPRNavigation","route","patchedRouterState","newCache","node","dynamicRequestTree","dynamicRequest","listenForDynamicRequest","applied","triggerLazyFetchForLeafSegments","appliedPatch","segmentPathsToFill","map","segmentPaths","clearCacheNodeDataForSegmentPath","shouldHardNavigate","invalidateCacheBelowFlightSegmentPath","subSegment","scrollableSegmentPath","mpaNavigation","flightRouterPatch","segments","entries","parallelRouteKey","parallelRoute","childSegment","getSegmentValue","serverPatchReducer","serverResponse","segmentPath","canonicalUrlOverrideHref","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_PREFETCH","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","abortTask","updateCacheNodeOnPopstateRestoration","oldCacheNode","routerState","routerStateChildren","oldParallelRoutes","newParallelRoutes","routerStateChild","segmentChild","segmentKeyChild","oldSegmentMapChild","oldCacheNodeChild","newCacheNodeChild","newSegmentMapChild","shouldUsePrefetch","isDeferredRsc","lazyData","prefetchHead","MPA_NAVIGATION_TASK","children","oldRouterState","newRouterState","prefetchData","isPrefetchHeadPartial","isSamePageNavigation","scrollableSegmentsResult","updateCacheNodeOnNavigation","didFindRootLayout","oldRouterStateChildren","newRouterStateChildren","prefetchDataChildren","isRootLayout","prefetchParallelRoutes","patchedRouterStateChildren","taskChildren","needsDynamicRequest","dynamicRequestTreeChildren","newRouterStateChild","oldRouterStateChild","prefetchDataChild","newSegmentChild","newSegmentPathChild","concat","newSegmentKeyChild","oldSegmentChild","taskChild","spawnReusedTask","reusedRouterState","beginRenderingNewRouteTree","matchSegment","taskChildRoute","dynamicRequestTreeChild","newCacheNode","patchRouterStateWithNewChildren","existingCacheNode","possiblyPartialPrefetchHead","createCacheNodeOnNavigation","cacheNodeNavigatedAt","isLeafSegment","spawnPendingTask","existingCacheNodeChildren","cacheNodeChildren","existingSegmentMapChild","segmentPathChild","existingCacheNodeChild","baseRouterState","newChildren","clone","newTask","createPendingCacheNode","size","maybePrefetchRsc","maybePrefetchLoading","createDeferredRsc","responsePromise","serverRouterState","dynamicHead","dynamicData","writeDynamicDataIntoPendingTask","rootTask","i","taskSegment","finishTaskUsingDynamicDataPayload","taskNode","finishPendingCacheNode","taskState","serverState","taskStateChildren","serverStateChildren","dataChildren","taskStateChild","serverStateChild","dataChild","segmentMapChild","taskSegmentChild","taskSegmentKeyChild","cacheNodeChild","abortPendingCacheNode","dynamicSegmentData","serverChildren","dynamicDataChildren","serverRouterStateChild","dynamicDataChild","error","DEFERRED","Symbol","value","pendingRsc","rej","fulfilledRsc","rejectedRsc","reason","restoreReducer","extractPathFromFlightRouterState","treeToRestore","oldCache","focusAndScrollRef","currentSegment","getNextFlightSegmentPath","reducer","clientReducer","serverReducer","refreshReducer","isInterceptionRouteAppPath"],"sourceRoot":"","ignoreList":[]}