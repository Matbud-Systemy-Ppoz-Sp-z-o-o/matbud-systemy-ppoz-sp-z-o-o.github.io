{"version":3,"file":"static/chunks/4848-3c6c1a686145b911.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/get-segment-value.ts","webpack://_N_E/../../../../src/client/components/router-reducer/prefetch-cache-utils.ts"],"sourcesContent":["import type { FlightRouterState } from '../../../../server/app-render/types'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n","import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n","import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\n\nconst INTERCEPTION_CACHE_KEY_MARKER = '%'\n\nexport type AliasedPrefetchCacheEntry = PrefetchCacheEntry & {\n  /** This is a special property that indicates a prefetch entry associated with a different URL\n   * was returned rather than the requested URL. This signals to the router that it should only\n   * apply the part that doesn't depend on searchParams (specifically the loading state).\n   */\n  aliased?: boolean\n}\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKeyImpl(\n  url: URL,\n  includeSearchParams: boolean,\n  prefix?: string | null\n) {\n  // Initially we only use the pathname as the cache key. We don't want to include\n  // search params so that multiple URLs with the same search parameter can re-use\n  // loading states.\n  let pathnameFromUrl = url.pathname\n\n  // RSC responses can differ based on search params, specifically in the case where we aren't\n  // returning a partial response (ie with `PrefetchKind.AUTO`).\n  // In the auto case, since loading.js & layout.js won't have access to search params,\n  // we can safely re-use that cache entry. But for full prefetches, we should not\n  // re-use the cache entry as the response may differ.\n  if (includeSearchParams) {\n    // if we have a full prefetch, we can include the search param in the key,\n    // as we'll be getting back a full response. The server might have read the search\n    // params when generating the full response.\n    pathnameFromUrl += url.search\n  }\n\n  if (prefix) {\n    return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\nfunction createPrefetchCacheKey(\n  url: URL,\n  kind: PrefetchKind | undefined,\n  nextUrl?: string | null\n) {\n  return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)\n}\n\nfunction getExistingCacheEntry(\n  url: URL,\n  kind: PrefetchKind = PrefetchKind.TEMPORARY,\n  nextUrl: string | null,\n  prefetchCache: Map<string, PrefetchCacheEntry>,\n  allowAliasing: boolean\n): AliasedPrefetchCacheEntry | undefined {\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  for (const maybeNextUrl of [nextUrl, null]) {\n    const cacheKeyWithParams = createPrefetchCacheKeyImpl(\n      url,\n      true,\n      maybeNextUrl\n    )\n    const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(\n      url,\n      false,\n      maybeNextUrl\n    )\n\n    // First, we check if we have a cache entry that exactly matches the URL\n    const cacheKeyToUse = url.search\n      ? cacheKeyWithParams\n      : cacheKeyWithoutParams\n\n    const existingEntry = prefetchCache.get(cacheKeyToUse)\n    if (existingEntry && allowAliasing) {\n      // We know we're returning an aliased entry when the pathname matches but the search params don't,\n      const isAliased =\n        existingEntry.url.pathname === url.pathname &&\n        existingEntry.url.search !== url.search\n\n      if (isAliased) {\n        return {\n          ...existingEntry,\n          aliased: true,\n        }\n      }\n\n      return existingEntry\n    }\n\n    // If the request contains search params, and we're not doing a full prefetch, we can return the\n    // param-less entry if it exists.\n    // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n    // but lets us arrive there quicker in the param-full case.\n    const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      allowAliasing &&\n      url.search &&\n      kind !== PrefetchKind.FULL &&\n      entryWithoutParams &&\n      // We shouldn't return the aliased entry if it was relocated to a new cache key.\n      // Since it's rewritten, it could respond with a completely different loading state.\n      !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n    ) {\n      return { ...entryWithoutParams, aliased: true }\n    }\n  }\n\n  // If we've gotten to this point, we didn't find a specific cache entry that matched\n  // the request URL.\n  // We attempt a partial match by checking if there's a cache entry with the same pathname.\n  // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n  // This will signal to the router that it should only apply the loading state on the prefetched data.\n  if (\n    process.env.NODE_ENV !== 'development' &&\n    kind !== PrefetchKind.FULL &&\n    allowAliasing\n  ) {\n    for (const cacheEntry of prefetchCache.values()) {\n      if (\n        cacheEntry.url.pathname === url.pathname &&\n        // We shouldn't return the aliased entry if it was relocated to a new cache key.\n        // Since it's rewritten, it could respond with a completely different loading state.\n        !cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n      ) {\n        return { ...cacheEntry, aliased: true }\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  prefetchCache,\n  kind,\n  allowAliasing = true,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'> & {\n  url: URL\n  kind?: PrefetchKind\n  allowAliasing: boolean\n}): AliasedPrefetchCacheEntry {\n  const existingCacheEntry = getExistingCacheEntry(\n    url,\n    kind,\n    nextUrl,\n    prefetchCache,\n    allowAliasing\n  )\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n      // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n      // are seeded but without a prefetch intent)\n      existingCacheEntry.data.then((prefetchResponse) => {\n        const isFullPrefetch =\n          Array.isArray(prefetchResponse.flightData) &&\n          prefetchResponse.flightData.some((flightData) => {\n            // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n            return flightData.isRootRender && flightData.seedData !== null\n          })\n\n        if (!isFullPrefetch) {\n          return createLazyPrefetchEntry({\n            tree,\n            url,\n            nextUrl,\n            prefetchCache,\n            // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n            // rather than assuming the same intent as the previous entry, to be consistent with how we\n            // lazily create prefetch entries when intent is left unspecified.\n            kind: kind ?? PrefetchKind.TEMPORARY,\n          })\n        }\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n  existingCacheKey,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n  existingCacheKey: string\n}) {\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(\n    url,\n    existingCacheEntry.kind,\n    nextUrl\n  )\n  prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })\n  prefetchCache.delete(existingCacheKey)\n\n  return newCacheKey\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createSeededPrefetchCacheEntry({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  data,\n  kind,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  data: FetchServerResponseResult\n  kind: PrefetchKind\n}) {\n  // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n  // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = data.couldBeIntercepted\n    ? createPrefetchCacheKey(url, kind, nextUrl)\n    : createPrefetchCacheKey(url, kind)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    staleTime: data.staleTime,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  } satisfies PrefetchCacheEntry\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url, kind)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, {\n      flightRouterState: tree,\n      nextUrl,\n      prefetchKind: kind,\n    }).then((prefetchResponse) => {\n      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n      // to avoid drift between this cache key prefixing logic\n      // (which is currently directly influenced by the server response)\n      let newCacheKey\n\n      if (prefetchResponse.couldBeIntercepted) {\n        // Determine if we need to prefix the cache key with the nextUrl\n        newCacheKey = prefixExistingPrefetchCacheEntry({\n          url,\n          existingCacheKey: prefetchCacheKey,\n          nextUrl,\n          prefetchCache,\n        })\n      }\n\n      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n      // staleTime.\n      if (prefetchResponse.prerendered) {\n        const existingCacheEntry = prefetchCache.get(\n          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n          newCacheKey ?? prefetchCacheKey\n        )\n        if (existingCacheEntry) {\n          existingCacheEntry.kind = PrefetchKind.FULL\n          if (prefetchResponse.staleTime !== -1) {\n            // This is the stale time that was collected by the server during\n            // static generation. Use this in place of the default stale time.\n            existingCacheEntry.staleTime = prefetchResponse.staleTime\n          }\n        }\n      }\n\n      return prefetchResponse\n    })\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === PrefetchKind.AUTO) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === PrefetchKind.FULL) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n"],"names":["findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","length","parallelRoutesKeys","filter","key","unshift","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","cacheNode","item","getSegmentValue","Array","isArray","DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","createSeededPrefetchCacheEntry","getOrCreatePrefetchCacheEntry","prunePrefetchCache","createPrefetchCacheKeyImpl","url","includeSearchParams","prefix","pathnameFromUrl","pathname","search","INTERCEPTION_CACHE_KEY_MARKER","createPrefetchCacheKey","kind","nextUrl","PrefetchKind","FULL","tree","prefetchCache","existingCacheEntry","allowAliasing","getExistingCacheEntry","TEMPORARY","maybeNextUrl","cacheKeyWithParams","cacheKeyWithoutParams","cacheKeyToUse","existingEntry","isAliased","aliased","entryWithoutParams","process","includes","values","cacheEntry","status","getPrefetchEntryCacheStatus","data","then","prefetchResponse","isFullPrefetch","flightData","some","isRootRender","seedData","createLazyPrefetchEntry","prefetchCacheKey","couldBeIntercepted","prefetchEntry","treeAtTimeOfPrefetch","Promise","resolve","prefetchTime","Date","now","lastUsedTime","staleTime","PrefetchCacheEntryStatus","fresh","set","prefetchQueue","enqueue","fetchServerResponse","flightRouterState","prefetchKind","newCacheKey","prefixExistingPrefetchCacheEntry","existingCacheKey","delete","prerendered","href","prefetchCacheEntry","expired","Number","reusable","AUTO","stale"],"sourceRoot":"","ignoreList":[]}