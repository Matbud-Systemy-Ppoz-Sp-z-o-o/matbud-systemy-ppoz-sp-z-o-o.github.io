{"version":3,"file":"static/chunks/5570-87db689d8b7ea56d.js","mappings":"wWA8eA,qCAAwBA,8CA/djB,eASA,gBACc,YAKd,WAC6B,WACD,WACL,WACD,UAC4B,WACxB,WACU,WACN,WACa,WACV,WACkB,SACzB,OAwDjC,IAAMC,EACJC,EAAAA,OAAQ,CACRD,4DAA4D,CAmBxDE,EAAiB,CACrB,SACA,SACA,OACA,QACA,MACA,QACA,IACA,IACD,CA2BD,SAASC,EAAuBC,CAAoB,CAAEC,CAAsB,EAC1E,IAAMC,EAAOF,EAAQG,qBAAqB,GAC1C,OAAOD,EAAKE,GAAG,EAAI,GAAKF,EAAKE,GAAG,EAAIH,CACtC,OA0BA,8HAAMI,EAAN,SACEC,qBAAAA,CAAwB,WAEtB,MAAM,EAA0CC,KAAK,KAA7CC,iBAAiB,GAAkB,EAAhBC,EAAoB,SAAT,CAEtC,GAAID,EAAkBE,KAAK,CAAE,CAI3B,GACEF,MAAkBG,YAAY,CAACC,MAAM,EACrC,CAACJ,EAAkBG,YAAY,CAACE,IAAI,CAAC,SAACC,CAAAA,SACpCL,EAAYM,KAAK,CAAC,SAACC,CAAAA,CAASC,CAAAA,QAC1BC,GAAAA,EAAAA,YAAAA,EAAaF,EAASF,CAAoB,CAACG,EAAM,MAIrD,CADA,MAIF,IA9BFE,EA8BMC,EAEiC,KAC/BC,EAAeb,EAAkBa,YAAY,CAanD,GAXIA,IACFD,EA1CFC,OAAwB,CAyCN,EAxCbF,SAASG,IAAI,CAKpBH,MAAAA,CAAAA,EAAAA,SAASI,cAAc,CAACF,EAAAA,CAAAA,CAAxBF,EACA,SACSK,iBAAiB,CAACH,EAAa,CAAC,EAAE,EAuCrC,IACFD,EArGJxB,GAoGgB,EApG6C6B,GAqG/CA,QArG+CA,EAqGnC,EAAI,GAItBL,EAAAA,CAAmBM,CAAnBN,EAxG0BO,IAwGD,KAC7B,CADiC,MAMnC,KAAO,CAAEP,EAAAA,CAAmBQ,CAAnBR,EAAAA,CAA6B,aA9F5C,SAASS,CAAsC,EAI7C,GAAI,CAAC,SAAU,QAAQ,CAACC,QAAQ,CAACC,iBAAiB/B,GAASgC,QAAQ,EAOjE,CAPoE,MAO7D,EAKT,IAAM9B,EAAOF,EAAQG,qBAAqB,GAC1C,OAAOL,EAAeiB,KAAK,CAAC,SAACkB,CAAAA,SAAwB,KAAX,CAACA,EAAK,EAClD,EA4EoEb,IAAU,CAUtE,GAAmC,MAAM,CAArCA,EAAQc,kBAAkB,CAC5B,OAEFd,EAAUA,EAAQc,kBAAkB,CAItC1B,EAAkBE,KAAK,CAAG,GAC1BF,EAAkBa,YAAY,CAAG,KACjCb,EAAkBG,YAAY,CAAG,EAAE,CAEnCwB,CAAAA,EAAAA,EAAAA,wCAAAA,EACE,WAEE,GAAId,EAAc,YACdD,EAAwBgB,cAAc,GAM1C,IAAMC,EAAclB,SAASmB,eAAe,CACtCrC,EAAiBoC,EAAYE,YAAY,EAG3CxC,EAAuBqB,EAAwBnB,KAQnDoC,EAAYG,SAAS,CAAG,EAGpB,EAAwBpB,EAAwBnB,IAEhDmB,EAAwBgB,WAFyC,GAE3B,GAE5C,EACA,CAEEK,iBAAiB,EACjBC,eAAgBlC,EAAkBkC,cAAc,GAKpDlC,EAAkBkC,cAAc,EAAG,EAGnCtB,EAAQuB,KAAK,EACf,CACF,mEAEAC,EACE,IAAI,CAACtC,aADa,QACQ,EAC5B,IAEAuC,IAAAA,gBAAqB,sBAEf,IAAI,CAACtC,KAAK,CAACC,iBAAiB,CAACE,KAAK,EAAE,IAClC,CAACJ,qBAAqB,EAE9B,gCAEAwC,EACE,OAAO,IAAI,CAACvC,KAAK,CAACwC,QAAQ,QAxHWC,EAAAA,OAAK,CAACC,SAAS,EA4HxD,SAASC,EAAsB,CAM9B,EAN8B,MAClB,gBADkB,EAE7BH,QAAQ,CAKFI,EAAUC,CAAAA,EAAAA,EAAAA,UAAAA,EAAWC,EAAAA,yBAAyB,EACpD,GAAI,CAACF,EACH,MAAM,CADM,MACN,cAAuD,CAAvD,MAAU,8CAAV,+DAAsD,GAG9D,MACE,UAAC9C,EAAAA,CACCI,YAAaA,EACbD,kBAAmB2C,EAAQ3C,iBAAiB,UAE3CuC,GAGP,CAKA,SAASO,EAAkB,CAU1B,EAV0B,QACzBC,IAAI,GADqB,EAEzB9C,WAAW,KACX+C,SAAS,CACTC,EAMD,CANI,CAMJ,IACON,EAAUC,CAAAA,EAAAA,EAAAA,UAAAA,EAAWC,EAAAA,yBAAyB,EACpD,GAAI,CAACF,EACH,MAAM,CADM,MACN,cAAuD,CAAvD,MAAU,8CAAV,+DAAsD,GAG9D,IAAcO,EAAR,EAAEH,IAAc,CAShBI,CATkB,CAUtBH,SAAUI,WAAW,CAAYJ,EAAUI,WAAW,CAAGJ,EAAUK,GAAG,CAKlEA,EAAWC,CAAAA,EAAAA,EAAAA,gBAAAA,EAAiBN,EAAUK,GAAG,CAAEF,GAM3CI,EAAAA,CAAAA,KAAAA,IAAAA,EAAAA,YACJ,GAAOF,CAAAA,EAAAA,CAAAA,GAAQ,UAAYA,UAAoC,YAApB,OAAOA,EAAIG,IAAI,CACtDC,CAAAA,EAAAA,EAAAA,GAAAA,EAAIJ,GACJA,EAEN,GAAI,CAACE,EAAa,CAMhB,IAAIG,EAAWV,EAAUU,QAAQ,CACjC,GAAiB,OAAbA,EAAmB,CAKrB,IAAMC,EA/UZ,SAASC,EACPC,CAAgD,CAChDC,CAAiC,EAEjC,GAAID,EAAmB,CACrB,MAAM,SAACrD,EAAAA,CAAAA,CAAAA,EAAAA,CAASuD,EAAoBF,CAAAA,CAAAA,EAAAA,CAC9BG,EAAsC,MAAX5D,EADA,IACM,CAEvC,GAAIM,CAAAA,EAAAA,EAAAA,YAAAA,EAAaoD,CAAc,CAAC,EAAE,CAAEtD,IAC9BsD,CAAc,CAAC,EAAE,CAACG,CADsB,aACR,CAACF,GAAmB,CACtD,GAAIC,EAAQ,CACV,IAAME,EAAUN,OACdO,EACAL,CAAc,CAAC,EAAE,CAACC,EAAiB,EAErC,MAAO,CACLD,CAAc,CAAC,EAAE,CACjB,WACKA,CAAc,CAAC,EAAE,EACpB,OAACC,EAAmB,CAClBG,CAAO,CAAC,EAAE,CACVA,CAAO,CAAC,EAAE,CACVA,CAAO,CAAC,EAHQ,CAIhB,UACD,GAEJ,CAGH,MAAO,CACLJ,CAAc,CAAC,EAAE,CACjB,WACKA,CAAc,CAAC,EAAE,EACpB,OAACC,EAAmBH,EAClBC,EAAkBO,KAAK,CAAC,GACxBN,CAAc,CAFE,EAEC,CAACC,EAAiB,IAGxC,CAGP,CAEA,OAAOD,CACT,EAmS0BF,CAAgB,GAAmB,CAApB,WAAQ3D,IAAciD,GACnDmB,EAAiBC,CAAAA,EAAAA,EAAAA,iCAAAA,EAAkCpB,GACnDqB,EAAcC,KAAKC,GAAG,GAC5BzB,EAAUU,QAAQ,CAAGA,EAAWgB,GAAAA,EAAAA,mBAAAA,EAC9B,IAAIC,IAAI1B,EAAK2B,SAASC,MAAM,EAC5B,CACEC,kBAAmBnB,EACnBoB,QAASV,EAAiB1B,EAAQoC,OAAO,CAAG,IAC9C,GACAvB,IAAI,CAAC,SAACwB,CAAAA,EAUN,MATAC,GAAAA,EAAAA,eAAAA,EAAgB,WACdC,CAAAA,EAAAA,EAAAA,uBAAAA,EAAwB,CACtBC,KAAMC,EAAAA,mBAAmB,CACzBC,aAAcnC,iBACd8B,cACAT,CACF,EACF,GAEOS,CACT,GAGAvB,CAAAA,EAAAA,EAAAA,GAAAA,EAAIC,EACN,CAGAD,CAAAA,EAAAA,EAAAA,GAAAA,EAAI6B,EAAAA,kBAAkB,CACxB,CAmBA,MAdE,CAcKC,EAdL,OAACC,EAAAA,UAD2E,SACxD,CAACC,QAAQ,EAC3BC,MAAO,CACLC,WAAY5C,EACZ6C,gBAAiB5C,EACjB6C,kBAAmB5F,EAGnBgD,IAAKA,CACP,WAECM,GAKP,CAMA,SAASuC,EAAgB,CAMxB,EANwB,IAenBC,EAfmB,IACvBC,OAAO,GADgB,EAEvBzD,QAAQ,CAyBR,GALEwD,CAKEA,CAXJ,wBACE,GAAOC,CAAAA,EAAAA,CAAAA,GAAY,UACP,OAAZA,GACiC,YACjC,OADQA,EAAgBxC,IAAI,CAGRC,GAAAA,EAAAA,GAAAA,EADMuC,GAGNA,EAGC,CACrB,IAAMC,EAAaF,CAAiB,CAAC,EAAE,CACjCG,EAAgBH,CAAiB,CAAC,EAAE,CACpCI,EAAiBJ,CAAiB,CAAC,EAAE,CAC3C,MACE,UAACK,EAAAA,QAAQ,EACPC,SACE,YADFA,CACE,oBACGH,EACAC,EACAF,cAIJ1D,GAGP,CAEA,MAAO,+BAAGA,GACZ,CAMe,SAASpD,EAAkB,CAwBzC,EAxByC,QACxCmH,iBAAiB,CACjBC,EAAK,UAFmC,EAGxCC,WAAW,KACXC,YAAY,KACZC,cAAc,KACdC,eAAe,KACfC,QAAQ,KACRC,QAAQ,KACRC,SAAS,KACTC,YAAY,GACZC,qBAAqB,CAcrB,IAAMrE,EAAUC,GAAAA,EAAAA,UAAAA,EAAW4C,EAAAA,mBAAmB,EAC9C,GAAI,CAAC7C,EACH,MAAM,CADM,MACN,cAA2D,CAA3D,MAAU,kDAAV,8DAA0D,GAGlE,MAAM,EAAEgD,UAAU,KAAEC,eAAe,KAAEC,iBAAiB,GAAUlD,EAARM,GAAG,CAIrDgE,EAAuBrB,EAAgBsB,cAAc,CACvDC,EAAaF,EAAqBG,GAAG,CAACd,GAGrCa,IACHA,EAAa,IAAIE,EADF,EAEfJ,EAAqBK,GAAG,CAAChB,EAAmBa,IAE9C,IAAMI,EAAoB5B,CAAU,CAAC,EAAE,CACjC1F,EACkB,OAAtB4F,EAII,CAACS,EAAkB,CACnBT,EAAkB2B,MAAM,CAAC,CAACD,EAAmBjB,EAAkB,EAY/DmB,EAAa9B,CAAU,CAAC,EAAE,CAACW,EAAkB,CAC7CoB,EAAgBD,CAAU,CAAC,CAfU,CAeR,CAC7BE,EAAiBC,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqBF,GAAe,GAQvDG,EAA0CC,CARmB,EAQnBA,EAAAA,eARsC,CAQtCA,EAC5CL,EACAE,GAEEpF,EAAmC,EAAE,CACzC,EAAG,CACD,IAAMQ,EAAO8E,EAAa9E,IAAI,CACxBgF,EAAWF,EAAaE,QAAQ,CAChCvH,EAAUuC,CAAI,CAAC,EAAE,CACjBiF,EAAWJ,CAAAA,EAAAA,EAAAA,oBAAAA,EAAqBpH,GAGlCwC,EAAYmE,EAAWC,GAAG,CAACY,GAC/B,QAAkB7D,IAAdnB,EAAyB,CAG3B,IAAMiF,EAAkC,CACtCvE,SAAU,KACVL,IAAK,KACLD,YAAa,KACb8E,KAAM,KACNC,aAAc,KACdjB,eAAgB,IAAIG,IACpBrB,QAAS,KACTzB,YAAa,CAAC,CAChB,EAGAvB,EAAYiF,EACZd,EAAWG,GAAG,CAACU,EAAUC,EAC3B,CA0CA,IAAMlC,EAAoBH,EAAgBI,OAAO,CAC7CoC,EACF,WAACC,EAAAA,IADCD,WACc,CAAC3C,QAAQ,EAEvBC,MACE,WAAChD,CADHgD,CACGhD,CAAsBzC,YAAaA,YAClC,UAACqI,EAAAA,aAAa,EACZC,eAAgBhC,EAChBC,YAAaA,EACbC,aAAcA,WAEd,UAACX,EAAAA,CAAgBE,QAASD,WACxB,UAACyC,EAAAA,0BAA0B,EACzB3B,SAAUA,EACVC,UAAWA,EACXC,aAAcA,WAEd,WAAC0B,EAAAA,gBAAgB,YACf,UAAC3F,EAAAA,CACCG,IAAKA,EACLF,KAAMA,EACNC,UAAWA,EACX/C,YAAaA,IAnDmB,cACN,kBA6DvCyG,EACAC,EACAC,IAhCImB,GA2DTxF,EAASmG,IAAI,CAACN,GAEdP,EAAeA,EAAac,IAAI,OACR,OAAjBd,EAAsB,CAE/B,OAAOtF,CACT,sdC7nB6B,SAAhBqG,SAAAA,OAAgB,gBAHG,SAAnBC,SAAAA,UAAmB,WAoHC,SAAjBC,SAAAA,QAAiB,aAtCA,SAAjBC,SAAAA,QAAiB,mBAwFM,SAAvBC,SAAAA,GAsBAC,WAtBuB,OAsBL,mBAAlBA,oBA0EgB,SAAhBC,SAAAA,OAAgB,wBA7PW,SAA3BC,SAAAA,kBAA2B,iBASI,SAA/BC,SAAAA,GA2HAC,mBA3H+B,QA2HJ,mBAA3BA,OA5MyB,0BAMlC,WASyB,WACH,WACE,OA2C3BC,EAAmD,KAG1CT,EAAsB,CAAEU,QAAS,EAAK,EAGtCX,EAAmB,CAAEW,SAAS,CAAM,EAM1C,SAASJ,EAA4BK,CAAyB,EACnEvE,CAAAA,EAAAA,EAAAA,eAAAA,EAAgB,WACdqE,MAAAA,CAAAA,EAAAA,EAA6BG,CAA7BH,sBAAoD,CAACV,GACrDY,MAAAA,CAAAA,EAAAA,EAAMC,CAAND,sBAA6B,CAACX,GAC9BS,EAA8BE,CAChC,EACF,CAGO,SAASJ,EAAgCI,CAAkB,EAC5DF,IAAgCE,IAClCF,EADwC,IACV,CAElC,CAIA,IAAMI,EAGe,YAAnB,OAAOC,QAAyB,IAAIA,QAAY,IAAItC,IAMhDuC,EAAoD,IAAIC,IAGxDC,EAC4B,YAAhC,OAAOC,qBACH,IAAIA,qBAAqBC,SAoHtBA,CAAyD,6BAChE,QAAK,EAAL,EAAoBC,CAAAA,CAAAA,OAAAA,QAAAA,CAAAA,GAAf,4BAAwB,KAAlBC,EAAAA,EAAAA,KAAAA,CAIHC,EAAYD,EAAME,iBAAiB,CAAG,EAC5CpB,EAAwBkB,EAAMG,MAAM,CAAuBF,EAC7D,oFACF,EA5HgD,CACxCG,WAAY,OACd,GACA,KAEN,SAASC,EAAkB/K,CAAgB,CAAE2B,CAA8B,EAErEqJ,KAAqBrG,IADAuF,EAAatC,GAAG,CAAC5H,CACN,GAIlC6J,EAA4B7J,GAG9BkK,EAAapC,GAAG,CAAC9H,EAAS2B,GACtB2I,MAAmB,IACrBA,EAASW,OAAO,CAACjL,EAErB,CAEA,SAASkL,EAAsBC,CAAY,EACzC,GAAI,CACF,MAAOC,CAAAA,EAAAA,EAAAA,iBAAAA,EAAkBD,EAC3B,CAAE,QAAM,CAWN,MAHAE,CADyB,YAAvB,OAAOC,YAA6BA,YAAcC,QAAQxE,KAAAA,EAEzD,oBAAmBoE,EAAK,8CAEpB,IACT,CACF,CAEO,SAAS5B,EACdvJ,CAAoB,CACpBmL,CAAY,CACZK,CAAyB,CACzBC,CAAwC,CACxCC,CAAwB,CACxBzB,CAA+D,EAE/D,GAAIyB,EAAiB,CACnB,IAAMC,EAAcT,EAAsBC,GAC1C,GAAoB,OAAhBQ,EAAsB,CACxB,IAAMhK,EAAqC,QACzC6J,gBACAC,EACAd,WAAW,EACXiB,aAAc,KACdC,aAAcF,EAAYR,IAAI,yBAC9BlB,CACF,EAIA,OADAc,EAAkB/K,EAAS2B,GACpBA,CACT,CACF,CAWA,MAR8C,CAQvCA,OAPL6J,gBACAC,EACAd,WAAW,EACXiB,aAAc,KACdC,aAAc,KACd5B,wBAAAA,CACF,CAEF,CAEO,SAASX,EACdtJ,CAAwB,CACxBmL,CAAY,CACZK,CAAyB,CACzBC,CAAwC,EAExC,IAAME,EAAcT,EAAsBC,EACtB,MAAM,EAAtBQ,GAeJZ,EAAkB/K,EARa,OAQJ2B,CAPzB6J,gBACAC,EACAd,WAAW,EACXiB,aAAc,KACdC,aAAcF,EAAYR,IAAI,CAC9BlB,wBAAyB,IAC3B,EAEF,CAEO,SAASJ,EAA4B7J,CAAgB,EAC1D,IAAM2B,EAAWuI,EAAatC,GAAG,CAAC5H,GAClC,QAAiB2E,IAAbhD,EAAwB,CAC1BuI,EAAa4B,MAAM,CAAC9L,GACpBoK,EAAuB0B,MAAM,CAACnK,GAC9B,IAAMiK,EAAejK,EAASiK,YAAY,MACf,EAAvBA,GACFG,CAAAA,EAAAA,EAAAA,kBAAAA,EAAmBH,EAEvB,CACiB,MAAM,CAAnBtB,GACFA,EAAS0B,SAAS,CAAChM,EAEvB,CAYO,SAASwJ,EAAwBxJ,CAAgB,CAAE2K,CAAkB,EAQ1E,IAAMhJ,EAAWuI,EAAatC,GAAG,CAAC5H,QACjB2E,IAAbhD,IAIJA,EAASgJ,CAJmB,QAIV,CAAGA,EACjBA,EACFP,EAAuB6B,GAAG,CAACtK,GADd,EAGUmK,MAAM,CAACnK,GAEhCuK,EAAuBvK,EAAUwK,EAAAA,gBAAgB,CAACC,OAAO,EAC3D,CAEO,SAAS3C,EACdzJ,CAAwC,CACxCqM,CAA0C,EAE1C,IAAM1K,EAAWuI,EAAatC,GAAG,CAAC5H,QACjB2E,IAAbhD,GAIAA,IAJwB,OAIA,CAQ1BuK,EAAuBvK,EAAUwK,EAAAA,gBAAgB,CAACG,MAAM,CAE5D,CAEA,SAASJ,EACPvK,CAA8B,CAC9B4K,CAA4D,EAE5D,IAmF0C5K,EAnFpC6K,EAAuB7K,EAASiK,EAmFkC,UAnFtB,CAElD,GAAI,CAACjK,EAASgJ,SAAS,CAAE,CAGM,MAAM,CAA/B6B,GACFT,CAAAA,EAAAA,EAAAA,kBAAAA,EAAmBS,GAMrB,MACF,GAKqC7K,EA4GrC8K,mBAjCMC,8BACJ,OAAQ/K,EAAS8J,aAAa,EAC5B,KAAKkB,EAAAA,aAAa,CAACC,GAAG,CACpBF,EAAeG,EAAAA,YAAY,CAACC,IAAI,CAChC,KAEF,MAAKH,EAAAA,aAAa,CAACI,IAAI,CACrBL,EAAeG,EAAAA,YAAY,CAACG,IAAI,CAChC,KAEF,MAAKL,EAAAA,aAAa,CAACM,UAAU,CAG3B,MAAM,qBAEL,CAFK,IAAIC,EAAAA,cAAc,CACtB,oGADI,+DAEN,EAEF,SACEvL,EAAS8J,aAAa,CAEtBiB,OAAe/H,CAEnB,CAEA,SAAOhD,EAAS6J,MAAM,CAAC2B,QAAQ,CAACxL,EAASkK,YAAY,CAAE,CACrDuB,KAAMV,CACR,KACF,KAMaW,KAAK,CAAC,SAACC,CAAAA,EAKpB,EApFF,CAEO,SAAS5D,EACdnE,CAAsB,CACtBhC,CAAuB,MASlB,uBAAL,QAAuB6G,EAAvB,EAAuBA,CAAAA,CAAAA,OAAAA,QAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,CAAAA,EAAwB,KAApCzI,EAAAA,EAAAA,KAAAA,CACH4L,EAAO5L,EAASiK,YAAY,CAClC,GAAa,OAAT2B,CAAiB,EAACC,CAAAA,EAAAA,EAAAA,mBAAAA,EAAoBD,EAAMhI,EAAShC,IAO5C,GAPmD,GAO7C,CAAfgK,GACFxB,CAAAA,EAAAA,EAAAA,kBAAAA,EAAmBwB,GAErB,IAAM/E,EAAWiF,CAAAA,EAAAA,EAAAA,cAAAA,EAAe9L,EAASkK,YAAY,CAAEtG,GACvD5D,EAASiK,YAAY,CAAG8B,CAAAA,EAAAA,EAAAA,oBAAAA,EACtBlF,EACAjF,EACA5B,EAAS8J,aAAa,CACtBU,EAAAA,gBAAgB,CAACC,OAAO,CACxB,MAEJ,oFACF","sources":["webpack://_N_E/../../../src/client/components/layout-router.tsx","webpack://_N_E/../../../src/client/components/links.ts"],"sourcesContent":["'use client'\n\nimport type {\n  CacheNode,\n  LazyCacheNode,\n  LoadingModuleData,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../server/app-render/types'\nimport type { ErrorComponent } from './error-boundary'\nimport {\n  ACTION_SERVER_PATCH,\n  type FocusAndScrollRef,\n} from './router-reducer/router-reducer-types'\n\nimport React, {\n  useContext,\n  use,\n  startTransition,\n  Suspense,\n  useDeferredValue,\n  type JSX,\n} from 'react'\nimport ReactDOM from 'react-dom'\nimport {\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n  TemplateContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { fetchServerResponse } from './router-reducer/fetch-server-response'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { ErrorBoundary } from './error-boundary'\nimport { matchSegment } from './match-segments'\nimport { disableSmoothScrollDuringRouteTransition } from '../../shared/lib/router/utils/disable-smooth-scroll'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { HTTPAccessFallbackBoundary } from './http-access-fallback/error-boundary'\nimport { createRouterCacheKey } from './router-reducer/create-router-cache-key'\nimport { hasInterceptionRouteInCurrentTree } from './router-reducer/reducers/has-interception-route-in-current-tree'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { useRouterBFCache, type RouterBFCacheEntry } from './bfcache'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n\nconst Activity = process.env.__NEXT_ROUTER_BF_CACHE\n  ? (require('react') as typeof import('react')).unstable_Activity\n  : null!\n\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */\nfunction walkAddRefetch(\n  segmentPathToWalk: FlightSegmentPath | undefined,\n  treeToRecreate: FlightRouterState\n): FlightRouterState {\n  if (segmentPathToWalk) {\n    const [segment, parallelRouteKey] = segmentPathToWalk\n    const isLast = segmentPathToWalk.length === 2\n\n    if (matchSegment(treeToRecreate[0], segment)) {\n      if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n        if (isLast) {\n          const subTree = walkAddRefetch(\n            undefined,\n            treeToRecreate[1][parallelRouteKey]\n          )\n          return [\n            treeToRecreate[0],\n            {\n              ...treeToRecreate[1],\n              [parallelRouteKey]: [\n                subTree[0],\n                subTree[1],\n                subTree[2],\n                'refetch',\n              ],\n            },\n          ]\n        }\n\n        return [\n          treeToRecreate[0],\n          {\n            ...treeToRecreate[1],\n            [parallelRouteKey]: walkAddRefetch(\n              segmentPathToWalk.slice(2),\n              treeToRecreate[1][parallelRouteKey]\n            ),\n          },\n        ]\n      }\n    }\n  }\n\n  return treeToRecreate\n}\n\nconst __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = (\n  ReactDOM as any\n).__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */\nfunction findDOMNode(\n  instance: React.ReactInstance | null | undefined\n): Element | Text | null {\n  // Tree-shake for server bundle\n  if (typeof window === 'undefined') return null\n\n  // __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode is null during module init.\n  // We need to lazily reference it.\n  const internal_reactDOMfindDOMNode =\n    __DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE.findDOMNode\n  return internal_reactDOMfindDOMNode(instance)\n}\n\nconst rectProperties = [\n  'bottom',\n  'height',\n  'left',\n  'right',\n  'top',\n  'width',\n  'x',\n  'y',\n] as const\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */\nfunction shouldSkipElement(element: HTMLElement) {\n  // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n  // and will result in a situation we bail on scroll because of something like a fixed nav,\n  // even though the actual page content is offscreen\n  if (['sticky', 'fixed'].includes(getComputedStyle(element).position)) {\n    if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:',\n        element\n      )\n    }\n    return true\n  }\n\n  // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n  // because `offsetParent` doesn't consider document/body\n  const rect = element.getBoundingClientRect()\n  return rectProperties.every((item) => rect[item] === 0)\n}\n\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */\nfunction topOfElementInViewport(element: HTMLElement, viewportHeight: number) {\n  const rect = element.getBoundingClientRect()\n  return rect.top >= 0 && rect.top <= viewportHeight\n}\n\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */\nfunction getHashFragmentDomNode(hashFragment: string) {\n  // If the hash fragment is `top` the page has to scroll to the top of the page.\n  if (hashFragment === 'top') {\n    return document.body\n  }\n\n  // If the hash fragment is an id, the page has to scroll to the element with that id.\n  return (\n    document.getElementById(hashFragment) ??\n    // If the hash fragment is a name, the page has to scroll to the first element with that name.\n    document.getElementsByName(hashFragment)[0]\n  )\n}\ninterface ScrollAndFocusHandlerProps {\n  focusAndScrollRef: FocusAndScrollRef\n  children: React.ReactNode\n  segmentPath: FlightSegmentPath\n}\nclass InnerScrollAndFocusHandler extends React.Component<ScrollAndFocusHandlerProps> {\n  handlePotentialScroll = () => {\n    // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n    const { focusAndScrollRef, segmentPath } = this.props\n\n    if (focusAndScrollRef.apply) {\n      // segmentPaths is an array of segment paths that should be scrolled to\n      // if the current segment path is not in the array, the scroll is not applied\n      // unless the array is empty, in which case the scroll is always applied\n      if (\n        focusAndScrollRef.segmentPaths.length !== 0 &&\n        !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath) =>\n          segmentPath.every((segment, index) =>\n            matchSegment(segment, scrollRefSegmentPath[index])\n          )\n        )\n      ) {\n        return\n      }\n\n      let domNode:\n        | ReturnType<typeof getHashFragmentDomNode>\n        | ReturnType<typeof findDOMNode> = null\n      const hashFragment = focusAndScrollRef.hashFragment\n\n      if (hashFragment) {\n        domNode = getHashFragmentDomNode(hashFragment)\n      }\n\n      // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n      // This already caused a bug where the first child was a <link/> in head.\n      if (!domNode) {\n        domNode = findDOMNode(this)\n      }\n\n      // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n      if (!(domNode instanceof Element)) {\n        return\n      }\n\n      // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n      // If the element is skipped, try to select the next sibling and try again.\n      while (!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (domNode.parentElement?.localName === 'head') {\n            // TODO: We enter this state when metadata was rendered as part of the page or via Next.js.\n            // This is always a bug in Next.js and caused by React hoisting metadata.\n            // We need to replace `findDOMNode` in favor of Fragment Refs (when available) so that we can skip over metadata.\n          }\n        }\n\n        // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n        if (domNode.nextElementSibling === null) {\n          return\n        }\n        domNode = domNode.nextElementSibling\n      }\n\n      // State is mutated to ensure that the focus and scroll is applied only once.\n      focusAndScrollRef.apply = false\n      focusAndScrollRef.hashFragment = null\n      focusAndScrollRef.segmentPaths = []\n\n      disableSmoothScrollDuringRouteTransition(\n        () => {\n          // In case of hash scroll, we only need to scroll the element into view\n          if (hashFragment) {\n            ;(domNode as HTMLElement).scrollIntoView()\n\n            return\n          }\n          // Store the current viewport height because reading `clientHeight` causes a reflow,\n          // and it won't change during this function.\n          const htmlElement = document.documentElement\n          const viewportHeight = htmlElement.clientHeight\n\n          // If the element's top edge is already in the viewport, exit early.\n          if (topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            return\n          }\n\n          // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n          // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n          // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n          // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n          htmlElement.scrollTop = 0\n\n          // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n          if (!topOfElementInViewport(domNode as HTMLElement, viewportHeight)) {\n            // Scroll into view doesn't scroll horizontally by default when not needed\n            ;(domNode as HTMLElement).scrollIntoView()\n          }\n        },\n        {\n          // We will force layout by querying domNode position\n          dontForceLayout: true,\n          onlyHashChange: focusAndScrollRef.onlyHashChange,\n        }\n      )\n\n      // Mutate after scrolling so that it can be read by `disableSmoothScrollDuringRouteTransition`\n      focusAndScrollRef.onlyHashChange = false\n\n      // Set focus on the element\n      domNode.focus()\n    }\n  }\n\n  componentDidMount() {\n    this.handlePotentialScroll()\n  }\n\n  componentDidUpdate() {\n    // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n    if (this.props.focusAndScrollRef.apply) {\n      this.handlePotentialScroll()\n    }\n  }\n\n  render() {\n    return this.props.children\n  }\n}\n\nfunction ScrollAndFocusHandler({\n  segmentPath,\n  children,\n}: {\n  segmentPath: FlightSegmentPath\n  children: React.ReactNode\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  return (\n    <InnerScrollAndFocusHandler\n      segmentPath={segmentPath}\n      focusAndScrollRef={context.focusAndScrollRef}\n    >\n      {children}\n    </InnerScrollAndFocusHandler>\n  )\n}\n\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */\nfunction InnerLayoutRouter({\n  tree,\n  segmentPath,\n  cacheNode,\n  url,\n}: {\n  tree: FlightRouterState\n  segmentPath: FlightSegmentPath\n  cacheNode: CacheNode\n  url: string\n}) {\n  const context = useContext(GlobalLayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant global layout router not mounted')\n  }\n\n  const { tree: fullTree } = context\n\n  // `rsc` represents the renderable node for this segment.\n\n  // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n  // We should use that on initial render instead of `rsc`. Then we'll switch\n  // to `rsc` when the dynamic response streams in.\n  //\n  // If no prefetch data is available, then we go straight to rendering `rsc`.\n  const resolvedPrefetchRsc =\n    cacheNode.prefetchRsc !== null ? cacheNode.prefetchRsc : cacheNode.rsc\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  const rsc: any = useDeferredValue(cacheNode.rsc, resolvedPrefetchRsc)\n\n  // `rsc` is either a React node or a promise for a React node, except we\n  // special case `null` to represent that this segment's data is missing. If\n  // it's a promise, we need to unwrap it so we can determine whether or not the\n  // data is missing.\n  const resolvedRsc: React.ReactNode =\n    typeof rsc === 'object' && rsc !== null && typeof rsc.then === 'function'\n      ? use(rsc)\n      : rsc\n\n  if (!resolvedRsc) {\n    // The data for this segment is not available, and there's no pending\n    // navigation that will be able to fulfill it. We need to fetch more from\n    // the server and patch the cache.\n\n    // Check if there's already a pending request.\n    let lazyData = cacheNode.lazyData\n    if (lazyData === null) {\n      /**\n       * Router state with refetch marker added\n       */\n      // TODO-APP: remove ''\n      const refetchTree = walkAddRefetch(['', ...segmentPath], fullTree)\n      const includeNextUrl = hasInterceptionRouteInCurrentTree(fullTree)\n      const navigatedAt = Date.now()\n      cacheNode.lazyData = lazyData = fetchServerResponse(\n        new URL(url, location.origin),\n        {\n          flightRouterState: refetchTree,\n          nextUrl: includeNextUrl ? context.nextUrl : null,\n        }\n      ).then((serverResponse) => {\n        startTransition(() => {\n          dispatchAppRouterAction({\n            type: ACTION_SERVER_PATCH,\n            previousTree: fullTree,\n            serverResponse,\n            navigatedAt,\n          })\n        })\n\n        return serverResponse\n      })\n\n      // Suspend while waiting for lazyData to resolve\n      use(lazyData)\n    }\n    // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n    // A falsey `resolvedRsc` indicates missing data -- we should not commit that branch, and we need to wait for the data to arrive.\n    use(unresolvedThenable) as never\n  }\n\n  // If we get to this point, then we know we have something we can render.\n  const subtree = (\n    // The layout router context narrows down tree and childNodes at each level.\n    <LayoutRouterContext.Provider\n      value={{\n        parentTree: tree,\n        parentCacheNode: cacheNode,\n        parentSegmentPath: segmentPath,\n\n        // TODO-APP: overriding of url for parallel routes\n        url: url,\n      }}\n    >\n      {resolvedRsc}\n    </LayoutRouterContext.Provider>\n  )\n  // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n  return subtree\n}\n\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */\nfunction LoadingBoundary({\n  loading,\n  children,\n}: {\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  children: React.ReactNode\n}): JSX.Element {\n  // If loading is a promise, unwrap it. This happens in cases where we haven't\n  // yet received the loading data from the server — which includes whether or\n  // not this layout has a loading component at all.\n  //\n  // It's OK to suspend here instead of inside the fallback because this\n  // promise will resolve simultaneously with the data for the segment itself.\n  // So it will never suspend for longer than it would have if we didn't use\n  // a Suspense fallback at all.\n  let loadingModuleData\n  if (\n    typeof loading === 'object' &&\n    loading !== null &&\n    typeof (loading as any).then === 'function'\n  ) {\n    const promiseForLoading = loading as Promise<LoadingModuleData>\n    loadingModuleData = use(promiseForLoading)\n  } else {\n    loadingModuleData = loading as LoadingModuleData\n  }\n\n  if (loadingModuleData) {\n    const loadingRsc = loadingModuleData[0]\n    const loadingStyles = loadingModuleData[1]\n    const loadingScripts = loadingModuleData[2]\n    return (\n      <Suspense\n        fallback={\n          <>\n            {loadingStyles}\n            {loadingScripts}\n            {loadingRsc}\n          </>\n        }\n      >\n        {children}\n      </Suspense>\n    )\n  }\n\n  return <>{children}</>\n}\n\n/**\n * OuterLayoutRouter handles the current segment as well as <Offscreen> rendering of other segments.\n * It can be rendered next to each other with a different `parallelRouterKey`, allowing for Parallel routes.\n */\nexport default function OuterLayoutRouter({\n  parallelRouterKey,\n  error,\n  errorStyles,\n  errorScripts,\n  templateStyles,\n  templateScripts,\n  template,\n  notFound,\n  forbidden,\n  unauthorized,\n  segmentViewBoundaries,\n}: {\n  parallelRouterKey: string\n  error: ErrorComponent | undefined\n  errorStyles: React.ReactNode | undefined\n  errorScripts: React.ReactNode | undefined\n  templateStyles: React.ReactNode | undefined\n  templateScripts: React.ReactNode | undefined\n  template: React.ReactNode\n  notFound: React.ReactNode | undefined\n  forbidden: React.ReactNode | undefined\n  unauthorized: React.ReactNode | undefined\n  segmentViewBoundaries?: React.ReactNode\n}) {\n  const context = useContext(LayoutRouterContext)\n  if (!context) {\n    throw new Error('invariant expected layout router to be mounted')\n  }\n\n  const { parentTree, parentCacheNode, parentSegmentPath, url } = context\n\n  // Get the CacheNode for this segment by reading it from the parent segment's\n  // child map.\n  const parentParallelRoutes = parentCacheNode.parallelRoutes\n  let segmentMap = parentParallelRoutes.get(parallelRouterKey)\n  // If the parallel router cache node does not exist yet, create it.\n  // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n  if (!segmentMap) {\n    segmentMap = new Map()\n    parentParallelRoutes.set(parallelRouterKey, segmentMap)\n  }\n  const parentTreeSegment = parentTree[0]\n  const segmentPath =\n    parentSegmentPath === null\n      ? // TODO: The root segment value is currently omitted from the segment\n        // path. This has led to a bunch of special cases scattered throughout\n        // the code. We should clean this up.\n        [parallelRouterKey]\n      : parentSegmentPath.concat([parentTreeSegment, parallelRouterKey])\n\n  // The \"state\" key of a segment is the one passed to React — it represents the\n  // identity of the UI tree. Whenever the state key changes, the tree is\n  // recreated and the state is reset. In the App Router model, search params do\n  // not cause state to be lost, so two segments with the same segment path but\n  // different search params should have the same state key.\n  //\n  // The \"cache\" key of a segment, however, *does* include the search params, if\n  // it's possible that the segment accessed the search params on the server.\n  // (This only applies to page segments; layout segments cannot access search\n  // params on the server.)\n  const activeTree = parentTree[1][parallelRouterKey]\n  const activeSegment = activeTree[0]\n  const activeStateKey = createRouterCacheKey(activeSegment, true) // no search params\n\n  // At each level of the route tree, not only do we render the currently\n  // active segment — we also render the last N segments that were active at\n  // this level inside a hidden <Activity> boundary, to preserve their state\n  // if or when the user navigates to them again.\n  //\n  // bfcacheEntry is a linked list of FlightRouterStates.\n  let bfcacheEntry: RouterBFCacheEntry | null = useRouterBFCache(\n    activeTree,\n    activeStateKey\n  )\n  let children: Array<React.ReactNode> = []\n  do {\n    const tree = bfcacheEntry.tree\n    const stateKey = bfcacheEntry.stateKey\n    const segment = tree[0]\n    const cacheKey = createRouterCacheKey(segment)\n\n    // Read segment path from the parallel router cache node.\n    let cacheNode = segmentMap.get(cacheKey)\n    if (cacheNode === undefined) {\n      // When data is not available during rendering client-side we need to fetch\n      // it from the server.\n      const newLazyCacheNode: LazyCacheNode = {\n        lazyData: null,\n        rsc: null,\n        prefetchRsc: null,\n        head: null,\n        prefetchHead: null,\n        parallelRoutes: new Map(),\n        loading: null,\n        navigatedAt: -1,\n      }\n\n      // Flight data fetch kicked off during render and put into the cache.\n      cacheNode = newLazyCacheNode\n      segmentMap.set(cacheKey, newLazyCacheNode)\n    }\n\n    /*\n    - Error boundary\n      - Only renders error boundary if error component is provided.\n      - Rendered for each segment to ensure they have their own error state.\n      - When gracefully degrade for bots, skip rendering error boundary.\n    - Loading boundary\n      - Only renders suspense boundary if loading components is provided.\n      - Rendered for each segment to ensure they have their own loading state.\n      - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n  */\n\n    let segmentBoundaryTriggerNode: React.ReactNode = null\n    let segmentViewStateNode: React.ReactNode = null\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      process.env.__NEXT_DEVTOOL_SEGMENT_EXPLORER\n    ) {\n      const { SegmentBoundaryTriggerNode, SegmentViewStateNode } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      const pagePrefix = normalizeAppPath(url)\n      segmentViewStateNode = (\n        <SegmentViewStateNode key={pagePrefix} page={pagePrefix} />\n      )\n\n      segmentBoundaryTriggerNode = (\n        <>\n          <SegmentBoundaryTriggerNode />\n        </>\n      )\n    }\n\n    // TODO: The loading module data for a segment is stored on the parent, then\n    // applied to each of that parent segment's parallel route slots. In the\n    // simple case where there's only one parallel route (the `children` slot),\n    // this is no different from if the loading module data where stored on the\n    // child directly. But I'm not sure this actually makes sense when there are\n    // multiple parallel routes. It's not a huge issue because you always have\n    // the option to define a narrower loading boundary for a particular slot. But\n    // this sort of smells like an implementation accident to me.\n    const loadingModuleData = parentCacheNode.loading\n    let child = (\n      <TemplateContext.Provider\n        key={stateKey}\n        value={\n          <ScrollAndFocusHandler segmentPath={segmentPath}>\n            <ErrorBoundary\n              errorComponent={error}\n              errorStyles={errorStyles}\n              errorScripts={errorScripts}\n            >\n              <LoadingBoundary loading={loadingModuleData}>\n                <HTTPAccessFallbackBoundary\n                  notFound={notFound}\n                  forbidden={forbidden}\n                  unauthorized={unauthorized}\n                >\n                  <RedirectBoundary>\n                    <InnerLayoutRouter\n                      url={url}\n                      tree={tree}\n                      cacheNode={cacheNode}\n                      segmentPath={segmentPath}\n                    />\n                    {segmentBoundaryTriggerNode}\n                  </RedirectBoundary>\n                </HTTPAccessFallbackBoundary>\n              </LoadingBoundary>\n            </ErrorBoundary>\n            {segmentViewStateNode}\n          </ScrollAndFocusHandler>\n        }\n      >\n        {templateStyles}\n        {templateScripts}\n        {template}\n      </TemplateContext.Provider>\n    )\n\n    if (process.env.NODE_ENV !== 'production') {\n      const { SegmentStateProvider } =\n        require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n\n      child = (\n        <SegmentStateProvider key={stateKey}>\n          {child}\n          {segmentViewBoundaries}\n        </SegmentStateProvider>\n      )\n    }\n\n    if (process.env.__NEXT_ROUTER_BF_CACHE) {\n      child = (\n        <Activity\n          key={stateKey}\n          mode={stateKey === activeStateKey ? 'visible' : 'hidden'}\n        >\n          {child}\n        </Activity>\n      )\n    }\n\n    children.push(child)\n\n    bfcacheEntry = bfcacheEntry.next\n  } while (bfcacheEntry !== null)\n\n  return children\n}\n","import type { FlightRouterState } from '../../server/app-render/types'\nimport type { AppRouterInstance } from '../../shared/lib/app-router-context.shared-runtime'\nimport { getCurrentAppRouterState } from './app-router-instance'\nimport { createPrefetchURL } from './app-router'\nimport {\n  FetchStrategy,\n  isPrefetchTaskDirty,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache'\nimport { createCacheKey } from './segment-cache'\nimport {\n  type PrefetchTask,\n  PrefetchPriority,\n  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n  cancelPrefetchTask,\n  reschedulePrefetchTask,\n} from './segment-cache'\nimport { startTransition } from 'react'\nimport { PrefetchKind } from './router-reducer/router-reducer-types'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\ntype LinkElement = HTMLAnchorElement | SVGAElement\n\ntype Element = LinkElement | HTMLFormElement\n\n// Properties that are shared between Link and Form instances. We use the same\n// shape for both to prevent a polymorphic de-opt in the VM.\ntype LinkOrFormInstanceShared = {\n  router: AppRouterInstance\n  fetchStrategy: PrefetchTaskFetchStrategy\n\n  isVisible: boolean\n\n  // The most recently initiated prefetch task. It may or may not have\n  // already completed. The same prefetch task object can be reused across\n  // multiple prefetches of the same link.\n  prefetchTask: PrefetchTask | null\n}\n\nexport type FormInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: null\n}\n\ntype PrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: string\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype NonPrefetchableLinkInstance = LinkOrFormInstanceShared & {\n  prefetchHref: null\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n}\n\ntype PrefetchableInstance = PrefetchableLinkInstance | FormInstance\n\nexport type LinkInstance =\n  | PrefetchableLinkInstance\n  | NonPrefetchableLinkInstance\n\n// Tracks the most recently navigated link instance. When null, indicates\n// the current navigation was not initiated by a link click.\nlet linkForMostRecentNavigation: LinkInstance | null = null\n\n// Status object indicating link is pending\nexport const PENDING_LINK_STATUS = { pending: true }\n\n// Status object indicating link is idle\nexport const IDLE_LINK_STATUS = { pending: false }\n\n// Updates the loading state when navigating between links\n// - Resets the previous link's loading state\n// - Sets the new link's loading state\n// - Updates tracking of current navigation\nexport function setLinkForCurrentNavigation(link: LinkInstance | null) {\n  startTransition(() => {\n    linkForMostRecentNavigation?.setOptimisticLinkStatus(IDLE_LINK_STATUS)\n    link?.setOptimisticLinkStatus(PENDING_LINK_STATUS)\n    linkForMostRecentNavigation = link\n  })\n}\n\n// Unmounts the current link instance from navigation tracking\nexport function unmountLinkForCurrentNavigation(link: LinkInstance) {\n  if (linkForMostRecentNavigation === link) {\n    linkForMostRecentNavigation = null\n  }\n}\n\n// Use a WeakMap to associate a Link instance with its DOM element. This is\n// used by the IntersectionObserver to track the link's visibility.\nconst prefetchable:\n  | WeakMap<Element, PrefetchableInstance>\n  | Map<Element, PrefetchableInstance> =\n  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n\n// A Set of the currently visible links. We re-prefetch visible links after a\n// cache invalidation, or when the current URL changes. It's a separate data\n// structure from the WeakMap above because only the visible links need to\n// be enumerated.\nconst prefetchableAndVisible: Set<PrefetchableInstance> = new Set()\n\n// A single IntersectionObserver instance shared by all <Link> components.\nconst observer: IntersectionObserver | null =\n  typeof IntersectionObserver === 'function'\n    ? new IntersectionObserver(handleIntersect, {\n        rootMargin: '200px',\n      })\n    : null\n\nfunction observeVisibility(element: Element, instance: PrefetchableInstance) {\n  const existingInstance = prefetchable.get(element)\n  if (existingInstance !== undefined) {\n    // This shouldn't happen because each <Link> component should have its own\n    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n    // case there's a logical error somewhere else.\n    unmountPrefetchableInstance(element)\n  }\n  // Only track prefetchable links that have a valid prefetch URL\n  prefetchable.set(element, instance)\n  if (observer !== null) {\n    observer.observe(element)\n  }\n}\n\nfunction coercePrefetchableUrl(href: string): URL | null {\n  try {\n    return createPrefetchURL(href)\n  } catch {\n    // createPrefetchURL sometimes throws an error if an invalid URL is\n    // provided, though I'm not sure if it's actually necessary.\n    // TODO: Consider removing the throw from the inner function, or change it\n    // to reportError. Or maybe the error isn't even necessary for automatic\n    // prefetches, just navigations.\n    const reportErrorFn =\n      typeof reportError === 'function' ? reportError : console.error\n    reportErrorFn(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n    return null\n  }\n}\n\nexport function mountLinkInstance(\n  element: LinkElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy,\n  prefetchEnabled: boolean,\n  setOptimisticLinkStatus: (status: { pending: boolean }) => void\n): LinkInstance {\n  if (prefetchEnabled) {\n    const prefetchURL = coercePrefetchableUrl(href)\n    if (prefetchURL !== null) {\n      const instance: PrefetchableLinkInstance = {\n        router,\n        fetchStrategy,\n        isVisible: false,\n        prefetchTask: null,\n        prefetchHref: prefetchURL.href,\n        setOptimisticLinkStatus,\n      }\n      // We only observe the link's visibility if it's prefetchable. For\n      // example, this excludes links to external URLs.\n      observeVisibility(element, instance)\n      return instance\n    }\n  }\n  // If the link is not prefetchable, we still create an instance so we can\n  // track its optimistic state (i.e. useLinkStatus).\n  const instance: NonPrefetchableLinkInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: null,\n    setOptimisticLinkStatus,\n  }\n  return instance\n}\n\nexport function mountFormInstance(\n  element: HTMLFormElement,\n  href: string,\n  router: AppRouterInstance,\n  fetchStrategy: PrefetchTaskFetchStrategy\n): void {\n  const prefetchURL = coercePrefetchableUrl(href)\n  if (prefetchURL === null) {\n    // This href is not prefetchable, so we don't track it.\n    // TODO: We currently observe/unobserve a form every time its href changes.\n    // For Links, this isn't a big deal because the href doesn't usually change,\n    // but for forms it's extremely common. We should optimize this.\n    return\n  }\n  const instance: FormInstance = {\n    router,\n    fetchStrategy,\n    isVisible: false,\n    prefetchTask: null,\n    prefetchHref: prefetchURL.href,\n    setOptimisticLinkStatus: null,\n  }\n  observeVisibility(element, instance)\n}\n\nexport function unmountPrefetchableInstance(element: Element) {\n  const instance = prefetchable.get(element)\n  if (instance !== undefined) {\n    prefetchable.delete(element)\n    prefetchableAndVisible.delete(instance)\n    const prefetchTask = instance.prefetchTask\n    if (prefetchTask !== null) {\n      cancelPrefetchTask(prefetchTask)\n    }\n  }\n  if (observer !== null) {\n    observer.unobserve(element)\n  }\n}\n\nfunction handleIntersect(entries: Array<IntersectionObserverEntry>) {\n  for (const entry of entries) {\n    // Some extremely old browsers or polyfills don't reliably support\n    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n    // really. But whatever this is fine.)\n    const isVisible = entry.intersectionRatio > 0\n    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n  }\n}\n\nexport function onLinkVisibilityChanged(element: Element, isVisible: boolean) {\n  if (process.env.NODE_ENV !== 'production') {\n    // Prefetching on viewport is disabled in development for performance\n    // reasons, because it requires compiling the target page.\n    // TODO: Investigate re-enabling this.\n    return\n  }\n\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n\n  instance.isVisible = isVisible\n  if (isVisible) {\n    prefetchableAndVisible.add(instance)\n  } else {\n    prefetchableAndVisible.delete(instance)\n  }\n  rescheduleLinkPrefetch(instance, PrefetchPriority.Default)\n}\n\nexport function onNavigationIntent(\n  element: HTMLAnchorElement | SVGAElement,\n  unstable_upgradeToDynamicPrefetch: boolean\n) {\n  const instance = prefetchable.get(element)\n  if (instance === undefined) {\n    return\n  }\n  // Prefetch the link on hover/touchstart.\n  if (instance !== undefined) {\n    if (\n      process.env.__NEXT_DYNAMIC_ON_HOVER &&\n      unstable_upgradeToDynamicPrefetch\n    ) {\n      // Switch to a full prefetch\n      instance.fetchStrategy = FetchStrategy.Full\n    }\n    rescheduleLinkPrefetch(instance, PrefetchPriority.Intent)\n  }\n}\n\nfunction rescheduleLinkPrefetch(\n  instance: PrefetchableInstance,\n  priority: PrefetchPriority.Default | PrefetchPriority.Intent\n) {\n  const existingPrefetchTask = instance.prefetchTask\n\n  if (!instance.isVisible) {\n    // Cancel any in-progress prefetch task. (If it already finished then this\n    // is a no-op.)\n    if (existingPrefetchTask !== null) {\n      cancelPrefetchTask(existingPrefetchTask)\n    }\n    // We don't need to reset the prefetchTask to null upon cancellation; an\n    // old task object can be rescheduled with reschedulePrefetchTask. This is a\n    // micro-optimization but also makes the code simpler (don't need to\n    // worry about whether an old task object is stale).\n    return\n  }\n\n  if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // The old prefetch implementation does not have different priority levels.\n    // Just schedule a new prefetch task.\n    prefetchWithOldCacheImplementation(instance)\n    return\n  }\n\n  const appRouterState = getCurrentAppRouterState()\n  if (appRouterState !== null) {\n    const treeAtTimeOfPrefetch = appRouterState.tree\n    if (existingPrefetchTask === null) {\n      // Initiate a prefetch task.\n      const nextUrl = appRouterState.nextUrl\n      const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n      instance.prefetchTask = scheduleSegmentPrefetchTask(\n        cacheKey,\n        treeAtTimeOfPrefetch,\n        instance.fetchStrategy,\n        priority,\n        null\n      )\n    } else {\n      // We already have an old task object that we can reschedule. This is\n      // effectively the same as canceling the old task and creating a new one.\n      reschedulePrefetchTask(\n        existingPrefetchTask,\n        treeAtTimeOfPrefetch,\n        instance.fetchStrategy,\n        priority\n      )\n    }\n  }\n}\n\nexport function pingVisibleLinks(\n  nextUrl: string | null,\n  tree: FlightRouterState\n) {\n  // For each currently visible link, cancel the existing prefetch task (if it\n  // exists) and schedule a new one. This is effectively the same as if all the\n  // visible links left and then re-entered the viewport.\n  //\n  // This is called when the Next-Url or the base tree changes, since those\n  // may affect the result of a prefetch task. It's also called after a\n  // cache invalidation.\n  for (const instance of prefetchableAndVisible) {\n    const task = instance.prefetchTask\n    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n      // The cache has not been invalidated, and none of the inputs have\n      // changed. Bail out.\n      continue\n    }\n    // Something changed. Cancel the existing prefetch task and schedule a\n    // new one.\n    if (task !== null) {\n      cancelPrefetchTask(task)\n    }\n    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n    instance.prefetchTask = scheduleSegmentPrefetchTask(\n      cacheKey,\n      tree,\n      instance.fetchStrategy,\n      PrefetchPriority.Default,\n      null\n    )\n  }\n}\n\nfunction prefetchWithOldCacheImplementation(instance: PrefetchableInstance) {\n  // This is the path used when the Segment Cache is not enabled.\n  if (typeof window === 'undefined') {\n    return\n  }\n\n  const doPrefetch = async () => {\n    // note that `appRouter.prefetch()` is currently sync,\n    // so we have to wrap this call in an async function to be able to catch() errors below.\n\n    let prefetchKind: PrefetchKind\n    switch (instance.fetchStrategy) {\n      case FetchStrategy.PPR: {\n        prefetchKind = PrefetchKind.AUTO\n        break\n      }\n      case FetchStrategy.Full: {\n        prefetchKind = PrefetchKind.FULL\n        break\n      }\n      case FetchStrategy.PPRRuntime: {\n        // We can only get here if Client Segment Cache is off, and in that case\n        // it shouldn't be possible for a link to request a runtime prefetch.\n        throw new InvariantError(\n          'FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled'\n        )\n      }\n      default: {\n        instance.fetchStrategy satisfies never\n        // Unreachable, but otherwise typescript will consider the variable unassigned\n        prefetchKind = undefined!\n      }\n    }\n\n    return instance.router.prefetch(instance.prefetchHref, {\n      kind: prefetchKind,\n    })\n  }\n\n  // Prefetch the page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n  doPrefetch().catch((err) => {\n    if (process.env.NODE_ENV !== 'production') {\n      // rethrow to show invalid URL errors\n      throw err\n    }\n  })\n}\n"],"names":["OuterLayoutRouter","__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE","ReactDOM","rectProperties","topOfElementInViewport","element","viewportHeight","rect","getBoundingClientRect","top","InnerScrollAndFocusHandler","handlePotentialScroll","props","focusAndScrollRef","segmentPath","apply","segmentPaths","length","some","scrollRefSegmentPath","every","segment","index","matchSegment","document","domNode","hashFragment","body","getElementById","getElementsByName","findDOMNode","Element","instance","HTMLElement","shouldSkipElement","includes","getComputedStyle","position","item","nextElementSibling","disableSmoothScrollDuringRouteTransition","scrollIntoView","htmlElement","documentElement","clientHeight","scrollTop","dontForceLayout","onlyHashChange","focus","componentDidMount","componentDidUpdate","render","children","React","Component","ScrollAndFocusHandler","context","useContext","GlobalLayoutRouterContext","InnerLayoutRouter","tree","cacheNode","url","fullTree","resolvedPrefetchRsc","prefetchRsc","rsc","useDeferredValue","resolvedRsc","then","use","lazyData","refetchTree","walkAddRefetch","segmentPathToWalk","treeToRecreate","parallelRouteKey","isLast","hasOwnProperty","subTree","undefined","slice","includeNextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","fetchServerResponse","URL","location","origin","flightRouterState","nextUrl","serverResponse","startTransition","dispatchAppRouterAction","type","ACTION_SERVER_PATCH","previousTree","unresolvedThenable","subtree","LayoutRouterContext","Provider","value","parentTree","parentCacheNode","parentSegmentPath","LoadingBoundary","loadingModuleData","loading","loadingRsc","loadingStyles","loadingScripts","Suspense","fallback","parallelRouterKey","error","errorStyles","errorScripts","templateStyles","templateScripts","template","notFound","forbidden","unauthorized","segmentViewBoundaries","parentParallelRoutes","parallelRoutes","segmentMap","get","Map","set","parentTreeSegment","concat","activeTree","activeSegment","activeStateKey","createRouterCacheKey","bfcacheEntry","useRouterBFCache","stateKey","cacheKey","newLazyCacheNode","head","prefetchHead","child","TemplateContext","ErrorBoundary","errorComponent","HTTPAccessFallbackBoundary","RedirectBoundary","push","next","IDLE_LINK_STATUS","PENDING_LINK_STATUS","mountFormInstance","mountLinkInstance","onLinkVisibilityChanged","onNavigationIntent","pingVisibleLinks","setLinkForCurrentNavigation","unmountLinkForCurrentNavigation","unmountPrefetchableInstance","linkForMostRecentNavigation","pending","link","setOptimisticLinkStatus","prefetchable","WeakMap","prefetchableAndVisible","Set","observer","IntersectionObserver","handleIntersect","entries","entry","isVisible","intersectionRatio","target","rootMargin","observeVisibility","existingInstance","observe","coercePrefetchableUrl","href","createPrefetchURL","reportErrorFn","reportError","console","router","fetchStrategy","prefetchEnabled","prefetchURL","prefetchTask","prefetchHref","delete","cancelPrefetchTask","unobserve","add","rescheduleLinkPrefetch","PrefetchPriority","Default","unstable_upgradeToDynamicPrefetch","Intent","priority","existingPrefetchTask","doPrefetch","prefetchKind","FetchStrategy","PPR","PrefetchKind","AUTO","Full","FULL","PPRRuntime","InvariantError","prefetch","kind","catch","err","task","isPrefetchTaskDirty","createCacheKey","scheduleSegmentPrefetchTask"],"sourceRoot":"","ignoreList":[]}