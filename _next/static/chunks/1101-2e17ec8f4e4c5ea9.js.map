{"version":3,"file":"static/chunks/1101-2e17ec8f4e4c5ea9.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/set-cache-busting-search-param.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/find-head-in-cache.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/prefetch-cache-utils.ts","webpack://_N_E/../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/prefetch-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/get-segment-value.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/router-reducer-types.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/restore-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/should-hard-navigate.ts","webpack://_N_E/../../../../src/client/components/router-reducer/router-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","import type { FlightRouterState } from '../../../../server/app-render/types'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { createRouterCacheKey } from '../create-router-cache-key'\n\nexport function findHeadInCache(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1]\n): [CacheNode, string, string] | null {\n  return findHeadInCacheImpl(cache, parallelRoutes, '', '')\n}\n\nfunction findHeadInCacheImpl(\n  cache: CacheNode,\n  parallelRoutes: FlightRouterState[1],\n  keyPrefix: string,\n  keyPrefixWithoutSearchParams: string\n): [CacheNode, string, string] | null {\n  const isLastItem = Object.keys(parallelRoutes).length === 0\n  if (isLastItem) {\n    // Returns the entire Cache Node of the segment whose head we will render.\n    return [cache, keyPrefix, keyPrefixWithoutSearchParams]\n  }\n\n  // First try the 'children' parallel route if it exists\n  // when starting from the \"root\", this corresponds with the main page component\n  const parallelRoutesKeys = Object.keys(parallelRoutes).filter(\n    (key) => key !== 'children'\n  )\n\n  // if we are at the root, we need to check the children slot first\n  if ('children' in parallelRoutes) {\n    parallelRoutesKeys.unshift('children')\n  }\n\n  for (const key of parallelRoutesKeys) {\n    const [segment, childParallelRoutes] = parallelRoutes[key]\n    // If the parallel is not matched and using the default segment,\n    // skip searching the head from it.\n    if (segment === DEFAULT_SEGMENT_KEY) {\n      continue\n    }\n    const childSegmentMap = cache.parallelRoutes.get(key)\n    if (!childSegmentMap) {\n      continue\n    }\n\n    const cacheKey = createRouterCacheKey(segment)\n    const cacheKeyWithoutSearchParams = createRouterCacheKey(segment, true)\n\n    const cacheNode = childSegmentMap.get(cacheKey)\n    if (!cacheNode) {\n      continue\n    }\n\n    const item = findHeadInCacheImpl(\n      cacheNode,\n      childParallelRoutes,\n      keyPrefix + '/' + cacheKey,\n      keyPrefix + '/' + cacheKeyWithoutSearchParams\n    )\n\n    if (item) {\n      return item\n    }\n  }\n\n  return null\n}\n","import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../server/app-render/types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport {\n  PrefetchKind,\n  type ReadonlyReducerState,\n  type ReducerState,\n  type ServerActionAction,\n  type ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const res = await fetch(state.canonicalUrl, {\n    method: 'POST',\n    headers: {\n      Accept: RSC_CONTENT_TYPE_HEADER,\n      [ACTION_HEADER]: actionId,\n      [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n        state.tree\n      ),\n      ...(process.env.NEXT_DEPLOYMENT_ID\n        ? {\n            'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,\n          }\n        : {}),\n      ...(nextUrl\n        ? {\n            [NEXT_URL]: nextUrl,\n          }\n        : {}),\n    },\n    body,\n  })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      { callServer, findSourceMapURL, temporaryReferences }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[3]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            undefined\n          )\n\n          mutable.cache = cache\n          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n            revalidateEntireCache(state.nextUrl, newTree)\n          } else {\n            mutable.prefetchCache = new Map()\n          }\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE && !actionRevalidated) {\n          // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n          // with the FlightData that we got from the server action for the target page, so that it's\n          // available when the page is navigated to and doesn't need to be re-fetched.\n          // We only do this if the server action didn't revalidate any data, as in that case the\n          // client cache will be cleared and the data will be re-fetched anyway.\n          // NOTE: We don't do this in the Segment Cache implementation.\n          // Dynamic data should never be placed into the cache, unless it's\n          // \"converted\" to static data using <Link prefetch={true}>. What we\n          // do instead is re-prefetch links and forms whenever the cache is\n          // invalidated.\n          createSeededPrefetchCacheEntry({\n            url: redirectLocation,\n            data: {\n              flightData,\n              canonicalUrl: undefined,\n              couldBeIntercepted: false,\n              prerendered: false,\n              postponed: false,\n              // TODO: We should be able to set this if the server action\n              // returned a fully static response.\n              staleTime: -1,\n            },\n            tree: state.tree,\n            prefetchCache: state.prefetchCache,\n            nextUrl: state.nextUrl,\n            kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,\n          })\n          mutable.prefetchCache = state.prefetchCache\n        }\n\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        reject(\n          getRedirectError(\n            hasBasePath(redirectHref)\n              ? removeBasePath(redirectHref)\n              : redirectHref,\n            redirectType || RedirectType.push\n          )\n        )\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n","import {\n  fetchServerResponse,\n  type FetchServerResponseResult,\n} from './fetch-server-response'\nimport {\n  PrefetchCacheEntryStatus,\n  type PrefetchCacheEntry,\n  PrefetchKind,\n  type ReadonlyReducerState,\n} from './router-reducer-types'\nimport { prefetchQueue } from './reducers/prefetch-reducer'\n\nconst INTERCEPTION_CACHE_KEY_MARKER = '%'\n\nexport type AliasedPrefetchCacheEntry = PrefetchCacheEntry & {\n  /** This is a special property that indicates a prefetch entry associated with a different URL\n   * was returned rather than the requested URL. This signals to the router that it should only\n   * apply the part that doesn't depend on searchParams (specifically the loading state).\n   */\n  aliased?: boolean\n}\n\n/**\n * Creates a cache key for the router prefetch cache\n *\n * @param url - The URL being navigated to\n * @param nextUrl - an internal URL, primarily used for handling rewrites. Defaults to '/'.\n * @return The generated prefetch cache key.\n */\nfunction createPrefetchCacheKeyImpl(\n  url: URL,\n  includeSearchParams: boolean,\n  prefix?: string | null\n) {\n  // Initially we only use the pathname as the cache key. We don't want to include\n  // search params so that multiple URLs with the same search parameter can re-use\n  // loading states.\n  let pathnameFromUrl = url.pathname\n\n  // RSC responses can differ based on search params, specifically in the case where we aren't\n  // returning a partial response (ie with `PrefetchKind.AUTO`).\n  // In the auto case, since loading.js & layout.js won't have access to search params,\n  // we can safely re-use that cache entry. But for full prefetches, we should not\n  // re-use the cache entry as the response may differ.\n  if (includeSearchParams) {\n    // if we have a full prefetch, we can include the search param in the key,\n    // as we'll be getting back a full response. The server might have read the search\n    // params when generating the full response.\n    pathnameFromUrl += url.search\n  }\n\n  if (prefix) {\n    return `${prefix}${INTERCEPTION_CACHE_KEY_MARKER}${pathnameFromUrl}`\n  }\n\n  return pathnameFromUrl\n}\n\nfunction createPrefetchCacheKey(\n  url: URL,\n  kind: PrefetchKind | undefined,\n  nextUrl?: string | null\n) {\n  return createPrefetchCacheKeyImpl(url, kind === PrefetchKind.FULL, nextUrl)\n}\n\nfunction getExistingCacheEntry(\n  url: URL,\n  kind: PrefetchKind = PrefetchKind.TEMPORARY,\n  nextUrl: string | null,\n  prefetchCache: Map<string, PrefetchCacheEntry>,\n  allowAliasing: boolean\n): AliasedPrefetchCacheEntry | undefined {\n  // We first check if there's a more specific interception route prefetch entry\n  // This is because when we detect a prefetch that corresponds with an interception route, we prefix it with nextUrl (see `createPrefetchCacheKey`)\n  // to avoid conflicts with other pages that may have the same URL but render different things depending on the `Next-URL` header.\n  for (const maybeNextUrl of [nextUrl, null]) {\n    const cacheKeyWithParams = createPrefetchCacheKeyImpl(\n      url,\n      true,\n      maybeNextUrl\n    )\n    const cacheKeyWithoutParams = createPrefetchCacheKeyImpl(\n      url,\n      false,\n      maybeNextUrl\n    )\n\n    // First, we check if we have a cache entry that exactly matches the URL\n    const cacheKeyToUse = url.search\n      ? cacheKeyWithParams\n      : cacheKeyWithoutParams\n\n    const existingEntry = prefetchCache.get(cacheKeyToUse)\n    if (existingEntry && allowAliasing) {\n      // We know we're returning an aliased entry when the pathname matches but the search params don't,\n      const isAliased =\n        existingEntry.url.pathname === url.pathname &&\n        existingEntry.url.search !== url.search\n\n      if (isAliased) {\n        return {\n          ...existingEntry,\n          aliased: true,\n        }\n      }\n\n      return existingEntry\n    }\n\n    // If the request contains search params, and we're not doing a full prefetch, we can return the\n    // param-less entry if it exists.\n    // This is technically covered by the check at the bottom of this function, which iterates over cache entries,\n    // but lets us arrive there quicker in the param-full case.\n    const entryWithoutParams = prefetchCache.get(cacheKeyWithoutParams)\n    if (\n      process.env.NODE_ENV !== 'development' &&\n      allowAliasing &&\n      url.search &&\n      kind !== PrefetchKind.FULL &&\n      entryWithoutParams &&\n      // We shouldn't return the aliased entry if it was relocated to a new cache key.\n      // Since it's rewritten, it could respond with a completely different loading state.\n      !entryWithoutParams.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n    ) {\n      return { ...entryWithoutParams, aliased: true }\n    }\n  }\n\n  // If we've gotten to this point, we didn't find a specific cache entry that matched\n  // the request URL.\n  // We attempt a partial match by checking if there's a cache entry with the same pathname.\n  // Regardless of what we find, since it doesn't correspond with the requested URL, we'll mark it \"aliased\".\n  // This will signal to the router that it should only apply the loading state on the prefetched data.\n  if (\n    process.env.NODE_ENV !== 'development' &&\n    kind !== PrefetchKind.FULL &&\n    allowAliasing\n  ) {\n    for (const cacheEntry of prefetchCache.values()) {\n      if (\n        cacheEntry.url.pathname === url.pathname &&\n        // We shouldn't return the aliased entry if it was relocated to a new cache key.\n        // Since it's rewritten, it could respond with a completely different loading state.\n        !cacheEntry.key.includes(INTERCEPTION_CACHE_KEY_MARKER)\n      ) {\n        return { ...cacheEntry, aliased: true }\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Returns a prefetch cache entry if one exists. Otherwise creates a new one and enqueues a fetch request\n * to retrieve the prefetch data from the server.\n */\nexport function getOrCreatePrefetchCacheEntry({\n  url,\n  nextUrl,\n  tree,\n  prefetchCache,\n  kind,\n  allowAliasing = true,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache' | 'tree'> & {\n  url: URL\n  kind?: PrefetchKind\n  allowAliasing: boolean\n}): AliasedPrefetchCacheEntry {\n  const existingCacheEntry = getExistingCacheEntry(\n    url,\n    kind,\n    nextUrl,\n    prefetchCache,\n    allowAliasing\n  )\n\n  if (existingCacheEntry) {\n    // Grab the latest status of the cache entry and update it\n    existingCacheEntry.status = getPrefetchEntryCacheStatus(existingCacheEntry)\n\n    // when `kind` is provided, an explicit prefetch was requested.\n    // if the requested prefetch is \"full\" and the current cache entry wasn't, we want to re-prefetch with the new intent\n    const switchedToFullPrefetch =\n      existingCacheEntry.kind !== PrefetchKind.FULL &&\n      kind === PrefetchKind.FULL\n\n    if (switchedToFullPrefetch) {\n      // If we switched to a full prefetch, validate that the existing cache entry contained partial data.\n      // It's possible that the cache entry was seeded with full data but has a cache type of \"auto\" (ie when cache entries\n      // are seeded but without a prefetch intent)\n      existingCacheEntry.data.then((prefetchResponse) => {\n        const isFullPrefetch =\n          Array.isArray(prefetchResponse.flightData) &&\n          prefetchResponse.flightData.some((flightData) => {\n            // If we started rendering from the root and we returned RSC data (seedData), we already had a full prefetch.\n            return flightData.isRootRender && flightData.seedData !== null\n          })\n\n        if (!isFullPrefetch) {\n          return createLazyPrefetchEntry({\n            tree,\n            url,\n            nextUrl,\n            prefetchCache,\n            // If we didn't get an explicit prefetch kind, we want to set a temporary kind\n            // rather than assuming the same intent as the previous entry, to be consistent with how we\n            // lazily create prefetch entries when intent is left unspecified.\n            kind: kind ?? PrefetchKind.TEMPORARY,\n          })\n        }\n      })\n    }\n\n    // If the existing cache entry was marked as temporary, it means it was lazily created when attempting to get an entry,\n    // where we didn't have the prefetch intent. Now that we have the intent (in `kind`), we want to update the entry to the more accurate kind.\n    if (kind && existingCacheEntry.kind === PrefetchKind.TEMPORARY) {\n      existingCacheEntry.kind = kind\n    }\n\n    // We've determined that the existing entry we found is still valid, so we return it.\n    return existingCacheEntry\n  }\n\n  // If we didn't return an entry, create a new one.\n  return createLazyPrefetchEntry({\n    tree,\n    url,\n    nextUrl,\n    prefetchCache,\n    kind: kind || PrefetchKind.TEMPORARY,\n  })\n}\n\n/*\n * Used to take an existing cache entry and prefix it with the nextUrl, if it exists.\n * This ensures that we don't have conflicting cache entries for the same URL (as is the case with route interception).\n */\nfunction prefixExistingPrefetchCacheEntry({\n  url,\n  nextUrl,\n  prefetchCache,\n  existingCacheKey,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'prefetchCache'> & {\n  url: URL\n  existingCacheKey: string\n}) {\n  const existingCacheEntry = prefetchCache.get(existingCacheKey)\n  if (!existingCacheEntry) {\n    // no-op -- there wasn't an entry to move\n    return\n  }\n\n  const newCacheKey = createPrefetchCacheKey(\n    url,\n    existingCacheEntry.kind,\n    nextUrl\n  )\n  prefetchCache.set(newCacheKey, { ...existingCacheEntry, key: newCacheKey })\n  prefetchCache.delete(existingCacheKey)\n\n  return newCacheKey\n}\n\n/**\n * Use to seed the prefetch cache with data that has already been fetched.\n */\nexport function createSeededPrefetchCacheEntry({\n  nextUrl,\n  tree,\n  prefetchCache,\n  url,\n  data,\n  kind,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  data: FetchServerResponseResult\n  kind: PrefetchKind\n}) {\n  // The initial cache entry technically includes full data, but it isn't explicitly prefetched -- we just seed the\n  // prefetch cache so that we can skip an extra prefetch request later, since we already have the data.\n  // if the prefetch corresponds with an interception route, we use the nextUrl to prefix the cache key\n  const prefetchCacheKey = data.couldBeIntercepted\n    ? createPrefetchCacheKey(url, kind, nextUrl)\n    : createPrefetchCacheKey(url, kind)\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data: Promise.resolve(data),\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: Date.now(),\n    staleTime: data.staleTime,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  } satisfies PrefetchCacheEntry\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\n/**\n * Creates a prefetch entry entry and enqueues a fetch request to retrieve the data.\n */\nfunction createLazyPrefetchEntry({\n  url,\n  kind,\n  tree,\n  nextUrl,\n  prefetchCache,\n}: Pick<ReadonlyReducerState, 'nextUrl' | 'tree' | 'prefetchCache'> & {\n  url: URL\n  kind: PrefetchKind\n}): PrefetchCacheEntry {\n  const prefetchCacheKey = createPrefetchCacheKey(url, kind)\n\n  // initiates the fetch request for the prefetch and attaches a listener\n  // to the promise to update the prefetch cache entry when the promise resolves (if necessary)\n  const data = prefetchQueue.enqueue(() =>\n    fetchServerResponse(url, {\n      flightRouterState: tree,\n      nextUrl,\n      prefetchKind: kind,\n    }).then((prefetchResponse) => {\n      // TODO: `fetchServerResponse` should be more tighly coupled to these prefetch cache operations\n      // to avoid drift between this cache key prefixing logic\n      // (which is currently directly influenced by the server response)\n      let newCacheKey\n\n      if (prefetchResponse.couldBeIntercepted) {\n        // Determine if we need to prefix the cache key with the nextUrl\n        newCacheKey = prefixExistingPrefetchCacheEntry({\n          url,\n          existingCacheKey: prefetchCacheKey,\n          nextUrl,\n          prefetchCache,\n        })\n      }\n\n      // If the prefetch was a cache hit, we want to update the existing cache entry to reflect that it was a full prefetch.\n      // This is because we know that a static response will contain the full RSC payload, and can be updated to respect the `static`\n      // staleTime.\n      if (prefetchResponse.prerendered) {\n        const existingCacheEntry = prefetchCache.get(\n          // if we prefixed the cache key due to route interception, we want to use the new key. Otherwise we use the original key\n          newCacheKey ?? prefetchCacheKey\n        )\n        if (existingCacheEntry) {\n          existingCacheEntry.kind = PrefetchKind.FULL\n          if (prefetchResponse.staleTime !== -1) {\n            // This is the stale time that was collected by the server during\n            // static generation. Use this in place of the default stale time.\n            existingCacheEntry.staleTime = prefetchResponse.staleTime\n          }\n        }\n      }\n\n      return prefetchResponse\n    })\n  )\n\n  const prefetchEntry = {\n    treeAtTimeOfPrefetch: tree,\n    data,\n    kind,\n    prefetchTime: Date.now(),\n    lastUsedTime: null,\n    staleTime: -1,\n    key: prefetchCacheKey,\n    status: PrefetchCacheEntryStatus.fresh,\n    url,\n  }\n\n  prefetchCache.set(prefetchCacheKey, prefetchEntry)\n\n  return prefetchEntry\n}\n\nexport function prunePrefetchCache(\n  prefetchCache: ReadonlyReducerState['prefetchCache']\n) {\n  for (const [href, prefetchCacheEntry] of prefetchCache) {\n    if (\n      getPrefetchEntryCacheStatus(prefetchCacheEntry) ===\n      PrefetchCacheEntryStatus.expired\n    ) {\n      prefetchCache.delete(href)\n    }\n  }\n}\n\n// These values are set by `define-env-plugin` (based on `nextConfig.experimental.staleTimes`)\n// and default to 5 minutes (static) / 0 seconds (dynamic)\nexport const DYNAMIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_DYNAMIC_STALETIME) * 1000\n\nexport const STATIC_STALETIME_MS =\n  Number(process.env.__NEXT_CLIENT_ROUTER_STATIC_STALETIME) * 1000\n\nfunction getPrefetchEntryCacheStatus({\n  kind,\n  prefetchTime,\n  lastUsedTime,\n}: PrefetchCacheEntry): PrefetchCacheEntryStatus {\n  // We will re-use the cache entry data for up to the `dynamic` staletime window.\n  if (Date.now() < (lastUsedTime ?? prefetchTime) + DYNAMIC_STALETIME_MS) {\n    return lastUsedTime\n      ? PrefetchCacheEntryStatus.reusable\n      : PrefetchCacheEntryStatus.fresh\n  }\n\n  // For \"auto\" prefetching, we'll re-use only the loading boundary for up to `static` staletime window.\n  // A stale entry will only re-use the `loading` boundary, not the full data.\n  // This will trigger a \"lazy fetch\" for the full data.\n  if (kind === PrefetchKind.AUTO) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.stale\n    }\n  }\n\n  // for \"full\" prefetching, we'll re-use the cache entry data for up to `static` staletime window.\n  if (kind === PrefetchKind.FULL) {\n    if (Date.now() < prefetchTime + STATIC_STALETIME_MS) {\n      return PrefetchCacheEntryStatus.reusable\n    }\n  }\n\n  return PrefetchCacheEntryStatus.expired\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  navigatedAt: number\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  navigatedAt,\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then(({ flightData }) => {\n      if (typeof flightData !== 'string') {\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(\n            navigatedAt,\n            updatedCache,\n            updatedCache,\n            flightDataPath\n          )\n        }\n      } else {\n        // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      navigatedAt,\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n","import type {\n  PrefetchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport { PromiseQueue } from '../../promise-queue'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nexport const prefetchQueue = new PromiseQueue(5)\n\nexport const prefetchReducer = process.env.__NEXT_CLIENT_SEGMENT_CACHE\n  ? identityReducerWhenSegmentCacheIsEnabled\n  : prefetchReducerImpl\n\nfunction identityReducerWhenSegmentCacheIsEnabled<T>(state: T): T {\n  // Unlike the old implementation, the Segment Cache doesn't store its data in\n  // the router reducer state.\n  //\n  // This shouldn't be reachable because we wrap the prefetch API in a check,\n  // too, which prevents the action from being dispatched. But it's here for\n  // clarity + code elimination.\n  return state\n}\n\nfunction prefetchReducerImpl(\n  state: ReadonlyReducerState,\n  action: PrefetchAction\n): ReducerState {\n  // let's prune the prefetch cache before we do anything else\n  prunePrefetchCache(state.prefetchCache)\n\n  const { url } = action\n\n  getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    prefetchCache: state.prefetchCache,\n    kind: action.kind,\n    tree: state.tree,\n    allowAliasing: true,\n  })\n\n  return state\n}\n","import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  const navigatedAt = Date.now()\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n        const applied = applyFlightData(\n          navigatedAt,\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n","import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\nimport { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'\nimport {\n  navigate as navigateUsingSegmentCache,\n  NavigationResultTag,\n  type NavigationResult,\n} from '../../segment-cache'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =\n    action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // (Very Early Experimental Feature) Segment Cache\n    //\n    // Bypass the normal prefetch cache and use the new per-segment cache\n    // implementation instead. This is only supported if PPR is enabled, too.\n    //\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const result = navigateUsingSegmentCache(\n      url,\n      state.cache,\n      state.tree,\n      state.nextUrl,\n      shouldScroll\n    )\n    return handleNavigationResult(url, state, mutable, pendingPush, result)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    prefetchCache: state.prefetchCache,\n    allowAliasing,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) => {\n      const navigatedAt = Date.now()\n\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = navigatedAt\n        isFirstRead = true\n      }\n\n      if (prefetchValues.aliased) {\n        // When alias is enabled, search param may not be included in the canonicalUrl.\n        // But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.\n        const urlWithCanonicalPathname = new URL(url.href)\n        if (canonicalUrlOverride) {\n          urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname\n        }\n\n        const result = handleAliasedPrefetchEntry(\n          navigatedAt,\n          state,\n          flightData,\n          urlWithCanonicalPathname,\n          mutable\n        )\n\n        // We didn't return new router state because we didn't apply the aliased entry for some reason.\n        // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n        // will create an on-demand prefetch entry.\n        if (result === false) {\n          return navigateReducer(state, { ...action, allowAliasing: false })\n        }\n\n        return result\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      const updatedCanonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n\n      const onlyHashChange =\n        !!hash &&\n        state.canonicalUrl.split('#', 1)[0] ===\n          updatedCanonicalUrl.split('#', 1)[0]\n\n      // If only the hash has changed, the server hasn't sent us any new data. We can just update\n      // the mutable properties responsible for URL and scroll handling and return early.\n      if (onlyHashChange) {\n        mutable.onlyHashChange = true\n        mutable.canonicalUrl = updatedCanonicalUrl\n        mutable.shouldScroll = shouldScroll\n        mutable.hashFragment = hash\n        mutable.scrollableSegments = []\n        return handleMutable(state, mutable)\n      }\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const normalizedFlightData of flightData) {\n        const {\n          pathToSegment: flightSegmentPath,\n          seedData,\n          head,\n          isHeadPartial,\n          isRootRender,\n        } = normalizedFlightData\n        let treePatch = normalizedFlightData.tree\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (\n            // This is just a paranoid check. When a route is PPRed, the server\n            // will send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via startPPRNavigation. The current structure is just\n            // an incremental step.\n            seedData &&\n            isRootRender &&\n            postponed\n          ) {\n            const task = startPPRNavigation(\n              navigatedAt,\n              currentCache,\n              currentTree,\n              treePatch,\n              seedData,\n              head,\n              isHeadPartial,\n              false,\n              scrollableSegments\n            )\n\n            if (task !== null) {\n              if (task.route === null) {\n                // Detected a change to the root layout. Perform an full-\n                // page navigation.\n                return handleExternalUrl(state, mutable, href, pendingPush)\n              }\n              // Use the tree computed by startPPRNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n              if (newCache !== null) {\n                // We've created a new Cache Node tree that contains a prefetched\n                // version of the next page. This can be rendered instantly.\n                mutable.cache = newCache\n              }\n              const dynamicRequestTree = task.dynamicRequestTree\n              if (dynamicRequestTree !== null) {\n                // The prefetched tree has dynamic holes in it. We initiate a\n                // dynamic request to fill them in.\n                //\n                // Do not block on the result. We'll immediately render the Cache\n                // Node tree and suspend on the dynamic parts. When the request\n                // comes in, we'll fill in missing data and ping React to\n                // re-render. Unlike the lazy fetching model in the non-PPR\n                // implementation, this is modeled as a single React update +\n                // streaming, rather than multiple top-level updates. (However,\n                // even in the new model, we'll still need to sometimes update the\n                // root multiple times per navigation, like if the server sends us\n                // a different response than we expected. For now, we revert back\n                // to the lazy fetching mechanism in that case.)\n                const dynamicRequest = fetchServerResponse(\n                  new URL(updatedCanonicalUrl, url.origin),\n                  {\n                    flightRouterState: dynamicRequestTree,\n                    nextUrl: state.nextUrl,\n                  }\n                )\n\n                listenForDynamicRequest(task, dynamicRequest)\n                // We store the dynamic request on the `lazyData` property of the CacheNode\n                // because we're not going to await the dynamic request here. Since we're not blocking\n                // on the dynamic request, `layout-router` will\n                // task.node.lazyData = dynamicRequest\n              } else {\n                // The prefetched tree does not contain dynamic holes  it's\n                // fully static. We can skip the dynamic request.\n              }\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = treePatch\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n              return handleExternalUrl(state, mutable, href, pendingPush)\n            }\n\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n\n              // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = navigatedAt\n            } else {\n              applied = applyFlightData(\n                navigatedAt,\n                currentCache,\n                cache,\n                normalizedFlightData,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n              // If we applied the cache, we update the \"current cache\" value so any other\n              // segments in the FlightDataPath will be able to reference the updated cache.\n              currentCache = cache\n            }\n\n            for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n              const scrollableSegmentPath = [\n                ...flightSegmentPath,\n                ...subSegment,\n              ]\n              // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n              if (\n                scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n                DEFAULT_SEGMENT_KEY\n              ) {\n                scrollableSegments.push(scrollableSegmentPath)\n              }\n            }\n          }\n\n          currentTree = newTree\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = updatedCanonicalUrl\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import type { Segment } from '../../../../server/app-render/types'\n\nexport function getSegmentValue(segment: Segment) {\n  return Array.isArray(segment) ? segment[1] : segment\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const {\n    serverResponse: { flightData, canonicalUrl: canonicalUrlOverride },\n    navigatedAt,\n  } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof flightData === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      flightData,\n      state.pushRef.pendingPush\n    )\n  }\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    const canonicalUrlOverrideHref = canonicalUrlOverride\n      ? createHrefFromUrl(canonicalUrlOverride)\n      : undefined\n\n    if (canonicalUrlOverrideHref) {\n      mutable.canonicalUrl = canonicalUrlOverrideHref\n    }\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, tree } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  const treeToRestore = tree || state.tree\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    prefetchCache: state.prefetchCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n  }\n}\n","import type {\n  FlightRouterState,\n  FlightDataPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\n\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(\n  flightSegmentPath: FlightDataPath,\n  flightRouterState: FlightRouterState\n): boolean {\n  const [segment, parallelRoutes] = flightRouterState\n  // TODO-APP: Check if `as` can be replaced.\n  const [currentSegment, parallelRouteKey] = flightSegmentPath as [\n    Segment,\n    string,\n  ]\n\n  // Check if current segment matches the existing segment.\n  if (!matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true\n    }\n\n    // If the existing segment did not match soft navigation is triggered.\n    return false\n  }\n  const lastSegment = flightSegmentPath.length <= 2\n\n  if (lastSegment) {\n    return false\n  }\n\n  return shouldHardNavigate(\n    getNextFlightSegmentPath(flightSegmentPath),\n    parallelRoutes[parallelRouteKey]\n  )\n}\n","import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_PREFETCH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { prefetchReducer } from './reducers/prefetch-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_PREFETCH: {\n      return prefetchReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n","import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport { revalidateEntireCache } from '../../segment-cache'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  const navigatedAt = Date.now()\n  return cache.lazyData.then(\n    async ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const loading = cacheNodeSeedData[3]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            undefined\n          )\n          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n            revalidateEntireCache(state.nextUrl, newTree)\n          } else {\n            mutable.prefetchCache = new Map()\n          }\n        }\n\n        await refreshInactiveParallelSegments({\n          navigatedAt,\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","computeCacheBustingSearchParam","uniqueCacheKey","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","pairs","rawQuery","startsWith","slice","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join","findHeadInCache","cache","parallelRoutes","findHeadInCacheImpl","keyPrefix","keyPrefixWithoutSearchParams","isLastItem","Object","keys","parallelRoutesKeys","key","unshift","segment","childParallelRoutes","DEFAULT_SEGMENT_KEY","childSegmentMap","get","cacheKey","createRouterCacheKey","cacheKeyWithoutSearchParams","cacheNode","item","serverActionReducer","createFromFetch","createFromFetchBrowser","NO_REVALIDATED_PARTS","paths","tag","cookie","state","action","resolve","reject","mutable","currentTree","tree","preserveCustomHistoryState","nextUrl","hasInterceptionRouteInCurrentTree","navigatedAt","Date","now","fetchServerAction","info","usedArgs","body","res","redirectHeader","redirectType","isPrerender","revalidatedParts","revalidatedHeader","contentType","isRscResponse","actionResult","actionFlightData","response","encodeReply","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","extractInfoFromServerReferenceId","type","omitUnusedArgs","fetch","canonicalUrl","method","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","prepareFlightRouterStateForRequest","process","unrecognizedActionHeader","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","_redirectType","location","RedirectType","replace","undefined","NEXT_IS_PRERENDER_HEADER","JSON","parse","e","redirectLocation","assignLocation","URL","window","href","status","text","message","Promise","callServer","findSourceMapURL","a","normalizeFlightData","f","then","cacheNodeSeedData","head","newTree","flightData","pushRef","pendingPush","redirectHref","createHrefFromUrl","handleExternalUrl","actionRevalidated","treePatch","normalizedFlightData","seedData","isRootRender","applyRouterStatePatchToTree","handleSegmentMismatch","isNavigatingToNewRootLayout","rsc","createEmptyCacheNode","prefetchRsc","loading","fillLazyItemsTillLeafWithHead","prefetchCache","Map","refreshInactiveParallelSegments","updatedTree","updatedCache","includeNextUrl","Boolean","patchedTree","createSeededPrefetchCacheEntry","data","couldBeIntercepted","prerendered","postponed","staleTime","kind","PrefetchKind","FULL","AUTO","getRedirectError","hasBasePath","removeBasePath","handleMutable","DYNAMIC_STALETIME_MS","STATIC_STALETIME_MS","getOrCreatePrefetchCacheEntry","prunePrefetchCache","createPrefetchCacheKeyImpl","includeSearchParams","prefix","pathnameFromUrl","pathname","createPrefetchCacheKey","existingCacheEntry","allowAliasing","getExistingCacheEntry","TEMPORARY","maybeNextUrl","cacheKeyWithParams","cacheKeyWithoutParams","cacheKeyToUse","existingEntry","isAliased","aliased","entryWithoutParams","includes","INTERCEPTION_CACHE_KEY_MARKER","values","cacheEntry","getPrefetchEntryCacheStatus","prefetchResponse","isFullPrefetch","Array","isArray","some","createLazyPrefetchEntry","prefetchCacheKey","prefetchEntry","treeAtTimeOfPrefetch","prefetchTime","lastUsedTime","PrefetchCacheEntryStatus","fresh","set","prefetchQueue","enqueue","fetchServerResponse","flightRouterState","prefetchKind","newCacheKey","prefixExistingPrefetchCacheEntry","existingCacheKey","delete","prefetchCacheEntry","expired","Number","reusable","stale","addRefreshMarkerToActiveParallelSegments","path","refetchMarker","PAGE_SEGMENT_KEY","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","fetchPromises","fetchPromise","parallelFetchPromise","rootTree","refetchPath","has","add","origin","flightDataPath","applyFlightData","all","prefetchReducer","PromiseQueue","prefetchReducerImpl","identityReducerWhenSegmentCacheIsEnabled","hmrRefreshReducer","hmrRefreshReducerNoop","_action","hmrRefreshReducerImpl","generateSegmentsFromPatch","navigateReducer","isExternalUrl","navigateType","shouldScroll","toString","document","getElementById","prefetchValues","bump","canonicalUrlOverride","isFirstRead","urlWithCanonicalPathname","result","handleAliasedPrefetchEntry","updatedCanonicalUrl","onlyHashChange","hashFragment","scrollableSegments","currentCache","pathToSegment","isHeadPartial","flightSegmentPathWithLeadingEmpty","flightSegmentPath","task","startPPRNavigation","route","patchedRouterState","newCache","node","dynamicRequestTree","dynamicRequest","listenForDynamicRequest","applied","triggerLazyFetchForLeafSegments","appliedPatch","segmentPathsToFill","map","segmentPaths","clearCacheNodeDataForSegmentPath","shouldHardNavigate","invalidateCacheBelowFlightSegmentPath","subSegment","scrollableSegmentPath","mpaNavigation","flightRouterPatch","segments","entries","parallelRouteKey","parallelRoute","childSegment","getSegmentValue","serverPatchReducer","serverResponse","segmentPath","canonicalUrlOverrideHref","ACTION_HMR_REFRESH","ACTION_NAVIGATE","ACTION_PREFETCH","ACTION_REFRESH","ACTION_RESTORE","ACTION_SERVER_ACTION","ACTION_SERVER_PATCH","restoreReducer","extractPathFromFlightRouterState","treeToRestore","oldCache","focusAndScrollRef","currentSegment","matchSegment","getNextFlightSegmentPath","reducer","clientReducer","serverReducer","refreshReducer","lazyData","isInterceptionRouteAppPath"],"sourceRoot":"","ignoreList":[]}