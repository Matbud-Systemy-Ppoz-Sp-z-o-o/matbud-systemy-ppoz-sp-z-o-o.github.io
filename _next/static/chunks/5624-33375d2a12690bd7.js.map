{"version":3,"file":"static/chunks/5624-33375d2a12690bd7.js","mappings":"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","sources":["webpack://_N_E/../../src/client/app-next.ts","webpack://_N_E/../../../src/client/components/is-next-router-error.ts","webpack://_N_E/../../../src/client/components/app-router-instance.ts","webpack://_N_E/../../../src/client/components/handle-isr-error.tsx","webpack://_N_E/../../../src/client/components/app-router.tsx","webpack://_N_E/../../../src/client/components/client-segment.tsx","webpack://_N_E/../../src/client/app-webpack.ts","webpack://_N_E/../../../../src/client/components/errors/root-error-boundary.tsx","webpack://_N_E/../../../../src/client/components/http-access-fallback/http-access-fallback.ts","webpack://_N_E/../../../src/client/components/bfcache.ts","webpack://_N_E/../../../src/client/components/app-router-announcer.tsx","webpack://_N_E/../../../src/client/components/app-router-headers.ts","webpack://_N_E/../../../../src/client/components/builtin/global-error.tsx","webpack://_N_E/../../../../src/client/components/http-access-fallback/error-boundary.tsx","webpack://_N_E/../../src/client/assign-location.ts","webpack://_N_E/../../../src/client/components/forbidden.ts","webpack://_N_E/../../../../src/client/components/errors/graceful-degrade-boundary.tsx","webpack://_N_E/../../../src/client/components/client-page.tsx","webpack://_N_E/../../../src/client/components/error-boundary.tsx"],"sourcesContent":["// This import must go first because it needs to patch webpack chunk loading\n// before React patches chunk loading.\nimport './app-webpack'\nimport { appBootstrap } from './app-bootstrap'\n\nconst instrumentationHooks =\n  // eslint-disable-next-line @next/internal/typechecked-require -- not a module\n  require('../lib/require-instrumentation-client')\n\nappBootstrap(() => {\n  const { hydrate } = require('./app-index') as typeof import('./app-index')\n  // Include app-router and layout-router in the main chunk\n  // eslint-disable-next-line @next/internal/typechecked-require -- Why not relative imports?\n  require('next/dist/client/components/app-router')\n  // eslint-disable-next-line @next/internal/typechecked-require -- Why not relative imports?\n  require('next/dist/client/components/layout-router')\n  hydrate(instrumentationHooks)\n})\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","import {\n  type AppRouterState,\n  type ReducerActions,\n  type ReducerState,\n  ACTION_REFRESH,\n  ACTION_SERVER_ACTION,\n  ACTION_NAVIGATE,\n  ACTION_RESTORE,\n  type NavigateAction,\n  ACTION_HMR_REFRESH,\n  PrefetchKind,\n  ACTION_PREFETCH,\n} from './router-reducer/router-reducer-types'\nimport { reducer } from './router-reducer/router-reducer'\nimport { startTransition } from 'react'\nimport { isThenable } from '../../shared/lib/is-thenable'\nimport {\n  FetchStrategy,\n  prefetch as prefetchWithSegmentCache,\n  type PrefetchTaskFetchStrategy,\n} from './segment-cache'\nimport { dispatchAppRouterAction } from './use-action-queue'\nimport { addBasePath } from '../add-base-path'\nimport { createPrefetchURL, isExternalURL } from './app-router'\nimport { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'\nimport type {\n  AppRouterInstance,\n  NavigateOptions,\n  PrefetchOptions,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport { setLinkForCurrentNavigation, type LinkInstance } from './links'\nimport type { FlightRouterState } from '../../server/app-render/types'\nimport type { ClientInstrumentationHooks } from '../app-index'\nimport type { GlobalErrorComponent } from './builtin/global-error'\n\nexport type DispatchStatePromise = React.Dispatch<ReducerState>\n\nexport type AppRouterActionQueue = {\n  state: AppRouterState\n  dispatch: (payload: ReducerActions, setState: DispatchStatePromise) => void\n  action: (state: AppRouterState, action: ReducerActions) => ReducerState\n\n  onRouterTransitionStart:\n    | ((url: string, type: 'push' | 'replace' | 'traverse') => void)\n    | null\n\n  pending: ActionQueueNode | null\n  needsRefresh?: boolean\n  last: ActionQueueNode | null\n}\n\nexport type GlobalErrorState = [\n  GlobalError: GlobalErrorComponent,\n  styles: React.ReactNode,\n]\n\nexport type ActionQueueNode = {\n  payload: ReducerActions\n  next: ActionQueueNode | null\n  resolve: (value: ReducerState) => void\n  reject: (err: Error) => void\n  discarded?: boolean\n}\n\nfunction runRemainingActions(\n  actionQueue: AppRouterActionQueue,\n  setState: DispatchStatePromise\n) {\n  if (actionQueue.pending !== null) {\n    actionQueue.pending = actionQueue.pending.next\n    if (actionQueue.pending !== null) {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      runAction({\n        actionQueue,\n        action: actionQueue.pending,\n        setState,\n      })\n    } else {\n      // No more actions are pending, check if a refresh is needed\n      if (actionQueue.needsRefresh) {\n        actionQueue.needsRefresh = false\n        actionQueue.dispatch(\n          {\n            type: ACTION_REFRESH,\n            origin: window.location.origin,\n          },\n          setState\n        )\n      }\n    }\n  }\n}\n\nasync function runAction({\n  actionQueue,\n  action,\n  setState,\n}: {\n  actionQueue: AppRouterActionQueue\n  action: ActionQueueNode\n  setState: DispatchStatePromise\n}) {\n  const prevState = actionQueue.state\n\n  actionQueue.pending = action\n\n  const payload = action.payload\n  const actionResult = actionQueue.action(prevState, payload)\n\n  function handleResult(nextState: AppRouterState) {\n    // if we discarded this action, the state should also be discarded\n    if (action.discarded) {\n      return\n    }\n\n    actionQueue.state = nextState\n\n    runRemainingActions(actionQueue, setState)\n    action.resolve(nextState)\n  }\n\n  // if the action is a promise, set up a callback to resolve it\n  if (isThenable(actionResult)) {\n    actionResult.then(handleResult, (err) => {\n      runRemainingActions(actionQueue, setState)\n      action.reject(err)\n    })\n  } else {\n    handleResult(actionResult)\n  }\n}\n\nfunction dispatchAction(\n  actionQueue: AppRouterActionQueue,\n  payload: ReducerActions,\n  setState: DispatchStatePromise\n) {\n  let resolvers: {\n    resolve: (value: ReducerState) => void\n    reject: (reason: any) => void\n  } = { resolve: setState, reject: () => {} }\n\n  // most of the action types are async with the exception of restore\n  // it's important that restore is handled quickly since it's fired on the popstate event\n  // and we don't want to add any delay on a back/forward nav\n  // this only creates a promise for the async actions\n  if (payload.type !== ACTION_RESTORE) {\n    // Create the promise and assign the resolvers to the object.\n    const deferredPromise = new Promise<AppRouterState>((resolve, reject) => {\n      resolvers = { resolve, reject }\n    })\n\n    startTransition(() => {\n      // we immediately notify React of the pending promise -- the resolver is attached to the action node\n      // and will be called when the associated action promise resolves\n      setState(deferredPromise)\n    })\n  }\n\n  const newAction: ActionQueueNode = {\n    payload,\n    next: null,\n    resolve: resolvers.resolve,\n    reject: resolvers.reject,\n  }\n\n  // Check if the queue is empty\n  if (actionQueue.pending === null) {\n    // The queue is empty, so add the action and start it immediately\n    // Mark this action as the last in the queue\n    actionQueue.last = newAction\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else if (\n    payload.type === ACTION_NAVIGATE ||\n    payload.type === ACTION_RESTORE\n  ) {\n    // Navigations (including back/forward) take priority over any pending actions.\n    // Mark the pending action as discarded (so the state is never applied) and start the navigation action immediately.\n    actionQueue.pending.discarded = true\n\n    // The rest of the current queue should still execute after this navigation.\n    // (Note that it can't contain any earlier navigations, because we always put those into `actionQueue.pending` by calling `runAction`)\n    newAction.next = actionQueue.pending.next\n\n    // if the pending action was a server action, mark the queue as needing a refresh once events are processed\n    if (actionQueue.pending.payload.type === ACTION_SERVER_ACTION) {\n      actionQueue.needsRefresh = true\n    }\n\n    runAction({\n      actionQueue,\n      action: newAction,\n      setState,\n    })\n  } else {\n    // The queue is not empty, so add the action to the end of the queue\n    // It will be started by runRemainingActions after the previous action finishes\n    if (actionQueue.last !== null) {\n      actionQueue.last.next = newAction\n    }\n    actionQueue.last = newAction\n  }\n}\n\nlet globalActionQueue: AppRouterActionQueue | null = null\n\nexport function createMutableActionQueue(\n  initialState: AppRouterState,\n  instrumentationHooks: ClientInstrumentationHooks | null\n): AppRouterActionQueue {\n  const actionQueue: AppRouterActionQueue = {\n    state: initialState,\n    dispatch: (payload: ReducerActions, setState: DispatchStatePromise) =>\n      dispatchAction(actionQueue, payload, setState),\n    action: async (state: AppRouterState, action: ReducerActions) => {\n      const result = reducer(state, action)\n      return result\n    },\n    pending: null,\n    last: null,\n    onRouterTransitionStart:\n      instrumentationHooks !== null &&\n      typeof instrumentationHooks.onRouterTransitionStart === 'function'\n        ? // This profiling hook will be called at the start of every navigation.\n          instrumentationHooks.onRouterTransitionStart\n        : null,\n  }\n\n  if (typeof window !== 'undefined') {\n    // The action queue is lazily created on hydration, but after that point\n    // it doesn't change. So we can store it in a global rather than pass\n    // it around everywhere via props/context.\n    if (globalActionQueue !== null) {\n      throw new Error(\n        'Internal Next.js Error: createMutableActionQueue was called more ' +\n          'than once'\n      )\n    }\n    globalActionQueue = actionQueue\n  }\n\n  return actionQueue\n}\n\nexport function getCurrentAppRouterState(): AppRouterState | null {\n  return globalActionQueue !== null ? globalActionQueue.state : null\n}\n\nfunction getAppRouterActionQueue(): AppRouterActionQueue {\n  if (globalActionQueue === null) {\n    throw new Error(\n      'Internal Next.js error: Router action dispatched before initialization.'\n    )\n  }\n  return globalActionQueue\n}\n\nfunction getProfilingHookForOnNavigationStart() {\n  if (globalActionQueue !== null) {\n    return globalActionQueue.onRouterTransitionStart\n  }\n  return null\n}\n\nexport function dispatchNavigateAction(\n  href: string,\n  navigateType: NavigateAction['navigateType'],\n  shouldScroll: boolean,\n  linkInstanceRef: LinkInstance | null\n): void {\n  // TODO: This stuff could just go into the reducer. Leaving as-is for now\n  // since we're about to rewrite all the router reducer stuff anyway.\n  const url = new URL(addBasePath(href), location.href)\n  if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n    window.next.__pendingUrl = url\n  }\n\n  setLinkForCurrentNavigation(linkInstanceRef)\n\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, navigateType)\n  }\n\n  dispatchAppRouterAction({\n    type: ACTION_NAVIGATE,\n    url,\n    isExternalUrl: isExternalURL(url),\n    locationSearch: location.search,\n    shouldScroll,\n    navigateType,\n    allowAliasing: true,\n  })\n}\n\nexport function dispatchTraverseAction(\n  href: string,\n  tree: FlightRouterState | undefined\n) {\n  const onRouterTransitionStart = getProfilingHookForOnNavigationStart()\n  if (onRouterTransitionStart !== null) {\n    onRouterTransitionStart(href, 'traverse')\n  }\n  dispatchAppRouterAction({\n    type: ACTION_RESTORE,\n    url: new URL(href),\n    tree,\n  })\n}\n\n/**\n * The app router that is exposed through `useRouter`. These are public API\n * methods. Internal Next.js code should call the lower level methods directly\n * (although there's lots of existing code that doesn't do that).\n */\nexport const publicAppRouterInstance: AppRouterInstance = {\n  back: () => window.history.back(),\n  forward: () => window.history.forward(),\n  prefetch: process.env.__NEXT_CLIENT_SEGMENT_CACHE\n    ? // Unlike the old implementation, the Segment Cache doesn't store its\n      // data in the router reducer state; it writes into a global mutable\n      // cache. So we don't need to dispatch an action.\n      (href: string, options?: PrefetchOptions) => {\n        const actionQueue = getAppRouterActionQueue()\n        const prefetchKind = options?.kind ?? PrefetchKind.AUTO\n\n        // We don't currently offer a way to issue a runtime prefetch via `router.prefetch()`.\n        // This will be possible when we update its API to not take a PrefetchKind.\n        let fetchStrategy: PrefetchTaskFetchStrategy\n        switch (prefetchKind) {\n          case PrefetchKind.AUTO: {\n            // We default to PPR. We'll discover whether or not the route supports it with the initial prefetch.\n            fetchStrategy = FetchStrategy.PPR\n            break\n          }\n          case PrefetchKind.FULL: {\n            fetchStrategy = FetchStrategy.Full\n            break\n          }\n          case PrefetchKind.TEMPORARY: {\n            // This concept doesn't exist in the segment cache implementation.\n            return\n          }\n          default: {\n            prefetchKind satisfies never\n            // Despite typescript thinking that this can't happen,\n            // we might get an unexpected value from user code.\n            // We don't know what they want, but we know they want a prefetch,\n            // so use the default.\n            fetchStrategy = FetchStrategy.PPR\n          }\n        }\n\n        prefetchWithSegmentCache(\n          href,\n          actionQueue.state.nextUrl,\n          actionQueue.state.tree,\n          fetchStrategy,\n          options?.onInvalidate ?? null\n        )\n      }\n    : (href: string, options?: PrefetchOptions) => {\n        // Use the old prefetch implementation.\n        const actionQueue = getAppRouterActionQueue()\n        const url = createPrefetchURL(href)\n        if (url !== null) {\n          // The prefetch reducer doesn't actually update any state or\n          // trigger a rerender. It just writes to a mutable cache. So we\n          // shouldn't bother calling setState/dispatch; we can just re-run\n          // the reducer directly using the current state.\n          // TODO: Refactor this away from a \"reducer\" so it's\n          // less confusing.\n          prefetchReducer(actionQueue.state, {\n            type: ACTION_PREFETCH,\n            url,\n            kind: options?.kind ?? PrefetchKind.FULL,\n          })\n        }\n      },\n  replace: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'replace', options?.scroll ?? true, null)\n    })\n  },\n  push: (href: string, options?: NavigateOptions) => {\n    startTransition(() => {\n      dispatchNavigateAction(href, 'push', options?.scroll ?? true, null)\n    })\n  },\n  refresh: () => {\n    startTransition(() => {\n      dispatchAppRouterAction({\n        type: ACTION_REFRESH,\n        origin: window.location.origin,\n      })\n    })\n  },\n  hmrRefresh: () => {\n    if (process.env.NODE_ENV !== 'development') {\n      throw new Error(\n        'hmrRefresh can only be used in development mode. Please use refresh instead.'\n      )\n    } else {\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_HMR_REFRESH,\n          origin: window.location.origin,\n        })\n      })\n    }\n  },\n}\n\n// Exists for debugging purposes. Don't use in application code.\nif (typeof window !== 'undefined' && window.next) {\n  window.next.router = publicAppRouterInstance\n}\n","const workAsyncStorage =\n  typeof window === 'undefined'\n    ? (\n        require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n      ).workAsyncStorage\n    : undefined\n\n// if we are revalidating we want to re-throw the error so the\n// function crashes so we can maintain our previous cache\n// instead of caching the error page\nexport function HandleISRError({ error }: { error: any }) {\n  if (workAsyncStorage) {\n    const store = workAsyncStorage.getStore()\n    if (store?.isRevalidate || store?.isStaticGeneration) {\n      console.error(error)\n      throw error\n    }\n  }\n\n  return null\n}\n","'use client'\n\nimport React, {\n  useEffect,\n  useMemo,\n  startTransition,\n  useInsertionEffect,\n  useDeferredValue,\n} from 'react'\nimport {\n  AppRouterContext,\n  LayoutRouterContext,\n  GlobalLayoutRouterContext,\n} from '../../shared/lib/app-router-context.shared-runtime'\nimport type { CacheNode } from '../../shared/lib/app-router-context.shared-runtime'\nimport { ACTION_RESTORE } from './router-reducer/router-reducer-types'\nimport type { AppRouterState } from './router-reducer/router-reducer-types'\nimport { createHrefFromUrl } from './router-reducer/create-href-from-url'\nimport {\n  SearchParamsContext,\n  PathnameContext,\n  PathParamsContext,\n} from '../../shared/lib/hooks-client-context.shared-runtime'\nimport { dispatchAppRouterAction, useActionQueue } from './use-action-queue'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\nimport { addBasePath } from '../add-base-path'\nimport { AppRouterAnnouncer } from './app-router-announcer'\nimport { RedirectBoundary } from './redirect-boundary'\nimport { findHeadInCache } from './router-reducer/reducers/find-head-in-cache'\nimport { unresolvedThenable } from './unresolved-thenable'\nimport { removeBasePath } from '../remove-base-path'\nimport { hasBasePath } from '../has-base-path'\nimport { getSelectedParams } from './router-reducer/compute-changed-path'\nimport type { FlightRouterState } from '../../server/app-render/types'\nimport { useNavFailureHandler } from './nav-failure-handler'\nimport {\n  dispatchTraverseAction,\n  publicAppRouterInstance,\n  type AppRouterActionQueue,\n  type GlobalErrorState,\n} from './app-router-instance'\nimport { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\nimport { isRedirectError, RedirectType } from './redirect-error'\nimport { pingVisibleLinks } from './links'\nimport RootErrorBoundary from './errors/root-error-boundary'\nimport DefaultGlobalError from './builtin/global-error'\nimport { RootLayoutBoundary } from '../../lib/framework/boundary-components'\n\nconst globalMutable: {\n  pendingMpaPath?: string\n} = {}\n\nexport function isExternalURL(url: URL) {\n  return url.origin !== window.location.origin\n}\n\n/**\n * Given a link href, constructs the URL that should be prefetched. Returns null\n * in cases where prefetching should be disabled, like external URLs, or\n * during development.\n * @param href The href passed to <Link>, router.prefetch(), or similar\n * @returns A URL object to prefetch, or null if prefetching should be disabled\n */\nexport function createPrefetchURL(href: string): URL | null {\n  // Don't prefetch for bots as they don't navigate.\n  if (isBot(window.navigator.userAgent)) {\n    return null\n  }\n\n  let url: URL\n  try {\n    url = new URL(addBasePath(href), window.location.href)\n  } catch (_) {\n    // TODO: Does this need to throw or can we just console.error instead? Does\n    // anyone rely on this throwing? (Seems unlikely.)\n    throw new Error(\n      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n    )\n  }\n\n  // Don't prefetch during development (improves compilation performance)\n  if (process.env.NODE_ENV === 'development') {\n    return null\n  }\n\n  // External urls can't be prefetched in the same way.\n  if (isExternalURL(url)) {\n    return null\n  }\n\n  return url\n}\n\nfunction HistoryUpdater({\n  appRouterState,\n}: {\n  appRouterState: AppRouterState\n}) {\n  useInsertionEffect(() => {\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      // clear pending URL as navigation is no longer\n      // in flight\n      window.next.__pendingUrl = undefined\n    }\n\n    const { tree, pushRef, canonicalUrl } = appRouterState\n    const historyState = {\n      ...(pushRef.preserveCustomHistoryState ? window.history.state : {}),\n      // Identifier is shortened intentionally.\n      // __NA is used to identify if the history entry can be handled by the app-router.\n      // __N is used to identify if the history entry can be handled by the old router.\n      __NA: true,\n      __PRIVATE_NEXTJS_INTERNALS_TREE: tree,\n    }\n    if (\n      pushRef.pendingPush &&\n      // Skip pushing an additional history entry if the canonicalUrl is the same as the current url.\n      // This mirrors the browser behavior for normal navigation.\n      createHrefFromUrl(new URL(window.location.href)) !== canonicalUrl\n    ) {\n      // This intentionally mutates React state, pushRef is overwritten to ensure additional push/replace calls do not trigger an additional history entry.\n      pushRef.pendingPush = false\n      window.history.pushState(historyState, '', canonicalUrl)\n    } else {\n      window.history.replaceState(historyState, '', canonicalUrl)\n    }\n  }, [appRouterState])\n\n  useEffect(() => {\n    // The Next-Url and the base tree may affect the result of a prefetch\n    // task. Re-prefetch all visible links with the updated values. In most\n    // cases, this will not result in any new network requests, only if\n    // the prefetch result actually varies on one of these inputs.\n    if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n      pingVisibleLinks(appRouterState.nextUrl, appRouterState.tree)\n    }\n  }, [appRouterState.nextUrl, appRouterState.tree])\n\n  return null\n}\n\nexport function createEmptyCacheNode(): CacheNode {\n  return {\n    lazyData: null,\n    rsc: null,\n    prefetchRsc: null,\n    head: null,\n    prefetchHead: null,\n    parallelRoutes: new Map(),\n    loading: null,\n    navigatedAt: -1,\n  }\n}\n\nfunction copyNextJsInternalHistoryState(data: any) {\n  if (data == null) data = {}\n  const currentState = window.history.state\n  const __NA = currentState?.__NA\n  if (__NA) {\n    data.__NA = __NA\n  }\n  const __PRIVATE_NEXTJS_INTERNALS_TREE =\n    currentState?.__PRIVATE_NEXTJS_INTERNALS_TREE\n  if (__PRIVATE_NEXTJS_INTERNALS_TREE) {\n    data.__PRIVATE_NEXTJS_INTERNALS_TREE = __PRIVATE_NEXTJS_INTERNALS_TREE\n  }\n\n  return data\n}\n\nfunction Head({\n  headCacheNode,\n}: {\n  headCacheNode: CacheNode | null\n}): React.ReactNode {\n  // If this segment has a `prefetchHead`, it's the statically prefetched data.\n  // We should use that on initial render instead of `head`. Then we'll switch\n  // to `head` when the dynamic response streams in.\n  const head = headCacheNode !== null ? headCacheNode.head : null\n  const prefetchHead =\n    headCacheNode !== null ? headCacheNode.prefetchHead : null\n\n  // If no prefetch data is available, then we go straight to rendering `head`.\n  const resolvedPrefetchRsc = prefetchHead !== null ? prefetchHead : head\n\n  // We use `useDeferredValue` to handle switching between the prefetched and\n  // final values. The second argument is returned on initial render, then it\n  // re-renders with the first argument.\n  return useDeferredValue(head, resolvedPrefetchRsc)\n}\n\n/**\n * The global router that wraps the application components.\n */\nfunction Router({\n  actionQueue,\n  assetPrefix,\n  globalError,\n}: {\n  actionQueue: AppRouterActionQueue\n  assetPrefix: string\n  globalError: GlobalErrorState\n}) {\n  const state = useActionQueue(actionQueue)\n  const { canonicalUrl } = state\n  // Add memoized pathname/query for useSearchParams and usePathname.\n  const { searchParams, pathname } = useMemo(() => {\n    const url = new URL(\n      canonicalUrl,\n      typeof window === 'undefined' ? 'http://n' : window.location.href\n    )\n\n    return {\n      // This is turned into a readonly class in `useSearchParams`\n      searchParams: url.searchParams,\n      pathname: hasBasePath(url.pathname)\n        ? removeBasePath(url.pathname)\n        : url.pathname,\n    }\n  }, [canonicalUrl])\n\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const { cache, prefetchCache, tree } = state\n\n    // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      // Add `window.nd` for debugging purposes.\n      // This is not meant for use in applications as concurrent rendering will affect the cache/tree/router.\n      // @ts-ignore this is for debugging\n      window.nd = {\n        router: publicAppRouterInstance,\n        cache,\n        prefetchCache,\n        tree,\n      }\n    }, [cache, prefetchCache, tree])\n  }\n\n  useEffect(() => {\n    // If the app is restored from bfcache, it's possible that\n    // pushRef.mpaNavigation is true, which would mean that any re-render of this component\n    // would trigger the mpa navigation logic again from the lines below.\n    // This will restore the router to the initial state in the event that the app is restored from bfcache.\n    function handlePageShow(event: PageTransitionEvent) {\n      if (\n        !event.persisted ||\n        !window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n      ) {\n        return\n      }\n\n      // Clear the pendingMpaPath value so that a subsequent MPA navigation to the same URL can be triggered.\n      // This is necessary because if the browser restored from bfcache, the pendingMpaPath would still be set to the value\n      // of the last MPA navigation.\n      globalMutable.pendingMpaPath = undefined\n\n      dispatchAppRouterAction({\n        type: ACTION_RESTORE,\n        url: new URL(window.location.href),\n        tree: window.history.state.__PRIVATE_NEXTJS_INTERNALS_TREE,\n      })\n    }\n\n    window.addEventListener('pageshow', handlePageShow)\n\n    return () => {\n      window.removeEventListener('pageshow', handlePageShow)\n    }\n  }, [])\n\n  useEffect(() => {\n    // Ensure that any redirect errors that bubble up outside of the RedirectBoundary\n    // are caught and handled by the router.\n    function handleUnhandledRedirect(\n      event: ErrorEvent | PromiseRejectionEvent\n    ) {\n      const error = 'reason' in event ? event.reason : event.error\n      if (isRedirectError(error)) {\n        event.preventDefault()\n        const url = getURLFromRedirectError(error)\n        const redirectType = getRedirectTypeFromError(error)\n        // TODO: This should access the router methods directly, rather than\n        // go through the public interface.\n        if (redirectType === RedirectType.push) {\n          publicAppRouterInstance.push(url, {})\n        } else {\n          publicAppRouterInstance.replace(url, {})\n        }\n      }\n    }\n    window.addEventListener('error', handleUnhandledRedirect)\n    window.addEventListener('unhandledrejection', handleUnhandledRedirect)\n\n    return () => {\n      window.removeEventListener('error', handleUnhandledRedirect)\n      window.removeEventListener('unhandledrejection', handleUnhandledRedirect)\n    }\n  }, [])\n\n  // When mpaNavigation flag is set do a hard navigation to the new url.\n  // Infinitely suspend because we don't actually want to rerender any child\n  // components with the new URL and any entangled state updates shouldn't\n  // commit either (eg: useTransition isPending should stay true until the page\n  // unloads).\n  //\n  // This is a side effect in render. Don't try this at home, kids. It's\n  // probably safe because we know this is a singleton component and it's never\n  // in <Offscreen>. At least I hope so. (It will run twice in dev strict mode,\n  // but that's... fine?)\n  const { pushRef } = state\n  if (pushRef.mpaNavigation) {\n    // if there's a re-render, we don't want to trigger another redirect if one is already in flight to the same URL\n    if (globalMutable.pendingMpaPath !== canonicalUrl) {\n      const location = window.location\n      if (pushRef.pendingPush) {\n        location.assign(canonicalUrl)\n      } else {\n        location.replace(canonicalUrl)\n      }\n\n      globalMutable.pendingMpaPath = canonicalUrl\n    }\n    // TODO-APP: Should we listen to navigateerror here to catch failed\n    // navigations somehow? And should we call window.stop() if a SPA navigation\n    // should interrupt an MPA one?\n    // NOTE: This is intentionally using `throw` instead of `use` because we're\n    // inside an externally mutable condition (pushRef.mpaNavigation), which\n    // violates the rules of hooks.\n    throw unresolvedThenable\n  }\n\n  useEffect(() => {\n    const originalPushState = window.history.pushState.bind(window.history)\n    const originalReplaceState = window.history.replaceState.bind(\n      window.history\n    )\n\n    // Ensure the canonical URL in the Next.js Router is updated when the URL is changed so that `usePathname` and `useSearchParams` hold the pushed values.\n    const applyUrlFromHistoryPushReplace = (\n      url: string | URL | null | undefined\n    ) => {\n      const href = window.location.href\n      const tree: FlightRouterState | undefined =\n        window.history.state?.__PRIVATE_NEXTJS_INTERNALS_TREE\n\n      startTransition(() => {\n        dispatchAppRouterAction({\n          type: ACTION_RESTORE,\n          url: new URL(url ?? href, href),\n          tree,\n        })\n      })\n    }\n\n    /**\n     * Patch pushState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.pushState = function pushState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalPushState(data, _unused, url)\n      }\n\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n\n      return originalPushState(data, _unused, url)\n    }\n\n    /**\n     * Patch replaceState to ensure external changes to the history are reflected in the Next.js Router.\n     * Ensures Next.js internal history state is copied to the new history entry.\n     * Ensures usePathname and useSearchParams hold the newly provided url.\n     */\n    window.history.replaceState = function replaceState(\n      data: any,\n      _unused: string,\n      url?: string | URL | null\n    ): void {\n      // Avoid a loop when Next.js internals trigger pushState/replaceState\n      if (data?.__NA || data?._N) {\n        return originalReplaceState(data, _unused, url)\n      }\n      data = copyNextJsInternalHistoryState(data)\n\n      if (url) {\n        applyUrlFromHistoryPushReplace(url)\n      }\n      return originalReplaceState(data, _unused, url)\n    }\n\n    /**\n     * Handle popstate event, this is used to handle back/forward in the browser.\n     * By default dispatches ACTION_RESTORE, however if the history entry was not pushed/replaced by app-router it will reload the page.\n     * That case can happen when the old router injected the history entry.\n     */\n    const onPopState = (event: PopStateEvent) => {\n      if (!event.state) {\n        // TODO-APP: this case only happens when pushState/replaceState was called outside of Next.js. It should probably reload the page in this case.\n        return\n      }\n\n      // This case happens when the history entry was pushed by the `pages` router.\n      if (!event.state.__NA) {\n        window.location.reload()\n        return\n      }\n\n      // TODO-APP: Ideally the back button should not use startTransition as it should apply the updates synchronously\n      // Without startTransition works if the cache is there for this path\n      startTransition(() => {\n        dispatchTraverseAction(\n          window.location.href,\n          event.state.__PRIVATE_NEXTJS_INTERNALS_TREE\n        )\n      })\n    }\n\n    // Register popstate event to call onPopstate.\n    window.addEventListener('popstate', onPopState)\n    return () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener('popstate', onPopState)\n    }\n  }, [])\n\n  const { cache, tree, nextUrl, focusAndScrollRef } = state\n\n  const matchingHead = useMemo(() => {\n    return findHeadInCache(cache, tree[1])\n  }, [cache, tree])\n\n  // Add memoized pathParams for useParams.\n  const pathParams = useMemo(() => {\n    return getSelectedParams(tree)\n  }, [tree])\n\n  const layoutRouterContext = useMemo(() => {\n    return {\n      parentTree: tree,\n      parentCacheNode: cache,\n      parentSegmentPath: null,\n      // Root node always has `url`\n      // Provided in AppTreeContext to ensure it can be overwritten in layout-router\n      url: canonicalUrl,\n    }\n  }, [tree, cache, canonicalUrl])\n\n  const globalLayoutRouterContext = useMemo(() => {\n    return {\n      tree,\n      focusAndScrollRef,\n      nextUrl,\n    }\n  }, [tree, focusAndScrollRef, nextUrl])\n\n  let head\n  if (matchingHead !== null) {\n    // The head is wrapped in an extra component so we can use\n    // `useDeferredValue` to swap between the prefetched and final versions of\n    // the head. (This is what LayoutRouter does for segment data, too.)\n    //\n    // The `key` is used to remount the component whenever the head moves to\n    // a different segment.\n    const [headCacheNode, headKey, headKeyWithoutSearchParams] = matchingHead\n\n    head = (\n      <Head\n        key={\n          // Necessary for PPR: omit search params from the key to match prerendered keys\n          typeof window === 'undefined' ? headKeyWithoutSearchParams : headKey\n        }\n        headCacheNode={headCacheNode}\n      />\n    )\n  } else {\n    head = null\n  }\n\n  let content = (\n    <RedirectBoundary>\n      {head}\n      {/* RootLayoutBoundary enables detection of Suspense boundaries around the root layout.\n          When users wrap their layout in <Suspense>, this creates the component stack pattern\n          \"Suspense -> RootLayoutBoundary\" which dynamic-rendering.ts uses to allow dynamic rendering. */}\n      <RootLayoutBoundary>{cache.rsc}</RootLayoutBoundary>\n      <AppRouterAnnouncer tree={tree} />\n    </RedirectBoundary>\n  )\n\n  if (process.env.NODE_ENV !== 'production') {\n    // In development, we apply few error boundaries and hot-reloader:\n    // - DevRootHTTPAccessFallbackBoundary: avoid using navigation API like notFound() in root layout\n    // - HotReloader:\n    //  - hot-reload the app when the code changes\n    //  - render dev overlay\n    //  - catch runtime errors and display global-error when necessary\n    if (typeof window !== 'undefined') {\n      const { DevRootHTTPAccessFallbackBoundary } =\n        require('./dev-root-http-access-fallback-boundary') as typeof import('./dev-root-http-access-fallback-boundary')\n      content = (\n        <DevRootHTTPAccessFallbackBoundary>\n          {content}\n        </DevRootHTTPAccessFallbackBoundary>\n      )\n    }\n    const HotReloader: typeof import('../dev/hot-reloader/app/hot-reloader-app').default =\n      (\n        require('../dev/hot-reloader/app/hot-reloader-app') as typeof import('../dev/hot-reloader/app/hot-reloader-app')\n      ).default\n\n    content = (\n      <HotReloader assetPrefix={assetPrefix} globalError={globalError}>\n        {content}\n      </HotReloader>\n    )\n  } else {\n    content = (\n      <RootErrorBoundary\n        errorComponent={globalError[0]}\n        errorStyles={globalError[1]}\n      >\n        {content}\n      </RootErrorBoundary>\n    )\n  }\n\n  return (\n    <>\n      <HistoryUpdater appRouterState={state} />\n      <RuntimeStyles />\n      <PathParamsContext.Provider value={pathParams}>\n        <PathnameContext.Provider value={pathname}>\n          <SearchParamsContext.Provider value={searchParams}>\n            <GlobalLayoutRouterContext.Provider\n              value={globalLayoutRouterContext}\n            >\n              {/* TODO: We should be able to remove this context. useRouter\n                  should import from app-router-instance instead. It's only\n                  necessary because useRouter is shared between Pages and\n                  App Router. We should fork that module, then remove this\n                  context provider. */}\n              <AppRouterContext.Provider value={publicAppRouterInstance}>\n                <LayoutRouterContext.Provider value={layoutRouterContext}>\n                  {content}\n                </LayoutRouterContext.Provider>\n              </AppRouterContext.Provider>\n            </GlobalLayoutRouterContext.Provider>\n          </SearchParamsContext.Provider>\n        </PathnameContext.Provider>\n      </PathParamsContext.Provider>\n    </>\n  )\n}\n\nexport default function AppRouter({\n  actionQueue,\n  globalErrorState,\n  assetPrefix,\n}: {\n  actionQueue: AppRouterActionQueue\n  globalErrorState: GlobalErrorState\n  assetPrefix: string\n}) {\n  useNavFailureHandler()\n\n  const router = (\n    <Router\n      actionQueue={actionQueue}\n      assetPrefix={assetPrefix}\n      globalError={globalErrorState}\n    />\n  )\n\n  // At the very top level, use the default GlobalError component as the final fallback.\n  // When the app router itself fails, which means the framework itself fails, we show the default error.\n  return (\n    <RootErrorBoundary errorComponent={DefaultGlobalError}>\n      {router}\n    </RootErrorBoundary>\n  )\n}\n\nconst runtimeStyles = new Set<string>()\nlet runtimeStyleChanged = new Set<() => void>()\n\nglobalThis._N_E_STYLE_LOAD = function (href: string) {\n  let len = runtimeStyles.size\n  runtimeStyles.add(href)\n  if (runtimeStyles.size !== len) {\n    runtimeStyleChanged.forEach((cb) => cb())\n  }\n  // TODO figure out how to get a promise here\n  // But maybe it's not necessary as react would block rendering until it's loaded\n  return Promise.resolve()\n}\n\nfunction RuntimeStyles() {\n  const [, forceUpdate] = React.useState(0)\n  const renderedStylesSize = runtimeStyles.size\n  useEffect(() => {\n    const changed = () => forceUpdate((c) => c + 1)\n    runtimeStyleChanged.add(changed)\n    if (renderedStylesSize !== runtimeStyles.size) {\n      changed()\n    }\n    return () => {\n      runtimeStyleChanged.delete(changed)\n    }\n  }, [renderedStylesSize, forceUpdate])\n\n  const dplId = process.env.NEXT_DEPLOYMENT_ID\n    ? `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`\n    : ''\n  return [...runtimeStyles].map((href, i) => (\n    <link\n      key={i}\n      rel=\"stylesheet\"\n      href={`${href}${dplId}`}\n      // @ts-ignore\n      precedence=\"next\"\n      // TODO figure out crossOrigin and nonce\n      // crossOrigin={TODO}\n      // nonce={TODO}\n    />\n  ))\n}\n","'use client'\n\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Segment component.\n *\n * additionally we may send a promise representing params. We don't ever use this passed\n * value but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations\n * such as when cacheComponents is enabled. It is up to the caller to decide if the promises are needed.\n */\nexport function ClientSegmentRoot({\n  Component,\n  slots,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promise,\n}: {\n  Component: React.ComponentType<any>\n  slots: { [key: string]: React.ReactNode }\n  params: Params\n  promise?: Promise<any>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling params in a client segment such as a Layout or Template.'\n      )\n    }\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component {...slots} params={clientParams} />\n  } else {\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n    return <Component {...slots} params={clientParams} />\n  }\n}\n","// Override chunk URL mapping in the webpack runtime\n// https://github.com/webpack/webpack/blob/2738eebc7880835d88c727d364ad37f3ec557593/lib/RuntimeGlobals.js#L204\n\nimport { getDeploymentIdQueryOrEmptyString } from '../build/deployment-id'\nimport { encodeURIPath } from '../shared/lib/encode-uri-path'\n\ndeclare const __webpack_require__: any\n\n// If we have a deployment ID, we need to append it to the webpack chunk names\n// I am keeping the process check explicit so this can be statically optimized\nif (process.env.NEXT_DEPLOYMENT_ID) {\n  const suffix = getDeploymentIdQueryOrEmptyString()\n  // eslint-disable-next-line no-undef\n  const getChunkScriptFilename = __webpack_require__.u\n  // eslint-disable-next-line no-undef\n  __webpack_require__.u = (...args: any[]) =>\n    // We encode the chunk filename because our static server matches against and encoded\n    // filename path.\n    encodeURIPath(getChunkScriptFilename(...args)) + suffix\n\n  // eslint-disable-next-line no-undef\n  const getChunkCssFilename = __webpack_require__.k\n  // eslint-disable-next-line no-undef\n  __webpack_require__.k = (...args: any[]) =>\n    getChunkCssFilename(...args) + suffix\n\n  // eslint-disable-next-line no-undef\n  const getMiniCssFilename = __webpack_require__.miniCssF\n  // eslint-disable-next-line no-undef\n  __webpack_require__.miniCssF = (...args: any[]) =>\n    getMiniCssFilename(...args) + suffix\n} else {\n  // eslint-disable-next-line no-undef\n  const getChunkScriptFilename = __webpack_require__.u\n  // eslint-disable-next-line no-undef\n  __webpack_require__.u = (...args: any[]) =>\n    // We encode the chunk filename because our static server matches against and encoded\n    // filename path.\n    encodeURIPath(getChunkScriptFilename(...args))\n\n  // We don't need to override __webpack_require__.k because we don't modify\n  // the css chunk name when not using deployment id suffixes\n\n  // WE don't need to override __webpack_require__.miniCssF because we don't modify\n  // the mini css chunk name when not using deployment id suffixes\n}\n\nexport {}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport GracefulDegradeBoundary from './graceful-degrade-boundary'\nimport { ErrorBoundary, type ErrorBoundaryProps } from '../error-boundary'\nimport { isBot } from '../../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport default function RootErrorBoundary({\n  children,\n  errorComponent,\n  errorStyles,\n  errorScripts,\n}: ErrorBoundaryProps & { children: React.ReactNode }): JSX.Element {\n  if (isBotUserAgent) {\n    // Preserve existing DOM/HTML for bots to avoid replacing content with an error UI\n    // and to keep the original SSR output intact.\n    return <GracefulDegradeBoundary>{children}</GracefulDegradeBoundary>\n  }\n\n  return (\n    <ErrorBoundary\n      errorComponent={errorComponent}\n      errorStyles={errorStyles}\n      errorScripts={errorScripts}\n    >\n      {children}\n    </ErrorBoundary>\n  )\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","import type { FlightRouterState } from '../../server/app-render/types'\nimport { useState } from 'react'\n\n// When the flag is disabled, only track the currently active tree\nconst MAX_BF_CACHE_ENTRIES = process.env.__NEXT_ROUTER_BF_CACHE ? 3 : 1\n\nexport type RouterBFCacheEntry = {\n  tree: FlightRouterState\n  stateKey: string\n  // The entries form a linked list, sorted in order of most recently active.\n  next: RouterBFCacheEntry | null\n}\n\n/**\n * Keeps track of the most recent N trees (FlightRouterStates) that were active\n * at a certain segment level. E.g. for a segment \"/a/b/[param]\", this hook\n * tracks the last N param values that the router rendered for N.\n *\n * The result of this hook precisely determines the number and order of\n * trees that are rendered in parallel at their segment level.\n *\n * The purpose of this cache is to we can preserve the React and DOM state of\n * some number of inactive trees, by rendering them in an <Activity> boundary.\n * That means it would not make sense for the the lifetime of the cache to be\n * any longer than the lifetime of the React tree; e.g. if the hook were\n * unmounted, then the React tree would be, too. So, we use React state to\n * manage it.\n *\n * Note that we don't store the RSC data for the cache entries in this hook \n * the data for inactive segments is stored in the parent CacheNode, which\n * *does* have a longer lifetime than the React tree. This hook only determines\n * which of those trees should have their *state* preserved, by <Activity>.\n */\nexport function useRouterBFCache(\n  activeTree: FlightRouterState,\n  activeStateKey: string\n): RouterBFCacheEntry {\n  // The currently active entry. The entries form a linked list, sorted in\n  // order of most recently active. This allows us to reuse parts of the list\n  // without cloning, unless there's a reordering or removal.\n  // TODO: Once we start tracking back/forward history at each route level,\n  // we should use the history order instead. In other words, when traversing\n  // to an existing entry as a result of a popstate event, we should maintain\n  // the existing order instead of moving it to the front of the list. I think\n  // an initial implementation of this could be to pass an incrementing id\n  // to history.pushState/replaceState, then use that here for ordering.\n  const [prevActiveEntry, setPrevActiveEntry] = useState<RouterBFCacheEntry>(\n    () => {\n      const initialEntry: RouterBFCacheEntry = {\n        tree: activeTree,\n        stateKey: activeStateKey,\n        next: null,\n      }\n      return initialEntry\n    }\n  )\n\n  if (prevActiveEntry.tree === activeTree) {\n    // Fast path. The active tree hasn't changed, so we can reuse the\n    // existing state.\n    return prevActiveEntry\n  }\n\n  // The route tree changed. Note that this doesn't mean that the tree changed\n  // *at this level*  the change may be due to a child route. Either way, we\n  // need to either add or update the router tree in the bfcache.\n  //\n  // The rest of the code looks more complicated than it actually is because we\n  // can't mutate the state in place; we have to copy-on-write.\n\n  // Create a new entry for the active cache key. This is the head of the new\n  // linked list.\n  const newActiveEntry: RouterBFCacheEntry = {\n    tree: activeTree,\n    stateKey: activeStateKey,\n    next: null,\n  }\n\n  // We need to append the old list onto the new list. If the head of the new\n  // list was already present in the cache, then we'll need to clone everything\n  // that came before it. Then we can reuse the rest.\n  let n = 1\n  let oldEntry: RouterBFCacheEntry | null = prevActiveEntry\n  let clonedEntry: RouterBFCacheEntry = newActiveEntry\n  while (oldEntry !== null && n < MAX_BF_CACHE_ENTRIES) {\n    if (oldEntry.stateKey === activeStateKey) {\n      // Fast path. This entry in the old list that corresponds to the key that\n      // is now active. We've already placed a clone of this entry at the front\n      // of the new list. We can reuse the rest of the old list without cloning.\n      // NOTE: We don't need to worry about eviction in this case because we\n      // haven't increased the size of the cache, and we assume the max size\n      // is constant across renders. If we were to change it to a dynamic limit,\n      // then the implementation would need to account for that.\n      clonedEntry.next = oldEntry.next\n      break\n    } else {\n      // Clone the entry and append it to the list.\n      n++\n      const entry: RouterBFCacheEntry = {\n        tree: oldEntry.tree,\n        stateKey: oldEntry.stateKey,\n        next: null,\n      }\n      clonedEntry.next = entry\n      clonedEntry = entry\n    }\n    oldEntry = oldEntry.next\n  }\n\n  setPrevActiveEntry(newActiveEntry)\n  return newActiveEntry\n}\n","import { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\nimport type { FlightRouterState } from '../../server/app-render/types'\n\nconst ANNOUNCER_TYPE = 'next-route-announcer'\nconst ANNOUNCER_ID = '__next-route-announcer__'\n\nfunction getAnnouncerNode() {\n  const existingAnnouncer = document.getElementsByName(ANNOUNCER_TYPE)[0]\n  if (existingAnnouncer?.shadowRoot?.childNodes[0]) {\n    return existingAnnouncer.shadowRoot.childNodes[0] as HTMLElement\n  } else {\n    const container = document.createElement(ANNOUNCER_TYPE)\n    container.style.cssText = 'position:absolute'\n    const announcer = document.createElement('div')\n    announcer.ariaLive = 'assertive'\n    announcer.id = ANNOUNCER_ID\n    announcer.role = 'alert'\n    announcer.style.cssText =\n      'position:absolute;border:0;height:1px;margin:-1px;padding:0;width:1px;clip:rect(0 0 0 0);overflow:hidden;white-space:nowrap;word-wrap:normal'\n\n    // Use shadow DOM here to avoid any potential CSS bleed\n    const shadow = container.attachShadow({ mode: 'open' })\n    shadow.appendChild(announcer)\n    document.body.appendChild(container)\n    return announcer\n  }\n}\n\nexport function AppRouterAnnouncer({ tree }: { tree: FlightRouterState }) {\n  const [portalNode, setPortalNode] = useState<HTMLElement | null>(null)\n\n  useEffect(() => {\n    const announcer = getAnnouncerNode()\n    setPortalNode(announcer)\n    return () => {\n      const container = document.getElementsByTagName(ANNOUNCER_TYPE)[0]\n      if (container?.isConnected) {\n        document.body.removeChild(container)\n      }\n    }\n  }, [])\n\n  const [routeAnnouncement, setRouteAnnouncement] = useState('')\n  const previousTitle = useRef<string | undefined>(undefined)\n\n  useEffect(() => {\n    let currentTitle = ''\n    if (document.title) {\n      currentTitle = document.title\n    } else {\n      const pageHeader = document.querySelector('h1')\n      if (pageHeader) {\n        currentTitle = pageHeader.innerText || pageHeader.textContent || ''\n      }\n    }\n\n    // Only announce the title change, but not for the first load because screen\n    // readers do that automatically.\n    if (\n      previousTitle.current !== undefined &&\n      previousTitle.current !== currentTitle\n    ) {\n      setRouteAnnouncement(currentTitle)\n    }\n    previousTitle.current = currentTitle\n  }, [tree])\n\n  return portalNode ? createPortal(routeAnnouncement, portalNode) : null\n}\n","export const RSC_HEADER = 'rsc' as const\nexport const ACTION_HEADER = 'next-action' as const\n// TODO: Instead of sending the full router state, we only need to send the\n// segment path. Saves bytes. Then we could also use this field for segment\n// prefetches, which also need to specify a particular segment.\nexport const NEXT_ROUTER_STATE_TREE_HEADER = 'next-router-state-tree' as const\nexport const NEXT_ROUTER_PREFETCH_HEADER = 'next-router-prefetch' as const\n// This contains the path to the segment being prefetched.\n// TODO: If we change next-router-state-tree to be a segment path, we can use\n// that instead. Then next-router-prefetch and next-router-segment-prefetch can\n// be merged into a single enum.\nexport const NEXT_ROUTER_SEGMENT_PREFETCH_HEADER =\n  'next-router-segment-prefetch' as const\nexport const NEXT_HMR_REFRESH_HEADER = 'next-hmr-refresh' as const\nexport const NEXT_HMR_REFRESH_HASH_COOKIE = '__next_hmr_refresh_hash__' as const\nexport const NEXT_URL = 'next-url' as const\nexport const RSC_CONTENT_TYPE_HEADER = 'text/x-component' as const\n\nexport const FLIGHT_HEADERS = [\n  RSC_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_HMR_REFRESH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n] as const\n\nexport const NEXT_RSC_UNION_QUERY = '_rsc' as const\n\nexport const NEXT_ROUTER_STALE_TIME_HEADER = 'x-nextjs-stale-time' as const\nexport const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\nexport const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\nexport const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\nexport const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\nexport const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const\n","'use client'\n\nimport { HandleISRError } from '../handle-isr-error'\n\nconst styles = {\n  error: {\n    // https://github.com/sindresorhus/modern-normalize/blob/main/modern-normalize.css#L38-L52\n    fontFamily:\n      'system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"',\n    height: '100vh',\n    textAlign: 'center',\n    display: 'flex',\n    flexDirection: 'column',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  text: {\n    fontSize: '14px',\n    fontWeight: 400,\n    lineHeight: '28px',\n    margin: '0 8px',\n  },\n} as const\n\nexport type GlobalErrorComponent = React.ComponentType<{\n  error: any\n}>\nfunction DefaultGlobalError({ error }: { error: any }) {\n  const digest: string | undefined = error?.digest\n  return (\n    <html id=\"__next_error__\">\n      <head></head>\n      <body>\n        <HandleISRError error={error} />\n        <div style={styles.error}>\n          <div>\n            <h2 style={styles.text}>\n              Application error: a {digest ? 'server' : 'client'}-side exception\n              has occurred while loading {window.location.hostname} (see the{' '}\n              {digest ? 'server logs' : 'browser console'} for more\n              information).\n            </h2>\n            {digest ? <p style={styles.text}>{`Digest: ${digest}`}</p> : null}\n          </div>\n        </div>\n      </body>\n    </html>\n  )\n}\n\n// Exported so that the import signature in the loaders can be identical to user\n// supplied custom global error signatures.\nexport default DefaultGlobalError\n","'use client'\n\n/**\n * HTTPAccessFallbackBoundary is a boundary that catches errors and renders a\n * fallback component for HTTP errors.\n *\n * It receives the status code, and determine if it should render fallbacks for few HTTP 4xx errors.\n *\n * e.g. 404\n * 404 represents not found, and the fallback component pair contains the component and its styles.\n *\n */\n\nimport React, { useContext } from 'react'\nimport { useUntrackedPathname } from '../navigation-untracked'\nimport {\n  HTTPAccessErrorStatus,\n  getAccessFallbackHTTPStatus,\n  getAccessFallbackErrorTypeByStatus,\n  isHTTPAccessFallbackError,\n} from './http-access-fallback'\nimport { warnOnce } from '../../../shared/lib/utils/warn-once'\nimport { MissingSlotContext } from '../../../shared/lib/app-router-context.shared-runtime'\n\ninterface HTTPAccessFallbackBoundaryProps {\n  notFound?: React.ReactNode\n  forbidden?: React.ReactNode\n  unauthorized?: React.ReactNode\n  children: React.ReactNode\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessFallbackErrorBoundaryProps\n  extends HTTPAccessFallbackBoundaryProps {\n  pathname: string | null\n  missingSlots?: Set<string>\n}\n\ninterface HTTPAccessBoundaryState {\n  triggeredStatus: number | undefined\n  previousPathname: string | null\n}\n\nclass HTTPAccessFallbackErrorBoundary extends React.Component<\n  HTTPAccessFallbackErrorBoundaryProps,\n  HTTPAccessBoundaryState\n> {\n  constructor(props: HTTPAccessFallbackErrorBoundaryProps) {\n    super(props)\n    this.state = {\n      triggeredStatus: undefined,\n      previousPathname: props.pathname,\n    }\n  }\n\n  componentDidCatch(): void {\n    if (\n      process.env.NODE_ENV === 'development' &&\n      this.props.missingSlots &&\n      this.props.missingSlots.size > 0 &&\n      // A missing children slot is the typical not-found case, so no need to warn\n      !this.props.missingSlots.has('children')\n    ) {\n      let warningMessage =\n        'No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n' +\n        'Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n'\n\n      const formattedSlots = Array.from(this.props.missingSlots)\n        .sort((a, b) => a.localeCompare(b))\n        .map((slot) => `@${slot}`)\n        .join(', ')\n\n      warningMessage += 'Missing slots: ' + formattedSlots\n\n      warnOnce(warningMessage)\n    }\n  }\n\n  static getDerivedStateFromError(error: any) {\n    if (isHTTPAccessFallbackError(error)) {\n      const httpStatus = getAccessFallbackHTTPStatus(error)\n      return {\n        triggeredStatus: httpStatus,\n      }\n    }\n    // Re-throw if error is not for 404\n    throw error\n  }\n\n  static getDerivedStateFromProps(\n    props: HTTPAccessFallbackErrorBoundaryProps,\n    state: HTTPAccessBoundaryState\n  ): HTTPAccessBoundaryState | null {\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.triggeredStatus) {\n      return {\n        triggeredStatus: undefined,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      triggeredStatus: state.triggeredStatus,\n      previousPathname: props.pathname,\n    }\n  }\n\n  render() {\n    const { notFound, forbidden, unauthorized, children } = this.props\n    const { triggeredStatus } = this.state\n    const errorComponents = {\n      [HTTPAccessErrorStatus.NOT_FOUND]: notFound,\n      [HTTPAccessErrorStatus.FORBIDDEN]: forbidden,\n      [HTTPAccessErrorStatus.UNAUTHORIZED]: unauthorized,\n    }\n\n    if (triggeredStatus) {\n      const isNotFound =\n        triggeredStatus === HTTPAccessErrorStatus.NOT_FOUND && notFound\n      const isForbidden =\n        triggeredStatus === HTTPAccessErrorStatus.FORBIDDEN && forbidden\n      const isUnauthorized =\n        triggeredStatus === HTTPAccessErrorStatus.UNAUTHORIZED && unauthorized\n\n      // If there's no matched boundary in this layer, keep throwing the error by rendering the children\n      if (!(isNotFound || isForbidden || isUnauthorized)) {\n        return children\n      }\n\n      return (\n        <>\n          <meta name=\"robots\" content=\"noindex\" />\n          {process.env.NODE_ENV === 'development' && (\n            <meta\n              name=\"boundary-next-error\"\n              content={getAccessFallbackErrorTypeByStatus(triggeredStatus)}\n            />\n          )}\n          {errorComponents[triggeredStatus]}\n        </>\n      )\n    }\n\n    return children\n  }\n}\n\nexport function HTTPAccessFallbackBoundary({\n  notFound,\n  forbidden,\n  unauthorized,\n  children,\n}: HTTPAccessFallbackBoundaryProps) {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these error can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  const missingSlots = useContext(MissingSlotContext)\n  const hasErrorFallback = !!(notFound || forbidden || unauthorized)\n\n  if (hasErrorFallback) {\n    return (\n      <HTTPAccessFallbackErrorBoundary\n        pathname={pathname}\n        notFound={notFound}\n        forbidden={forbidden}\n        unauthorized={unauthorized}\n        missingSlots={missingSlots}\n      >\n        {children}\n      </HTTPAccessFallbackErrorBoundary>\n    )\n  }\n\n  return <>{children}</>\n}\n","import { addBasePath } from './add-base-path'\n\n/**\n * Function to correctly assign location to URL\n *\n * The method will add basePath, and will also correctly add location (including if it is a relative path)\n * @param location Location that should be added to the url\n * @param url Base URL to which the location should be assigned\n */\nexport function assignLocation(location: string, url: URL): URL {\n  if (location.startsWith('.')) {\n    const urlBase = url.origin + url.pathname\n    return new URL(\n      // In order for a relative path to be added to the current url correctly, the current url must end with a slash\n      // new URL('./relative', 'https://example.com/subdir').href -> 'https://example.com/relative'\n      // new URL('./relative', 'https://example.com/subdir/').href -> 'https://example.com/subdir/relative'\n      (urlBase.endsWith('/') ? urlBase : urlBase + '/') + location\n    )\n  }\n\n  return new URL(addBasePath(location), url.href)\n}\n","import {\n  HTTP_ERROR_FALLBACK_ERROR_CODE,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\n\n// TODO: Add `forbidden` docs\n/**\n * @experimental\n * This function allows you to render the [forbidden.js file](https://nextjs.org/docs/app/api-reference/file-conventions/forbidden)\n * within a route segment as well as inject a tag.\n *\n * `forbidden()` can be used in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers), and\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations).\n *\n * Read more: [Next.js Docs: `forbidden`](https://nextjs.org/docs/app/api-reference/functions/forbidden)\n */\n\nconst DIGEST = `${HTTP_ERROR_FALLBACK_ERROR_CODE};403`\n\nexport function forbidden(): never {\n  if (!process.env.__NEXT_EXPERIMENTAL_AUTH_INTERRUPTS) {\n    throw new Error(\n      `\\`forbidden()\\` is experimental and only allowed to be enabled when \\`experimental.authInterrupts\\` is enabled.`\n    )\n  }\n\n  // eslint-disable-next-line no-throw-literal\n  const error = new Error(DIGEST) as HTTPAccessFallbackError\n  ;(error as HTTPAccessFallbackError).digest = DIGEST\n  throw error\n}\n","'use client'\n\nimport { Component, createRef, type ReactNode } from 'react'\n\ninterface ErrorBoundaryProps {\n  children: ReactNode\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean\n}\n\nfunction getDomNodeAttributes(node: HTMLElement): Record<string, string> {\n  const result: Record<string, string> = {}\n  for (let i = 0; i < node.attributes.length; i++) {\n    const attr = node.attributes[i]\n    result[attr.name] = attr.value\n  }\n  return result\n}\n\nexport class GracefulDegradeBoundary extends Component<\n  ErrorBoundaryProps,\n  ErrorBoundaryState\n> {\n  private rootHtml: string\n  private htmlAttributes: Record<string, string>\n  private htmlRef: React.RefObject<HTMLHtmlElement | null>\n\n  constructor(props: ErrorBoundaryProps) {\n    super(props)\n    this.state = { hasError: false }\n    this.rootHtml = ''\n    this.htmlAttributes = {}\n    this.htmlRef = createRef<HTMLHtmlElement>()\n  }\n\n  static getDerivedStateFromError(_: unknown): ErrorBoundaryState {\n    return { hasError: true }\n  }\n\n  componentDidMount() {\n    const htmlNode = this.htmlRef.current\n    if (this.state.hasError && htmlNode) {\n      // Reapply the cached HTML attributes to the root element\n      Object.entries(this.htmlAttributes).forEach(([key, value]) => {\n        htmlNode.setAttribute(key, value)\n      })\n    }\n  }\n\n  render() {\n    const { hasError } = this.state\n    // Cache the root HTML content on the first render\n    if (typeof window !== 'undefined' && !this.rootHtml) {\n      this.rootHtml = document.documentElement.innerHTML\n      this.htmlAttributes = getDomNodeAttributes(document.documentElement)\n    }\n\n    if (hasError) {\n      // Render the current HTML content without hydration\n      return (\n        <html\n          ref={this.htmlRef}\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{\n            __html: this.rootHtml,\n          }}\n        />\n      )\n    }\n\n    return this.props.children\n  }\n}\n\nexport default GracefulDegradeBoundary\n","'use client'\n\nimport type { ParsedUrlQuery } from 'querystring'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nimport type { Params } from '../../server/request/params'\n\n/**\n * When the Page is a client component we send the params and searchParams to this client wrapper\n * where they are turned into dynamically tracked values before being passed to the actual Page component.\n *\n * additionally we may send promises representing the params and searchParams. We don't ever use these passed\n * values but it can be necessary for the sender to send a Promise that doesn't resolve in certain situations.\n * It is up to the caller to decide if the promises are needed.\n */\nexport function ClientPageRoot({\n  Component,\n  searchParams,\n  params,\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  promises,\n}: {\n  Component: React.ComponentType<any>\n  searchParams: ParsedUrlQuery\n  params: Params\n  promises?: Array<Promise<any>>\n}) {\n  if (typeof window === 'undefined') {\n    const { workAsyncStorage } =\n      require('../../server/app-render/work-async-storage.external') as typeof import('../../server/app-render/work-async-storage.external')\n\n    let clientSearchParams: Promise<ParsedUrlQuery>\n    let clientParams: Promise<Params>\n    // We are going to instrument the searchParams prop with tracking for the\n    // appropriate context. We wrap differently in prerendering vs rendering\n    const store = workAsyncStorage.getStore()\n    if (!store) {\n      throw new InvariantError(\n        'Expected workStore to exist when handling searchParams in a client Page.'\n      )\n    }\n\n    const { createSearchParamsFromClient } =\n      require('../../server/request/search-params') as typeof import('../../server/request/search-params')\n    clientSearchParams = createSearchParamsFromClient(searchParams, store)\n\n    const { createParamsFromClient } =\n      require('../../server/request/params') as typeof import('../../server/request/params')\n    clientParams = createParamsFromClient(params, store)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  } else {\n    const { createRenderSearchParamsFromClient } =\n      require('../request/search-params.browser') as typeof import('../request/search-params.browser')\n    const clientSearchParams = createRenderSearchParamsFromClient(searchParams)\n    const { createRenderParamsFromClient } =\n      require('../request/params.browser') as typeof import('../request/params.browser')\n    const clientParams = createRenderParamsFromClient(params)\n\n    return <Component params={clientParams} searchParams={clientSearchParams} />\n  }\n}\n","'use client'\n\nimport React, { type JSX } from 'react'\nimport { useUntrackedPathname } from './navigation-untracked'\nimport { isNextRouterError } from './is-next-router-error'\nimport { handleHardNavError } from './nav-failure-handler'\nimport { HandleISRError } from './handle-isr-error'\nimport { isBot } from '../../shared/lib/router/utils/is-bot'\n\nconst isBotUserAgent =\n  typeof window !== 'undefined' && isBot(window.navigator.userAgent)\n\nexport type ErrorComponent = React.ComponentType<{\n  error: Error\n  // global-error, there's no `reset` function;\n  // regular error boundary, there's a `reset` function.\n  reset?: () => void\n}>\n\nexport interface ErrorBoundaryProps {\n  children?: React.ReactNode\n  errorComponent: ErrorComponent | undefined\n  errorStyles?: React.ReactNode | undefined\n  errorScripts?: React.ReactNode | undefined\n}\n\ninterface ErrorBoundaryHandlerProps extends ErrorBoundaryProps {\n  pathname: string | null\n  errorComponent: ErrorComponent\n}\n\ninterface ErrorBoundaryHandlerState {\n  error: Error | null\n  previousPathname: string | null\n}\n\nexport class ErrorBoundaryHandler extends React.Component<\n  ErrorBoundaryHandlerProps,\n  ErrorBoundaryHandlerState\n> {\n  constructor(props: ErrorBoundaryHandlerProps) {\n    super(props)\n    this.state = { error: null, previousPathname: this.props.pathname }\n  }\n\n  static getDerivedStateFromError(error: Error) {\n    if (isNextRouterError(error)) {\n      // Re-throw if an expected internal Next.js router error occurs\n      // this means it should be handled by a different boundary (such as a NotFound boundary in a parent segment)\n      throw error\n    }\n\n    return { error }\n  }\n\n  static getDerivedStateFromProps(\n    props: ErrorBoundaryHandlerProps,\n    state: ErrorBoundaryHandlerState\n  ): ErrorBoundaryHandlerState | null {\n    const { error } = state\n\n    // if we encounter an error while\n    // a navigation is pending we shouldn't render\n    // the error boundary and instead should fallback\n    // to a hard navigation to attempt recovering\n    if (process.env.__NEXT_APP_NAV_FAIL_HANDLING) {\n      if (error && handleHardNavError(error)) {\n        // clear error so we don't render anything\n        return {\n          error: null,\n          previousPathname: props.pathname,\n        }\n      }\n    }\n\n    /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */\n    if (props.pathname !== state.previousPathname && state.error) {\n      return {\n        error: null,\n        previousPathname: props.pathname,\n      }\n    }\n    return {\n      error: state.error,\n      previousPathname: props.pathname,\n    }\n  }\n\n  reset = () => {\n    this.setState({ error: null })\n  }\n\n  // Explicit type is needed to avoid the generated `.d.ts` having a wide return type that could be specific to the `@types/react` version.\n  render(): React.ReactNode {\n    //When it's bot request, segment level error boundary will keep rendering the children,\n    // the final error will be caught by the root error boundary and determine wether need to apply graceful degrade.\n    if (this.state.error && !isBotUserAgent) {\n      return (\n        <>\n          <HandleISRError error={this.state.error} />\n          {this.props.errorStyles}\n          {this.props.errorScripts}\n          <this.props.errorComponent\n            error={this.state.error}\n            reset={this.reset}\n          />\n        </>\n      )\n    }\n\n    return this.props.children\n  }\n}\n\n/**\n * Handles errors through `getDerivedStateFromError`.\n * Renders the provided error component and provides a way to `reset` the error boundary state.\n */\n\n/**\n * Renders error boundary with the provided \"errorComponent\" property as the fallback.\n * If no \"errorComponent\" property is provided it renders the children without an error boundary.\n */\nexport function ErrorBoundary({\n  errorComponent,\n  errorStyles,\n  errorScripts,\n  children,\n}: ErrorBoundaryProps & {\n  children: React.ReactNode\n}): JSX.Element {\n  // When we're rendering the missing params shell, this will return null. This\n  // is because we won't be rendering any not found boundaries or error\n  // boundaries for the missing params shell. When this runs on the client\n  // (where these errors can occur), we will get the correct pathname.\n  const pathname = useUntrackedPathname()\n  if (errorComponent) {\n    return (\n      <ErrorBoundaryHandler\n        pathname={pathname}\n        errorComponent={errorComponent}\n        errorStyles={errorStyles}\n        errorScripts={errorScripts}\n      >\n        {children}\n      </ErrorBoundaryHandler>\n    )\n  }\n\n  return <>{children}</>\n}\n"],"names":["instrumentationHooks","appBootstrap","require","hydrate","isNextRouterError","error","isRedirectError","isHTTPAccessFallbackError","createMutableActionQueue","dispatchNavigateAction","dispatchTraverseAction","getCurrentAppRouterState","publicAppRouterInstance","runRemainingActions","actionQueue","setState","pending","next","runAction","action","needsRefresh","dispatch","type","ACTION_REFRESH","origin","window","location","payload","handleResult","nextState","discarded","state","resolve","prevState","actionResult","isThenable","then","err","reject","globalActionQueue","initialState","resolvers","ACTION_RESTORE","deferredPromise","Promise","startTransition","newAction","last","ACTION_NAVIGATE","ACTION_SERVER_ACTION","reducer","onRouterTransitionStart","getProfilingHookForOnNavigationStart","href","navigateType","shouldScroll","linkInstanceRef","url","URL","addBasePath","setLinkForCurrentNavigation","dispatchAppRouterAction","isExternalUrl","isExternalURL","locationSearch","search","allowAliasing","tree","back","history","forward","prefetch","process","options","getAppRouterActionQueue","createPrefetchURL","prefetchReducer","ACTION_PREFETCH","kind","PrefetchKind","FULL","replace","scroll","push","refresh","hmrRefresh","Error","router","HandleISRError","workAsyncStorage","undefined","store","getStore","isRevalidate","isStaticGeneration","createEmptyCacheNode","AppRouter","globalMutable","isBot","navigator","userAgent","_","HistoryUpdater","appRouterState","useInsertionEffect","pushRef","canonicalUrl","historyState","preserveCustomHistoryState","__NA","__PRIVATE_NEXTJS_INTERNALS_TREE","pendingPush","createHrefFromUrl","pushState","replaceState","useEffect","nextUrl","lazyData","rsc","prefetchRsc","head","prefetchHead","parallelRoutes","Map","loading","navigatedAt","copyNextJsInternalHistoryState","data","currentState","Head","headCacheNode","resolvedPrefetchRsc","useDeferredValue","Router","assetPrefix","globalError","useActionQueue","useMemo","searchParams","pathname","hasBasePath","removeBasePath","handlePageShow","event","persisted","pendingMpaPath","addEventListener","removeEventListener","reason","preventDefault","getURLFromRedirectError","redirectType","getRedirectTypeFromError","RedirectType","handleUnhandledRedirect","mpaNavigation","assign","unresolvedThenable","originalPushState","bind","originalReplaceState","applyUrlFromHistoryPushReplace","_unused","_N","onPopState","reload","cache","focusAndScrollRef","matchingHead","findHeadInCache","pathParams","getSelectedParams","layoutRouterContext","parentTree","parentCacheNode","parentSegmentPath","globalLayoutRouterContext","headKey","headKeyWithoutSearchParams","content","RedirectBoundary","RootLayoutBoundary","AppRouterAnnouncer","RootErrorBoundary","errorComponent","errorStyles","RuntimeStyles","PathParamsContext","Provider","value","PathnameContext","SearchParamsContext","GlobalLayoutRouterContext","AppRouterContext","LayoutRouterContext","globalErrorState","useNavFailureHandler","DefaultGlobalError","runtimeStyles","Set","runtimeStyleChanged","forceUpdate","React","useState","renderedStylesSize","size","changed","c","add","delete","map","i","link","rel","precedence","dplId","globalThis","_N_E_STYLE_LOAD","len","cb","ClientSegmentRoot","Component","slots","params","promise","clientParams","getChunkScriptFilename","__webpack_require__","u","args","encodeURIPath","isBotUserAgent","children","errorScripts","GracefulDegradeBoundary","ErrorBoundary","HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Object","values","digest","split","prefix","httpStatus","has","Number","status","useRouterBFCache","activeTree","activeStateKey","initialEntry","stateKey","prevActiveEntry","setPrevActiveEntry","newActiveEntry","n","oldEntry","clonedEntry","MAX_BF_CACHE_ENTRIES","entry","ANNOUNCER_TYPE","portalNode","setPortalNode","getAnnouncerNode","announcer","existingAnnouncer","document","getElementsByName","shadowRoot","childNodes","container","createElement","style","cssText","ariaLive","id","ANNOUNCER_ID","role","shadow","attachShadow","mode","appendChild","body","getElementsByTagName","isConnected","removeChild","routeAnnouncement","setRouteAnnouncement","previousTitle","useRef","currentTitle","title","pageHeader","querySelector","innerText","textContent","current","createPortal","ACTION_HEADER","FLIGHT_HEADERS","NEXT_ACTION_NOT_FOUND_HEADER","NEXT_DID_POSTPONE_HEADER","NEXT_HMR_REFRESH_HASH_COOKIE","NEXT_HMR_REFRESH_HEADER","NEXT_IS_PRERENDER_HEADER","NEXT_REWRITTEN_PATH_HEADER","NEXT_REWRITTEN_QUERY_HEADER","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STALE_TIME_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_RSC_UNION_QUERY","NEXT_URL","RSC_CONTENT_TYPE_HEADER","RSC_HEADER","styles","fontFamily","height","textAlign","display","flexDirection","alignItems","justifyContent","text","fontSize","fontWeight","lineHeight","margin","html","div","h2","hostname","p","HTTPAccessFallbackBoundary","props","triggeredStatus","previousPathname","componentDidCatch","render","notFound","forbidden","unauthorized","errorComponents","isNotFound","isForbidden","isUnauthorized","meta","name","getDerivedStateFromError","getDerivedStateFromProps","HTTPAccessFallbackErrorBoundary","useUntrackedPathname","missingSlots","useContext","MissingSlotContext","hasErrorFallback","assignLocation","startsWith","urlBase","endsWith","hasError","rootHtml","htmlAttributes","htmlRef","createRef","componentDidMount","htmlNode","forEach","key","setAttribute","documentElement","innerHTML","getDomNodeAttributes","result","node","attributes","length","attr","ref","suppressHydrationWarning","dangerouslySetInnerHTML","__html","ClientPageRoot","promises","clientSearchParams","createRenderParamsFromClient","ErrorBoundaryHandler","reset","this"],"sourceRoot":"","ignoreList":[]}