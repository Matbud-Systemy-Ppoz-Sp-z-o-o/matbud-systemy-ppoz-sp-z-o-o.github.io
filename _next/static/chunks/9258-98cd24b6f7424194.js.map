{"version":3,"file":"static/chunks/9258-98cd24b6f7424194.js","mappings":"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","sources":["webpack://_N_E/../../../../src/client/components/router-reducer/set-cache-busting-search-param.ts","webpack://_N_E/../../../../src/client/components/router-reducer/refetch-inactive-parallel-segments.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/navigate-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/server-patch-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/restore-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/refresh-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/prefetch-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/has-interception-route-in-current-tree.ts","webpack://_N_E/../../../../src/client/components/router-reducer/should-hard-navigate.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/server-action-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/reducers/hmr-refresh-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/router-reducer.ts","webpack://_N_E/../../../../src/client/components/router-reducer/router-reducer-types.ts"],"sourcesContent":["'use client'\n\nimport { computeCacheBustingSearchParam } from '../../../shared/lib/router/utils/cache-busting-search-param'\nimport {\n  NEXT_ROUTER_PREFETCH_HEADER,\n  NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  NEXT_RSC_UNION_QUERY,\n} from '../app-router-headers'\nimport type { RequestHeaders } from './fetch-server-response'\n\n/**\n * Mutates the provided URL by adding a cache-busting search parameter for CDNs that don't\n * support custom headers. This helps avoid caching conflicts by making each request unique.\n *\n * Rather than relying on the Vary header which some CDNs ignore, we append a search param\n * to create a unique URL that forces a fresh request.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * Note: This function mutates the input URL directly and does not return anything.\n *\n * TODO: Since we need to use a search param anyway, we could simplify by removing the custom\n * headers approach entirely and just use search params.\n */\nexport const setCacheBustingSearchParam = (\n  url: URL,\n  headers: RequestHeaders\n): void => {\n  const uniqueCacheKey = computeCacheBustingSearchParam(\n    headers[NEXT_ROUTER_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_SEGMENT_PREFETCH_HEADER],\n    headers[NEXT_ROUTER_STATE_TREE_HEADER],\n    headers[NEXT_URL]\n  )\n  setCacheBustingSearchParamWithHash(url, uniqueCacheKey)\n}\n\n/**\n * Sets a cache-busting search parameter on a URL using a provided hash value.\n *\n * This function performs the same logic as `setCacheBustingSearchParam` but accepts\n * a pre-computed hash instead of computing it from headers.\n *\n * Example:\n * URL before: https://example.com/path?query=1\n * hash: \"abc123\"\n * URL after: https://example.com/path?query=1&_rsc=abc123\n *\n * If the hash is null, we will set `_rsc` search param without a value.\n * Like this: https://example.com/path?query=1&_rsc\n *\n * Note: This function mutates the input URL directly and does not return anything.\n */\nexport const setCacheBustingSearchParamWithHash = (\n  url: URL,\n  hash: string\n): void => {\n  /**\n   * Note that we intentionally do not use `url.searchParams.set` here:\n   *\n   * const url = new URL('https://example.com/search?q=custom%20spacing');\n   * url.searchParams.set('_rsc', 'abc123');\n   * console.log(url.toString()); // Outputs: https://example.com/search?q=custom+spacing&_rsc=abc123\n   *                                                                             ^ <--- this is causing confusion\n   * This is in fact intended based on https://url.spec.whatwg.org/#interface-urlsearchparams, but\n   * we want to preserve the %20 as %20 if that's what the user passed in, hence the custom\n   * logic below.\n   */\n  const existingSearch = url.search\n  const rawQuery = existingSearch.startsWith('?')\n    ? existingSearch.slice(1)\n    : existingSearch\n\n  // Always remove any existing cache busting param and add a fresh one to ensure\n  // we have the correct value based on current request headers\n  const pairs = rawQuery\n    .split('&')\n    .filter((pair) => pair && !pair.startsWith(`${NEXT_RSC_UNION_QUERY}=`))\n\n  if (hash.length > 0) {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}=${hash}`)\n  } else {\n    pairs.push(`${NEXT_RSC_UNION_QUERY}`)\n  }\n  url.search = pairs.length ? `?${pairs.join('&')}` : ''\n}\n","import type { FlightRouterState } from '../../../server/app-render/types'\nimport type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type { AppRouterState } from './router-reducer-types'\nimport { applyFlightData } from './apply-flight-data'\nimport { fetchServerResponse } from './fetch-server-response'\nimport { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n\ninterface RefreshInactiveParallelSegments {\n  navigatedAt: number\n  state: AppRouterState\n  updatedTree: FlightRouterState\n  updatedCache: CacheNode\n  includeNextUrl: boolean\n  canonicalUrl: string\n}\n\n/**\n * Refreshes inactive segments that are still in the current FlightRouterState.\n * A segment is considered \"inactive\" when the server response indicates it didn't match to a page component.\n * This happens during a soft-navigation, where the server will want to patch in the segment\n * with the \"default\" component, but we explicitly ignore the server in this case\n * and keep the existing state for that segment. New data for inactive segments are inherently\n * not part of the server response when we patch the tree, because they were associated with a response\n * from an earlier navigation/request. For each segment, once it becomes \"active\", we encode the URL that provided\n * the data for it. This function traverses parallel routes looking for these markers so that it can re-fetch\n * and patch the new data into the tree.\n */\nexport async function refreshInactiveParallelSegments(\n  options: RefreshInactiveParallelSegments\n) {\n  const fetchedSegments = new Set<string>()\n  await refreshInactiveParallelSegmentsImpl({\n    ...options,\n    rootTree: options.updatedTree,\n    fetchedSegments,\n  })\n}\n\nasync function refreshInactiveParallelSegmentsImpl({\n  navigatedAt,\n  state,\n  updatedTree,\n  updatedCache,\n  includeNextUrl,\n  fetchedSegments,\n  rootTree = updatedTree,\n  canonicalUrl,\n}: RefreshInactiveParallelSegments & {\n  fetchedSegments: Set<string>\n  rootTree: FlightRouterState\n}) {\n  const [, parallelRoutes, refetchPath, refetchMarker] = updatedTree\n  const fetchPromises = []\n\n  if (\n    refetchPath &&\n    refetchPath !== canonicalUrl &&\n    refetchMarker === 'refresh' &&\n    // it's possible for the tree to contain multiple segments that contain data at the same URL\n    // we keep track of them so we can dedupe the requests\n    !fetchedSegments.has(refetchPath)\n  ) {\n    fetchedSegments.add(refetchPath) // Mark this URL as fetched\n\n    // Eagerly kick off the fetch for the refetch path & the parallel routes. This should be fine to do as they each operate\n    // independently on their own cache nodes, and `applyFlightData` will copy anything it doesn't care about from the existing cache.\n    const fetchPromise = fetchServerResponse(\n      new URL(refetchPath, location.origin),\n      {\n        // refetch from the root of the updated tree, otherwise it will be scoped to the current segment\n        // and might not contain the data we need to patch in interception route data (such as dynamic params from a previous segment)\n        flightRouterState: [rootTree[0], rootTree[1], rootTree[2], 'refetch'],\n        nextUrl: includeNextUrl ? state.nextUrl : null,\n      }\n    ).then(({ flightData }) => {\n      if (typeof flightData !== 'string') {\n        for (const flightDataPath of flightData) {\n          // we only pass the new cache as this function is called after clearing the router cache\n          // and filling in the new page data from the server. Meaning the existing cache is actually the cache that's\n          // just been created & has been written to, but hasn't been \"committed\" yet.\n          applyFlightData(\n            navigatedAt,\n            updatedCache,\n            updatedCache,\n            flightDataPath\n          )\n        }\n      } else {\n        // When flightData is a string, it suggests that the server response should have triggered an MPA navigation\n        // I'm not 100% sure of this decision, but it seems unlikely that we'd want to introduce a redirect side effect\n        // when refreshing on-screen data, so handling this has been ommitted.\n      }\n    })\n\n    fetchPromises.push(fetchPromise)\n  }\n\n  for (const key in parallelRoutes) {\n    const parallelFetchPromise = refreshInactiveParallelSegmentsImpl({\n      navigatedAt,\n      state,\n      updatedTree: parallelRoutes[key],\n      updatedCache,\n      includeNextUrl,\n      fetchedSegments,\n      rootTree,\n      canonicalUrl,\n    })\n\n    fetchPromises.push(parallelFetchPromise)\n  }\n\n  await Promise.all(fetchPromises)\n}\n\n/**\n * Walks the current parallel segments to determine if they are \"active\".\n * An active parallel route will have a `__PAGE__` segment in the FlightRouterState.\n * As opposed to a `__DEFAULT__` segment, which means there was no match for that parallel route.\n * We add a special marker here so that we know how to refresh its data when the router is revalidated.\n */\nexport function addRefreshMarkerToActiveParallelSegments(\n  tree: FlightRouterState,\n  path: string\n) {\n  const [segment, parallelRoutes, , refetchMarker] = tree\n  // a page segment might also contain concatenated search params, so we do a partial match on the key\n  if (segment.includes(PAGE_SEGMENT_KEY) && refetchMarker !== 'refresh') {\n    tree[2] = path\n    tree[3] = 'refresh'\n  }\n\n  for (const key in parallelRoutes) {\n    addRefreshMarkerToActiveParallelSegments(parallelRoutes[key], path)\n  }\n}\n","import type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../../server/app-render/types'\nimport { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { invalidateCacheBelowFlightSegmentPath } from '../invalidate-cache-below-flight-segmentpath'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { shouldHardNavigate } from '../should-hard-navigate'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport {\n  PrefetchCacheEntryStatus,\n  type Mutable,\n  type NavigateAction,\n  type ReadonlyReducerState,\n  type ReducerState,\n} from '../router-reducer-types'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport { prefetchQueue } from './prefetch-reducer'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { DEFAULT_SEGMENT_KEY } from '../../../../shared/lib/segment'\nimport { listenForDynamicRequest, startPPRNavigation } from '../ppr-navigations'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nimport { clearCacheNodeDataForSegmentPath } from '../clear-cache-node-data-for-segment-path'\nimport { handleAliasedPrefetchEntry } from '../aliased-prefetch-navigations'\nimport {\n  navigate as navigateUsingSegmentCache,\n  NavigationResultTag,\n  type NavigationResult,\n} from '../../segment-cache'\n\nexport function handleExternalUrl(\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  url: string,\n  pendingPush: boolean\n) {\n  mutable.mpaNavigation = true\n  mutable.canonicalUrl = url\n  mutable.pendingPush = pendingPush\n  mutable.scrollableSegments = undefined\n\n  return handleMutable(state, mutable)\n}\n\nexport function generateSegmentsFromPatch(\n  flightRouterPatch: FlightRouterState\n): FlightSegmentPath[] {\n  const segments: FlightSegmentPath[] = []\n  const [segment, parallelRoutes] = flightRouterPatch\n\n  if (Object.keys(parallelRoutes).length === 0) {\n    return [[segment]]\n  }\n\n  for (const [parallelRouteKey, parallelRoute] of Object.entries(\n    parallelRoutes\n  )) {\n    for (const childSegment of generateSegmentsFromPatch(parallelRoute)) {\n      // If the segment is empty, it means we are at the root of the tree\n      if (segment === '') {\n        segments.push([parallelRouteKey, ...childSegment])\n      } else {\n        segments.push([segment, parallelRouteKey, ...childSegment])\n      }\n    }\n  }\n\n  return segments\n}\n\nfunction triggerLazyFetchForLeafSegments(\n  newCache: CacheNode,\n  currentCache: CacheNode,\n  flightSegmentPath: FlightSegmentPath,\n  treePatch: FlightRouterState\n) {\n  let appliedPatch = false\n\n  newCache.rsc = currentCache.rsc\n  newCache.prefetchRsc = currentCache.prefetchRsc\n  newCache.loading = currentCache.loading\n  newCache.parallelRoutes = new Map(currentCache.parallelRoutes)\n\n  const segmentPathsToFill = generateSegmentsFromPatch(treePatch).map(\n    (segment) => [...flightSegmentPath, ...segment]\n  )\n\n  for (const segmentPaths of segmentPathsToFill) {\n    clearCacheNodeDataForSegmentPath(newCache, currentCache, segmentPaths)\n\n    appliedPatch = true\n  }\n\n  return appliedPatch\n}\n\nfunction handleNavigationResult(\n  url: URL,\n  state: ReadonlyReducerState,\n  mutable: Mutable,\n  pendingPush: boolean,\n  result: NavigationResult\n): ReducerState {\n  switch (result.tag) {\n    case NavigationResultTag.MPA: {\n      // Perform an MPA navigation.\n      const newUrl = result.data\n      return handleExternalUrl(state, mutable, newUrl, pendingPush)\n    }\n    case NavigationResultTag.NoOp: {\n      // The server responded with no change to the current page. However, if\n      // the URL changed, we still need to update that.\n      const newCanonicalUrl = result.data.canonicalUrl\n      mutable.canonicalUrl = newCanonicalUrl\n\n      // Check if the only thing that changed was the hash fragment.\n      const oldUrl = new URL(state.canonicalUrl, url)\n      const onlyHashChange =\n        // We don't need to compare the origins, because client-driven\n        // navigations are always same-origin.\n        url.pathname === oldUrl.pathname &&\n        url.search === oldUrl.search &&\n        url.hash !== oldUrl.hash\n      if (onlyHashChange) {\n        // The only updated part of the URL is the hash.\n        mutable.onlyHashChange = true\n        mutable.shouldScroll = result.data.shouldScroll\n        mutable.hashFragment = url.hash\n        // Setting this to an empty array triggers a scroll for all new and\n        // updated segments. See `ScrollAndFocusHandler` for more details.\n        mutable.scrollableSegments = []\n      }\n\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Success: {\n      // Received a new result.\n      mutable.cache = result.data.cacheNode\n      mutable.patchedTree = result.data.flightRouterState\n      mutable.canonicalUrl = result.data.canonicalUrl\n      mutable.scrollableSegments = result.data.scrollableSegments\n      mutable.shouldScroll = result.data.shouldScroll\n      mutable.hashFragment = result.data.hash\n      return handleMutable(state, mutable)\n    }\n    case NavigationResultTag.Async: {\n      return result.data.then(\n        (asyncResult) =>\n          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n        // If the navigation failed, return the current state.\n        // TODO: This matches the current behavior but we need to do something\n        // better here if the network fails.\n        () => {\n          return state\n        }\n      )\n    }\n    default: {\n      result satisfies never\n      return state\n    }\n  }\n}\n\nexport function navigateReducer(\n  state: ReadonlyReducerState,\n  action: NavigateAction\n): ReducerState {\n  const { url, isExternalUrl, navigateType, shouldScroll, allowAliasing } =\n    action\n  const mutable: Mutable = {}\n  const { hash } = url\n  const href = createHrefFromUrl(url)\n  const pendingPush = navigateType === 'push'\n  // we want to prune the prefetch cache on every navigation to avoid it growing too large\n  prunePrefetchCache(state.prefetchCache)\n\n  mutable.preserveCustomHistoryState = false\n  mutable.pendingPush = pendingPush\n\n  if (isExternalUrl) {\n    return handleExternalUrl(state, mutable, url.toString(), pendingPush)\n  }\n\n  // Handles case where `<meta http-equiv=\"refresh\">` tag is present,\n  // which will trigger an MPA navigation.\n  if (document.getElementById('__next-page-redirect')) {\n    return handleExternalUrl(state, mutable, href, pendingPush)\n  }\n\n  if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n    // (Very Early Experimental Feature) Segment Cache\n    //\n    // Bypass the normal prefetch cache and use the new per-segment cache\n    // implementation instead. This is only supported if PPR is enabled, too.\n    //\n    // Temporary glue code between the router reducer and the new navigation\n    // implementation. Eventually we'll rewrite the router reducer to a\n    // state machine.\n    const result = navigateUsingSegmentCache(\n      url,\n      state.cache,\n      state.tree,\n      state.nextUrl,\n      shouldScroll\n    )\n    return handleNavigationResult(url, state, mutable, pendingPush, result)\n  }\n\n  const prefetchValues = getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    tree: state.tree,\n    prefetchCache: state.prefetchCache,\n    allowAliasing,\n  })\n  const { treeAtTimeOfPrefetch, data } = prefetchValues\n\n  prefetchQueue.bump(data)\n\n  return data.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride, postponed }) => {\n      const navigatedAt = Date.now()\n\n      let isFirstRead = false\n      // we only want to mark this once\n      if (!prefetchValues.lastUsedTime) {\n        // important: we should only mark the cache node as dirty after we unsuspend from the call above\n        prefetchValues.lastUsedTime = navigatedAt\n        isFirstRead = true\n      }\n\n      if (prefetchValues.aliased) {\n        // When alias is enabled, search param may not be included in the canonicalUrl.\n        // But we want to set url to canonicalUrl so that we use redirected path for fetching dynamic data.\n        const urlWithCanonicalPathname = new URL(url.href)\n        if (canonicalUrlOverride) {\n          urlWithCanonicalPathname.pathname = canonicalUrlOverride.pathname\n        }\n\n        const result = handleAliasedPrefetchEntry(\n          navigatedAt,\n          state,\n          flightData,\n          urlWithCanonicalPathname,\n          mutable\n        )\n\n        // We didn't return new router state because we didn't apply the aliased entry for some reason.\n        // We'll re-invoke the navigation handler but ensure that we don't attempt to use the aliased entry. This\n        // will create an on-demand prefetch entry.\n        if (result === false) {\n          return navigateReducer(state, { ...action, allowAliasing: false })\n        }\n\n        return result\n      }\n\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(state, mutable, flightData, pendingPush)\n      }\n\n      const updatedCanonicalUrl = canonicalUrlOverride\n        ? createHrefFromUrl(canonicalUrlOverride)\n        : href\n\n      const onlyHashChange =\n        !!hash &&\n        state.canonicalUrl.split('#', 1)[0] ===\n          updatedCanonicalUrl.split('#', 1)[0]\n\n      // If only the hash has changed, the server hasn't sent us any new data. We can just update\n      // the mutable properties responsible for URL and scroll handling and return early.\n      if (onlyHashChange) {\n        mutable.onlyHashChange = true\n        mutable.canonicalUrl = updatedCanonicalUrl\n        mutable.shouldScroll = shouldScroll\n        mutable.hashFragment = hash\n        mutable.scrollableSegments = []\n        return handleMutable(state, mutable)\n      }\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n      let scrollableSegments: FlightSegmentPath[] = []\n      for (const normalizedFlightData of flightData) {\n        const {\n          pathToSegment: flightSegmentPath,\n          seedData,\n          head,\n          isHeadPartial,\n          isRootRender,\n        } = normalizedFlightData\n        let treePatch = normalizedFlightData.tree\n\n        // TODO-APP: remove ''\n        const flightSegmentPathWithLeadingEmpty = ['', ...flightSegmentPath]\n\n        // Create new tree based on the flightSegmentPath and router state patch\n        let newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          flightSegmentPathWithLeadingEmpty,\n          currentTree,\n          treePatch,\n          href\n        )\n\n        // If the tree patch can't be applied to the current tree then we use the tree at time of prefetch\n        // TODO-APP: This should instead fill in the missing pieces in `currentTree` with the data from `treeAtTimeOfPrefetch`, then apply the patch.\n        if (newTree === null) {\n          newTree = applyRouterStatePatchToTree(\n            // TODO-APP: remove ''\n            flightSegmentPathWithLeadingEmpty,\n            treeAtTimeOfPrefetch,\n            treePatch,\n            href\n          )\n        }\n\n        if (newTree !== null) {\n          if (\n            // This is just a paranoid check. When a route is PPRed, the server\n            // will send back a static response that's rendered from\n            // the root. If for some reason it doesn't, we fall back to the\n            // non-PPR implementation.\n            // TODO: We should get rid of the else branch and do all navigations\n            // via startPPRNavigation. The current structure is just\n            // an incremental step.\n            seedData &&\n            isRootRender &&\n            postponed\n          ) {\n            const task = startPPRNavigation(\n              navigatedAt,\n              currentCache,\n              currentTree,\n              treePatch,\n              seedData,\n              head,\n              isHeadPartial,\n              false,\n              scrollableSegments\n            )\n\n            if (task !== null) {\n              if (task.route === null) {\n                // Detected a change to the root layout. Perform an full-\n                // page navigation.\n                return handleExternalUrl(state, mutable, href, pendingPush)\n              }\n              // Use the tree computed by startPPRNavigation instead\n              // of the one computed by applyRouterStatePatchToTree.\n              // TODO: We should remove applyRouterStatePatchToTree\n              // from the PPR path entirely.\n              const patchedRouterState: FlightRouterState = task.route\n              newTree = patchedRouterState\n\n              const newCache = task.node\n              if (newCache !== null) {\n                // We've created a new Cache Node tree that contains a prefetched\n                // version of the next page. This can be rendered instantly.\n                mutable.cache = newCache\n              }\n              const dynamicRequestTree = task.dynamicRequestTree\n              if (dynamicRequestTree !== null) {\n                // The prefetched tree has dynamic holes in it. We initiate a\n                // dynamic request to fill them in.\n                //\n                // Do not block on the result. We'll immediately render the Cache\n                // Node tree and suspend on the dynamic parts. When the request\n                // comes in, we'll fill in missing data and ping React to\n                // re-render. Unlike the lazy fetching model in the non-PPR\n                // implementation, this is modeled as a single React update +\n                // streaming, rather than multiple top-level updates. (However,\n                // even in the new model, we'll still need to sometimes update the\n                // root multiple times per navigation, like if the server sends us\n                // a different response than we expected. For now, we revert back\n                // to the lazy fetching mechanism in that case.)\n                const dynamicRequest = fetchServerResponse(\n                  new URL(updatedCanonicalUrl, url.origin),\n                  {\n                    flightRouterState: dynamicRequestTree,\n                    nextUrl: state.nextUrl,\n                  }\n                )\n\n                listenForDynamicRequest(task, dynamicRequest)\n                // We store the dynamic request on the `lazyData` property of the CacheNode\n                // because we're not going to await the dynamic request here. Since we're not blocking\n                // on the dynamic request, `layout-router` will\n                // task.node.lazyData = dynamicRequest\n              } else {\n                // The prefetched tree does not contain dynamic holes â€” it's\n                // fully static. We can skip the dynamic request.\n              }\n            } else {\n              // Nothing changed, so reuse the old cache.\n              // TODO: What if the head changed but not any of the segment data?\n              // Is that possible? If so, we should clone the whole tree and\n              // update the head.\n              newTree = treePatch\n            }\n          } else {\n            // The static response does not include any dynamic holes, so\n            // there's no need to do a second request.\n            // TODO: As an incremental step this just reverts back to the\n            // non-PPR implementation. We can simplify this branch further,\n            // given that PPR prefetches are always static and return the whole\n            // tree. Or in the meantime we could factor it out into a\n            // separate function.\n\n            if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n              return handleExternalUrl(state, mutable, href, pendingPush)\n            }\n\n            const cache: CacheNode = createEmptyCacheNode()\n            let applied = false\n\n            if (\n              prefetchValues.status === PrefetchCacheEntryStatus.stale &&\n              !isFirstRead\n            ) {\n              // When we have a stale prefetch entry, we only want to re-use the loading state of the route we're navigating to, to support instant loading navigations\n              // this will trigger a lazy fetch for the actual page data by nulling the `rsc` and `prefetchRsc` values for page data,\n              // while copying over the `loading` for the segment that contains the page data.\n              // We only do this on subsequent reads, as otherwise there'd be no loading data to re-use.\n\n              // We skip this branch if only the hash fragment has changed, as we don't want to trigger a lazy fetch in that case\n              applied = triggerLazyFetchForLeafSegments(\n                cache,\n                currentCache,\n                flightSegmentPath,\n                treePatch\n              )\n              // since we re-used the stale cache's loading state & refreshed the data,\n              // update the `lastUsedTime` so that it can continue to be re-used for the next 30s\n              prefetchValues.lastUsedTime = navigatedAt\n            } else {\n              applied = applyFlightData(\n                navigatedAt,\n                currentCache,\n                cache,\n                normalizedFlightData,\n                prefetchValues\n              )\n            }\n\n            const hardNavigate = shouldHardNavigate(\n              // TODO-APP: remove ''\n              flightSegmentPathWithLeadingEmpty,\n              currentTree\n            )\n\n            if (hardNavigate) {\n              // Copy rsc for the root node of the cache.\n              cache.rsc = currentCache.rsc\n              cache.prefetchRsc = currentCache.prefetchRsc\n\n              invalidateCacheBelowFlightSegmentPath(\n                cache,\n                currentCache,\n                flightSegmentPath\n              )\n              // Ensure the existing cache value is used when the cache was not invalidated.\n              mutable.cache = cache\n            } else if (applied) {\n              mutable.cache = cache\n              // If we applied the cache, we update the \"current cache\" value so any other\n              // segments in the FlightDataPath will be able to reference the updated cache.\n              currentCache = cache\n            }\n\n            for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n              const scrollableSegmentPath = [\n                ...flightSegmentPath,\n                ...subSegment,\n              ]\n              // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n              if (\n                scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n                DEFAULT_SEGMENT_KEY\n              ) {\n                scrollableSegments.push(scrollableSegmentPath)\n              }\n            }\n          }\n\n          currentTree = newTree\n        }\n      }\n\n      mutable.patchedTree = currentTree\n      mutable.canonicalUrl = updatedCanonicalUrl\n      mutable.scrollableSegments = scrollableSegments\n      mutable.hashFragment = hash\n      mutable.shouldScroll = shouldScroll\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ServerPatchAction,\n  ReducerState,\n  ReadonlyReducerState,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyFlightData } from '../apply-flight-data'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\n\nexport function serverPatchReducer(\n  state: ReadonlyReducerState,\n  action: ServerPatchAction\n): ReducerState {\n  const {\n    serverResponse: { flightData, canonicalUrl: canonicalUrlOverride },\n    navigatedAt,\n  } = action\n\n  const mutable: Mutable = {}\n\n  mutable.preserveCustomHistoryState = false\n\n  // Handle case when navigating to page in `pages` from `app`\n  if (typeof flightData === 'string') {\n    return handleExternalUrl(\n      state,\n      mutable,\n      flightData,\n      state.pushRef.pendingPush\n    )\n  }\n\n  let currentTree = state.tree\n  let currentCache = state.cache\n\n  for (const normalizedFlightData of flightData) {\n    const { segmentPath: flightSegmentPath, tree: treePatch } =\n      normalizedFlightData\n\n    const newTree = applyRouterStatePatchToTree(\n      // TODO-APP: remove ''\n      ['', ...flightSegmentPath],\n      currentTree,\n      treePatch,\n      state.canonicalUrl\n    )\n\n    // `applyRouterStatePatchToTree` returns `null` when it determined that the server response is not applicable to the current tree.\n    // In other words, the server responded with a tree that doesn't match what the client is currently rendering.\n    // This can happen if the server patch action took longer to resolve than a subsequent navigation which would have changed the tree.\n    // Previously this case triggered an MPA navigation but it should be safe to simply discard the server response rather than forcing\n    // the entire page to reload.\n    if (newTree === null) {\n      return state\n    }\n\n    if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n      return handleExternalUrl(\n        state,\n        mutable,\n        state.canonicalUrl,\n        state.pushRef.pendingPush\n      )\n    }\n\n    const canonicalUrlOverrideHref = canonicalUrlOverride\n      ? createHrefFromUrl(canonicalUrlOverride)\n      : undefined\n\n    if (canonicalUrlOverrideHref) {\n      mutable.canonicalUrl = canonicalUrlOverrideHref\n    }\n\n    const cache: CacheNode = createEmptyCacheNode()\n    applyFlightData(navigatedAt, currentCache, cache, normalizedFlightData)\n\n    mutable.patchedTree = newTree\n    mutable.cache = cache\n\n    currentCache = cache\n    currentTree = newTree\n  }\n\n  return handleMutable(state, mutable)\n}\n","import { createHrefFromUrl } from '../create-href-from-url'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  RestoreAction,\n} from '../router-reducer-types'\nimport { extractPathFromFlightRouterState } from '../compute-changed-path'\nimport { updateCacheNodeOnPopstateRestoration } from '../ppr-navigations'\n\nexport function restoreReducer(\n  state: ReadonlyReducerState,\n  action: RestoreAction\n): ReducerState {\n  const { url, tree } = action\n  const href = createHrefFromUrl(url)\n  // This action is used to restore the router state from the history state.\n  // However, it's possible that the history state no longer contains the `FlightRouterState`.\n  // We will copy over the internal state on pushState/replaceState events, but if a history entry\n  // occurred before hydration, or if the user navigated to a hash using a regular anchor link,\n  // the history state will not contain the `FlightRouterState`.\n  // In this case, we'll continue to use the existing tree so the router doesn't get into an invalid state.\n  const treeToRestore = tree || state.tree\n\n  const oldCache = state.cache\n  const newCache = process.env.__NEXT_PPR\n    ? // When PPR is enabled, we update the cache to drop the prefetch\n      // data for any segment whose dynamic data was already received. This\n      // prevents an unnecessary flash back to PPR state during a\n      // back/forward navigation.\n      updateCacheNodeOnPopstateRestoration(oldCache, treeToRestore)\n    : oldCache\n\n  return {\n    // Set canonical url\n    canonicalUrl: href,\n    pushRef: {\n      pendingPush: false,\n      mpaNavigation: false,\n      // Ensures that the custom history state that was set is preserved when applying this update.\n      preserveCustomHistoryState: true,\n    },\n    focusAndScrollRef: state.focusAndScrollRef,\n    cache: newCache,\n    prefetchCache: state.prefetchCache,\n    // Restore provided tree\n    tree: treeToRestore,\n    nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n  }\n}\n","import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  Mutable,\n  ReadonlyReducerState,\n  ReducerState,\n  RefreshAction,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport { revalidateEntireCache } from '../../segment-cache'\n\nexport function refreshReducer(\n  state: ReadonlyReducerState,\n  action: RefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [\n      currentTree[0],\n      currentTree[1],\n      currentTree[2],\n      'refetch',\n    ],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n  })\n\n  const navigatedAt = Date.now()\n  return cache.lazyData.then(\n    async ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n\n        // Handles case where prefetch only returns the router tree patch without rendered components.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const loading = cacheNodeSeedData[3]\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = loading\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            undefined\n          )\n          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n            revalidateEntireCache(state.nextUrl, newTree)\n          } else {\n            mutable.prefetchCache = new Map()\n          }\n        }\n\n        await refreshInactiveParallelSegments({\n          navigatedAt,\n          state,\n          updatedTree: newTree,\n          updatedCache: cache,\n          includeNextUrl,\n          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n        })\n\n        mutable.cache = cache\n        mutable.patchedTree = newTree\n\n        currentTree = newTree\n      }\n\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n","import type {\n  PrefetchAction,\n  ReducerState,\n  ReadonlyReducerState,\n} from '../router-reducer-types'\nimport { PromiseQueue } from '../../promise-queue'\nimport {\n  getOrCreatePrefetchCacheEntry,\n  prunePrefetchCache,\n} from '../prefetch-cache-utils'\nexport const prefetchQueue = new PromiseQueue(5)\n\nexport const prefetchReducer = process.env.__NEXT_CLIENT_SEGMENT_CACHE\n  ? identityReducerWhenSegmentCacheIsEnabled\n  : prefetchReducerImpl\n\nfunction identityReducerWhenSegmentCacheIsEnabled<T>(state: T): T {\n  // Unlike the old implementation, the Segment Cache doesn't store its data in\n  // the router reducer state.\n  //\n  // This shouldn't be reachable because we wrap the prefetch API in a check,\n  // too, which prevents the action from being dispatched. But it's here for\n  // clarity + code elimination.\n  return state\n}\n\nfunction prefetchReducerImpl(\n  state: ReadonlyReducerState,\n  action: PrefetchAction\n): ReducerState {\n  // let's prune the prefetch cache before we do anything else\n  prunePrefetchCache(state.prefetchCache)\n\n  const { url } = action\n\n  getOrCreatePrefetchCacheEntry({\n    url,\n    nextUrl: state.nextUrl,\n    prefetchCache: state.prefetchCache,\n    kind: action.kind,\n    tree: state.tree,\n    allowAliasing: true,\n  })\n\n  return state\n}\n","import type { FlightRouterState } from '../../../../server/app-render/types'\nimport { isInterceptionRouteAppPath } from '../../../../shared/lib/router/utils/interception-routes'\n\nexport function hasInterceptionRouteInCurrentTree([\n  segment,\n  parallelRoutes,\n]: FlightRouterState): boolean {\n  // If we have a dynamic segment, it's marked as an interception route by the presence of the `i` suffix.\n  if (Array.isArray(segment) && (segment[2] === 'di' || segment[2] === 'ci')) {\n    return true\n  }\n\n  // If segment is not an array, apply the existing string-based check\n  if (typeof segment === 'string' && isInterceptionRouteAppPath(segment)) {\n    return true\n  }\n\n  // Iterate through parallelRoutes if they exist\n  if (parallelRoutes) {\n    for (const key in parallelRoutes) {\n      if (hasInterceptionRouteInCurrentTree(parallelRoutes[key])) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","import type {\n  FlightRouterState,\n  FlightDataPath,\n  Segment,\n} from '../../../server/app-render/types'\nimport { getNextFlightSegmentPath } from '../../flight-data-helpers'\nimport { matchSegment } from '../match-segments'\n\n// TODO-APP: flightSegmentPath will be empty in case of static response, needs to be handled.\nexport function shouldHardNavigate(\n  flightSegmentPath: FlightDataPath,\n  flightRouterState: FlightRouterState\n): boolean {\n  const [segment, parallelRoutes] = flightRouterState\n  // TODO-APP: Check if `as` can be replaced.\n  const [currentSegment, parallelRouteKey] = flightSegmentPath as [\n    Segment,\n    string,\n  ]\n\n  // Check if current segment matches the existing segment.\n  if (!matchSegment(currentSegment, segment)) {\n    // If dynamic parameter in tree doesn't match up with segment path a hard navigation is triggered.\n    if (Array.isArray(currentSegment)) {\n      return true\n    }\n\n    // If the existing segment did not match soft navigation is triggered.\n    return false\n  }\n  const lastSegment = flightSegmentPath.length <= 2\n\n  if (lastSegment) {\n    return false\n  }\n\n  return shouldHardNavigate(\n    getNextFlightSegmentPath(flightSegmentPath),\n    parallelRoutes[parallelRouteKey]\n  )\n}\n","import type {\n  ActionFlightResponse,\n  ActionResult,\n} from '../../../../server/app-render/types'\nimport { callServer } from '../../../app-call-server'\nimport { findSourceMapURL } from '../../../app-find-source-map-url'\nimport {\n  ACTION_HEADER,\n  NEXT_ACTION_NOT_FOUND_HEADER,\n  NEXT_IS_PRERENDER_HEADER,\n  NEXT_ROUTER_STATE_TREE_HEADER,\n  NEXT_URL,\n  RSC_CONTENT_TYPE_HEADER,\n} from '../../app-router-headers'\nimport { UnrecognizedActionError } from '../../unrecognized-action-error'\n\n// TODO: Explicitly import from client.browser\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport {\n  createFromFetch as createFromFetchBrowser,\n  createTemporaryReferenceSet,\n  encodeReply,\n} from 'react-server-dom-webpack/client'\n\nimport {\n  PrefetchKind,\n  type ReadonlyReducerState,\n  type ReducerState,\n  type ServerActionAction,\n  type ServerActionMutable,\n} from '../router-reducer-types'\nimport { assignLocation } from '../../../assign-location'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { handleMutable } from '../handle-mutable'\nimport { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\nimport {\n  normalizeFlightData,\n  prepareFlightRouterStateForRequest,\n  type NormalizedFlightData,\n} from '../../../flight-data-helpers'\nimport { getRedirectError } from '../../redirect'\nimport { RedirectType } from '../../redirect-error'\nimport { createSeededPrefetchCacheEntry } from '../prefetch-cache-utils'\nimport { removeBasePath } from '../../../remove-base-path'\nimport { hasBasePath } from '../../../has-base-path'\nimport {\n  extractInfoFromServerReferenceId,\n  omitUnusedArgs,\n} from '../../../../shared/lib/server-reference-info'\nimport { revalidateEntireCache } from '../../segment-cache'\n\nconst createFromFetch =\n  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n\ntype FetchServerActionResult = {\n  redirectLocation: URL | undefined\n  redirectType: RedirectType | undefined\n  actionResult: ActionResult | undefined\n  actionFlightData: NormalizedFlightData[] | string | undefined\n  isPrerender: boolean\n  revalidatedParts: {\n    tag: boolean\n    cookie: boolean\n    paths: string[]\n  }\n}\n\nasync function fetchServerAction(\n  state: ReadonlyReducerState,\n  nextUrl: ReadonlyReducerState['nextUrl'],\n  { actionId, actionArgs }: ServerActionAction\n): Promise<FetchServerActionResult> {\n  const temporaryReferences = createTemporaryReferenceSet()\n  const info = extractInfoFromServerReferenceId(actionId)\n\n  // TODO: Currently, we're only omitting unused args for the experimental \"use\n  // cache\" functions. Once the server reference info byte feature is stable, we\n  // should apply this to server actions as well.\n  const usedArgs =\n    info.type === 'use-cache' ? omitUnusedArgs(actionArgs, info) : actionArgs\n\n  const body = await encodeReply(usedArgs, { temporaryReferences })\n\n  const res = await fetch(state.canonicalUrl, {\n    method: 'POST',\n    headers: {\n      Accept: RSC_CONTENT_TYPE_HEADER,\n      [ACTION_HEADER]: actionId,\n      [NEXT_ROUTER_STATE_TREE_HEADER]: prepareFlightRouterStateForRequest(\n        state.tree\n      ),\n      ...(process.env.NEXT_DEPLOYMENT_ID\n        ? {\n            'x-deployment-id': process.env.NEXT_DEPLOYMENT_ID,\n          }\n        : {}),\n      ...(nextUrl\n        ? {\n            [NEXT_URL]: nextUrl,\n          }\n        : {}),\n    },\n    body,\n  })\n\n  // Handle server actions that the server didn't recognize.\n  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n  if (unrecognizedActionHeader === '1') {\n    throw new UnrecognizedActionError(\n      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n    )\n  }\n\n  const redirectHeader = res.headers.get('x-action-redirect')\n  const [location, _redirectType] = redirectHeader?.split(';') || []\n  let redirectType: RedirectType | undefined\n  switch (_redirectType) {\n    case 'push':\n      redirectType = RedirectType.push\n      break\n    case 'replace':\n      redirectType = RedirectType.replace\n      break\n    default:\n      redirectType = undefined\n  }\n\n  const isPrerender = !!res.headers.get(NEXT_IS_PRERENDER_HEADER)\n  let revalidatedParts: FetchServerActionResult['revalidatedParts']\n  try {\n    const revalidatedHeader = JSON.parse(\n      res.headers.get('x-action-revalidated') || '[[],0,0]'\n    )\n    revalidatedParts = {\n      paths: revalidatedHeader[0] || [],\n      tag: !!revalidatedHeader[1],\n      cookie: revalidatedHeader[2],\n    }\n  } catch (e) {\n    revalidatedParts = NO_REVALIDATED_PARTS\n  }\n\n  const redirectLocation = location\n    ? assignLocation(\n        location,\n        new URL(state.canonicalUrl, window.location.href)\n      )\n    : undefined\n\n  const contentType = res.headers.get('content-type')\n  const isRscResponse = !!(\n    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n  )\n\n  // Handle invalid server action responses.\n  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n  if (!isRscResponse && !redirectLocation) {\n    // The server can respond with a text/plain error message, but we'll fallback to something generic\n    // if there isn't one.\n    const message =\n      res.status >= 400 && contentType === 'text/plain'\n        ? await res.text()\n        : 'An unexpected response was received from the server.'\n\n    throw new Error(message)\n  }\n\n  let actionResult: FetchServerActionResult['actionResult']\n  let actionFlightData: FetchServerActionResult['actionFlightData']\n  if (isRscResponse) {\n    const response: ActionFlightResponse = await createFromFetch(\n      Promise.resolve(res),\n      { callServer, findSourceMapURL, temporaryReferences }\n    )\n\n    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n    actionResult = redirectLocation ? undefined : response.a\n    actionFlightData = normalizeFlightData(response.f)\n  } else {\n    // An external redirect doesn't contain RSC data.\n    actionResult = undefined\n    actionFlightData = undefined\n  }\n\n  return {\n    actionResult,\n    actionFlightData,\n    redirectLocation,\n    redirectType,\n    revalidatedParts,\n    isPrerender,\n  }\n}\n\nconst NO_REVALIDATED_PARTS = {\n  paths: [],\n  tag: false,\n  cookie: false,\n}\n\n/*\n * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation.\n */\nexport function serverActionReducer(\n  state: ReadonlyReducerState,\n  action: ServerActionAction\n): ReducerState {\n  const { resolve, reject } = action\n  const mutable: ServerActionMutable = {}\n\n  let currentTree = state.tree\n\n  mutable.preserveCustomHistoryState = false\n\n  // only pass along the `nextUrl` param (used for interception routes) if the current route was intercepted.\n  // If the route has been intercepted, the action should be as well.\n  // Otherwise the server action might be intercepted with the wrong action id\n  // (ie, one that corresponds with the intercepted route)\n  const nextUrl =\n    state.nextUrl && hasInterceptionRouteInCurrentTree(state.tree)\n      ? state.nextUrl\n      : null\n\n  const navigatedAt = Date.now()\n\n  return fetchServerAction(state, nextUrl, action).then(\n    async ({\n      actionResult,\n      actionFlightData: flightData,\n      redirectLocation,\n      redirectType,\n      isPrerender,\n      revalidatedParts,\n    }) => {\n      let redirectHref: string | undefined\n\n      // honor the redirect type instead of defaulting to push in case of server actions.\n      if (redirectLocation) {\n        if (redirectType === RedirectType.replace) {\n          state.pushRef.pendingPush = false\n          mutable.pendingPush = false\n        } else {\n          state.pushRef.pendingPush = true\n          mutable.pendingPush = true\n        }\n\n        redirectHref = createHrefFromUrl(redirectLocation, false)\n        mutable.canonicalUrl = redirectHref\n      }\n\n      if (!flightData) {\n        resolve(actionResult)\n\n        // If there is a redirect but no flight data we need to do a mpaNavigation.\n        if (redirectLocation) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectLocation.href,\n            state.pushRef.pendingPush\n          )\n        }\n        return state\n      }\n\n      if (typeof flightData === 'string') {\n        // Handle case when navigating to page in `pages` from `app`\n        resolve(actionResult)\n\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      const actionRevalidated =\n        revalidatedParts.paths.length > 0 ||\n        revalidatedParts.tag ||\n        revalidatedParts.cookie\n\n      for (const normalizedFlightData of flightData) {\n        const {\n          tree: treePatch,\n          seedData: cacheNodeSeedData,\n          head,\n          isRootRender,\n        } = normalizedFlightData\n\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('SERVER ACTION APPLY FAILED')\n          resolve(actionResult)\n\n          return state\n        }\n\n        // Given the path can only have two items the items are only the router state and rsc for the root.\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          redirectHref ? redirectHref : state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          resolve(actionResult)\n\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          resolve(actionResult)\n\n          return handleExternalUrl(\n            state,\n            mutable,\n            redirectHref || state.canonicalUrl,\n            state.pushRef.pendingPush\n          )\n        }\n\n        // The server sent back RSC data for the server action, so we need to apply it to the cache.\n        if (cacheNodeSeedData !== null) {\n          const rsc = cacheNodeSeedData[1]\n          const cache: CacheNode = createEmptyCacheNode()\n          cache.rsc = rsc\n          cache.prefetchRsc = null\n          cache.loading = cacheNodeSeedData[3]\n          fillLazyItemsTillLeafWithHead(\n            navigatedAt,\n            cache,\n            // Existing cache is not passed in as server actions have to invalidate the entire cache.\n            undefined,\n            treePatch,\n            cacheNodeSeedData,\n            head,\n            undefined\n          )\n\n          mutable.cache = cache\n          if (process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n            revalidateEntireCache(state.nextUrl, newTree)\n          } else {\n            mutable.prefetchCache = new Map()\n          }\n          if (actionRevalidated) {\n            await refreshInactiveParallelSegments({\n              navigatedAt,\n              state,\n              updatedTree: newTree,\n              updatedCache: cache,\n              includeNextUrl: Boolean(nextUrl),\n              canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n            })\n          }\n        }\n\n        mutable.patchedTree = newTree\n        currentTree = newTree\n      }\n\n      if (redirectLocation && redirectHref) {\n        if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE && !actionRevalidated) {\n          // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n          // with the FlightData that we got from the server action for the target page, so that it's\n          // available when the page is navigated to and doesn't need to be re-fetched.\n          // We only do this if the server action didn't revalidate any data, as in that case the\n          // client cache will be cleared and the data will be re-fetched anyway.\n          // NOTE: We don't do this in the Segment Cache implementation.\n          // Dynamic data should never be placed into the cache, unless it's\n          // \"converted\" to static data using <Link prefetch={true}>. What we\n          // do instead is re-prefetch links and forms whenever the cache is\n          // invalidated.\n          createSeededPrefetchCacheEntry({\n            url: redirectLocation,\n            data: {\n              flightData,\n              canonicalUrl: undefined,\n              couldBeIntercepted: false,\n              prerendered: false,\n              postponed: false,\n              // TODO: We should be able to set this if the server action\n              // returned a fully static response.\n              staleTime: -1,\n            },\n            tree: state.tree,\n            prefetchCache: state.prefetchCache,\n            nextUrl: state.nextUrl,\n            kind: isPrerender ? PrefetchKind.FULL : PrefetchKind.AUTO,\n          })\n          mutable.prefetchCache = state.prefetchCache\n        }\n\n        // If the action triggered a redirect, the action promise will be rejected with\n        // a redirect so that it's handled by RedirectBoundary as we won't have a valid\n        // action result to resolve the promise with. This will effectively reset the state of\n        // the component that called the action as the error boundary will remount the tree.\n        // The status code doesn't matter here as the action handler will have already sent\n        // a response with the correct status code.\n        reject(\n          getRedirectError(\n            hasBasePath(redirectHref)\n              ? removeBasePath(redirectHref)\n              : redirectHref,\n            redirectType || RedirectType.push\n          )\n        )\n      } else {\n        resolve(actionResult)\n      }\n\n      return handleMutable(state, mutable)\n    },\n    (e: any) => {\n      // When the server action is rejected we don't update the state and instead call the reject handler of the promise.\n      reject(e)\n\n      return state\n    }\n  )\n}\n","import { fetchServerResponse } from '../fetch-server-response'\nimport { createHrefFromUrl } from '../create-href-from-url'\nimport { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\nimport { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\nimport type {\n  ReadonlyReducerState,\n  ReducerState,\n  HmrRefreshAction,\n  Mutable,\n} from '../router-reducer-types'\nimport { handleExternalUrl } from './navigate-reducer'\nimport { handleMutable } from '../handle-mutable'\nimport { applyFlightData } from '../apply-flight-data'\nimport type { CacheNode } from '../../../../shared/lib/app-router-context.shared-runtime'\nimport { createEmptyCacheNode } from '../../app-router'\nimport { handleSegmentMismatch } from '../handle-segment-mismatch'\nimport { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n\n// A version of refresh reducer that keeps the cache around instead of wiping all of it.\nfunction hmrRefreshReducerImpl(\n  state: ReadonlyReducerState,\n  action: HmrRefreshAction\n): ReducerState {\n  const { origin } = action\n  const mutable: Mutable = {}\n  const href = state.canonicalUrl\n\n  mutable.preserveCustomHistoryState = false\n\n  const cache: CacheNode = createEmptyCacheNode()\n  // If the current tree was intercepted, the nextUrl should be included in the request.\n  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n\n  // TODO-APP: verify that `href` is not an external url.\n  // Fetch data from the root of the tree.\n  const navigatedAt = Date.now()\n  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n    flightRouterState: [state.tree[0], state.tree[1], state.tree[2], 'refetch'],\n    nextUrl: includeNextUrl ? state.nextUrl : null,\n    isHmrRefresh: true,\n  })\n\n  return cache.lazyData.then(\n    ({ flightData, canonicalUrl: canonicalUrlOverride }) => {\n      // Handle case when navigating to page in `pages` from `app`\n      if (typeof flightData === 'string') {\n        return handleExternalUrl(\n          state,\n          mutable,\n          flightData,\n          state.pushRef.pendingPush\n        )\n      }\n\n      // Remove cache.lazyData as it has been resolved at this point.\n      cache.lazyData = null\n\n      let currentTree = state.tree\n      let currentCache = state.cache\n\n      for (const normalizedFlightData of flightData) {\n        const { tree: treePatch, isRootRender } = normalizedFlightData\n        if (!isRootRender) {\n          // TODO-APP: handle this case better\n          console.log('REFRESH FAILED')\n          return state\n        }\n\n        const newTree = applyRouterStatePatchToTree(\n          // TODO-APP: remove ''\n          [''],\n          currentTree,\n          treePatch,\n          state.canonicalUrl\n        )\n\n        if (newTree === null) {\n          return handleSegmentMismatch(state, action, treePatch)\n        }\n\n        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n          return handleExternalUrl(\n            state,\n            mutable,\n            href,\n            state.pushRef.pendingPush\n          )\n        }\n\n        const canonicalUrlOverrideHref = canonicalUrlOverride\n          ? createHrefFromUrl(canonicalUrlOverride)\n          : undefined\n\n        if (canonicalUrlOverride) {\n          mutable.canonicalUrl = canonicalUrlOverrideHref\n        }\n        const applied = applyFlightData(\n          navigatedAt,\n          currentCache,\n          cache,\n          normalizedFlightData\n        )\n\n        if (applied) {\n          mutable.cache = cache\n          currentCache = cache\n        }\n\n        mutable.patchedTree = newTree\n        mutable.canonicalUrl = href\n\n        currentTree = newTree\n      }\n      return handleMutable(state, mutable)\n    },\n    () => state\n  )\n}\n\nfunction hmrRefreshReducerNoop(\n  state: ReadonlyReducerState,\n  _action: HmrRefreshAction\n): ReducerState {\n  return state\n}\n\nexport const hmrRefreshReducer =\n  process.env.NODE_ENV === 'production'\n    ? hmrRefreshReducerNoop\n    : hmrRefreshReducerImpl\n","import {\n  ACTION_NAVIGATE,\n  ACTION_SERVER_PATCH,\n  ACTION_RESTORE,\n  ACTION_REFRESH,\n  ACTION_PREFETCH,\n  ACTION_HMR_REFRESH,\n  ACTION_SERVER_ACTION,\n} from './router-reducer-types'\nimport type {\n  ReducerActions,\n  ReducerState,\n  ReadonlyReducerState,\n} from './router-reducer-types'\nimport { navigateReducer } from './reducers/navigate-reducer'\nimport { serverPatchReducer } from './reducers/server-patch-reducer'\nimport { restoreReducer } from './reducers/restore-reducer'\nimport { refreshReducer } from './reducers/refresh-reducer'\nimport { prefetchReducer } from './reducers/prefetch-reducer'\nimport { hmrRefreshReducer } from './reducers/hmr-refresh-reducer'\nimport { serverActionReducer } from './reducers/server-action-reducer'\n\n/**\n * Reducer that handles the app-router state updates.\n */\nfunction clientReducer(\n  state: ReadonlyReducerState,\n  action: ReducerActions\n): ReducerState {\n  switch (action.type) {\n    case ACTION_NAVIGATE: {\n      return navigateReducer(state, action)\n    }\n    case ACTION_SERVER_PATCH: {\n      return serverPatchReducer(state, action)\n    }\n    case ACTION_RESTORE: {\n      return restoreReducer(state, action)\n    }\n    case ACTION_REFRESH: {\n      return refreshReducer(state, action)\n    }\n    case ACTION_HMR_REFRESH: {\n      return hmrRefreshReducer(state, action)\n    }\n    case ACTION_PREFETCH: {\n      return prefetchReducer(state, action)\n    }\n    case ACTION_SERVER_ACTION: {\n      return serverActionReducer(state, action)\n    }\n    // This case should never be hit as dispatch is strongly typed.\n    default:\n      throw new Error('Unknown action')\n  }\n}\n\nfunction serverReducer(\n  state: ReadonlyReducerState,\n  _action: ReducerActions\n): ReducerState {\n  return state\n}\n\n// we don't run the client reducer on the server, so we use a noop function for better tree shaking\nexport const reducer =\n  typeof window === 'undefined' ? serverReducer : clientReducer\n","import type { CacheNode } from '../../../shared/lib/app-router-context.shared-runtime'\nimport type {\n  FlightRouterState,\n  FlightSegmentPath,\n} from '../../../server/app-render/types'\nimport type { FetchServerResponseResult } from './fetch-server-response'\n\nexport const ACTION_REFRESH = 'refresh'\nexport const ACTION_NAVIGATE = 'navigate'\nexport const ACTION_RESTORE = 'restore'\nexport const ACTION_SERVER_PATCH = 'server-patch'\nexport const ACTION_PREFETCH = 'prefetch'\nexport const ACTION_HMR_REFRESH = 'hmr-refresh'\nexport const ACTION_SERVER_ACTION = 'server-action'\n\nexport type RouterChangeByServerResponse = ({\n  navigatedAt,\n  previousTree,\n  serverResponse,\n}: {\n  navigatedAt: number\n  previousTree: FlightRouterState\n  serverResponse: FetchServerResponseResult\n}) => void\n\nexport interface Mutable {\n  mpaNavigation?: boolean\n  patchedTree?: FlightRouterState\n  canonicalUrl?: string\n  scrollableSegments?: FlightSegmentPath[]\n  pendingPush?: boolean\n  cache?: CacheNode\n  prefetchCache?: AppRouterState['prefetchCache']\n  hashFragment?: string\n  shouldScroll?: boolean\n  preserveCustomHistoryState?: boolean\n  onlyHashChange?: boolean\n}\n\nexport interface ServerActionMutable extends Mutable {\n  inFlightServerAction?: Promise<any> | null\n}\n\n/**\n * Refresh triggers a refresh of the full page data.\n * - fetches the Flight data and fills rsc at the root of the cache.\n * - The router state is updated at the root.\n */\nexport interface RefreshAction {\n  type: typeof ACTION_REFRESH\n  origin: Location['origin']\n}\n\nexport interface HmrRefreshAction {\n  type: typeof ACTION_HMR_REFRESH\n  origin: Location['origin']\n}\n\nexport type ServerActionDispatcher = (\n  args: Omit<\n    ServerActionAction,\n    'type' | 'mutable' | 'navigate' | 'changeByServerResponse' | 'cache'\n  >\n) => void\n\nexport interface ServerActionAction {\n  type: typeof ACTION_SERVER_ACTION\n  actionId: string\n  actionArgs: any[]\n  resolve: (value: any) => void\n  reject: (reason?: any) => void\n}\n\n/**\n * Navigate triggers a navigation to the provided url. It supports two types: `push` and `replace`.\n *\n * `navigateType`:\n * - `push` - pushes a new history entry in the browser history\n * - `replace` - replaces the current history entry in the browser history\n *\n * Navigate has multiple cache heuristics:\n * - page was prefetched\n *  - Apply router state tree from prefetch\n *  - Apply Flight data from prefetch to the cache\n *  - If Flight data is a string, it's a redirect and the state is updated to trigger a redirect\n *  - Check if hard navigation is needed\n *    - Hard navigation happens when a dynamic parameter below the common layout changed\n *    - When hard navigation is needed the cache is invalidated below the flightSegmentPath\n *    - The missing cache nodes of the page will be fetched in layout-router and trigger the SERVER_PATCH action\n *  - If hard navigation is not needed\n *    - The cache is reused\n *    - If any cache nodes are missing they'll be fetched in layout-router and trigger the SERVER_PATCH action\n * - page was not prefetched\n *  - The navigate was called from `next/router` (`router.push()` / `router.replace()`) / `next/link` without prefetched data available (e.g. the prefetch didn't come back from the server before clicking the link)\n *    - Flight data is fetched in the reducer (suspends the reducer)\n *    - Router state tree is created based on Flight data\n *    - Cache is filled based on the Flight data\n *\n * Above steps explain 3 cases:\n * - `soft` - Reuses the existing cache and fetches missing nodes in layout-router.\n * - `hard` - Creates a new cache where cache nodes are removed below the common layout and fetches missing nodes in layout-router.\n * - `optimistic` (explicit no prefetch) - Creates a new cache and kicks off the data fetch in the reducer. The data fetch is awaited in the layout-router.\n */\nexport interface NavigateAction {\n  type: typeof ACTION_NAVIGATE\n  url: URL\n  isExternalUrl: boolean\n  locationSearch: Location['search']\n  navigateType: 'push' | 'replace'\n  shouldScroll: boolean\n  allowAliasing: boolean\n}\n\n/**\n * Restore applies the provided router state.\n * - Used for `popstate` (back/forward navigation) where a known router state has to be applied.\n * - Also used when syncing the router state with `pushState`/`replaceState` calls.\n * - Router state is applied as-is from the history state, if available.\n * - If the history state does not contain the router state, the existing router state is used.\n * - If any cache node is missing it will be fetched in layout-router during rendering and the server-patch case.\n * - If existing cache nodes match these are used.\n */\nexport interface RestoreAction {\n  type: typeof ACTION_RESTORE\n  url: URL\n  tree: FlightRouterState | undefined\n}\n\n/**\n * Server-patch applies the provided Flight data to the cache and router tree.\n * - Only triggered in layout-router.\n * - Creates a new cache and router state with the Flight data applied.\n */\nexport interface ServerPatchAction {\n  type: typeof ACTION_SERVER_PATCH\n  navigatedAt: number\n  serverResponse: FetchServerResponseResult\n  previousTree: FlightRouterState\n}\n\n/**\n * PrefetchKind defines the type of prefetching that should be done.\n * - `auto` - if the page is dynamic, prefetch the page data partially, if static prefetch the page data fully.\n * - `full` - prefetch the page data fully.\n * - `temporary` - a temporary prefetch entry is added to the cache, this is used when prefetch={false} is used in next/link or when you push a route programmatically.\n */\n\nexport enum PrefetchKind {\n  AUTO = 'auto',\n  FULL = 'full',\n  TEMPORARY = 'temporary',\n}\n\n/**\n * Prefetch adds the provided FlightData to the prefetch cache\n * - Creates the router state tree based on the patch in FlightData\n * - Adds the FlightData to the prefetch cache\n * - In ACTION_NAVIGATE the prefetch cache is checked and the router state tree and FlightData are applied.\n */\nexport interface PrefetchAction {\n  type: typeof ACTION_PREFETCH\n  url: URL\n  kind: PrefetchKind\n}\n\nexport interface PushRef {\n  /**\n   * If the app-router should push a new history entry in app-router's useEffect()\n   */\n  pendingPush: boolean\n  /**\n   * Multi-page navigation through location.href.\n   */\n  mpaNavigation: boolean\n  /**\n   * Skip applying the router state to the browser history state.\n   */\n  preserveCustomHistoryState: boolean\n}\n\nexport type FocusAndScrollRef = {\n  /**\n   * If focus and scroll should be set in the layout-router's useEffect()\n   */\n  apply: boolean\n  /**\n   * The hash fragment that should be scrolled to.\n   */\n  hashFragment: string | null\n  /**\n   * The paths of the segments that should be focused.\n   */\n  segmentPaths: FlightSegmentPath[]\n  /**\n   * If only the URLs hash fragment changed\n   */\n  onlyHashChange: boolean\n}\n\nexport type PrefetchCacheEntry = {\n  treeAtTimeOfPrefetch: FlightRouterState\n  data: Promise<FetchServerResponseResult>\n  kind: PrefetchKind\n  prefetchTime: number\n  staleTime: number\n  lastUsedTime: number | null\n  key: string\n  status: PrefetchCacheEntryStatus\n  url: URL\n}\n\nexport enum PrefetchCacheEntryStatus {\n  fresh = 'fresh',\n  reusable = 'reusable',\n  expired = 'expired',\n  stale = 'stale',\n}\n\n/**\n * Handles keeping the state of app-router.\n */\nexport type AppRouterState = {\n  /**\n   * The router state, this is written into the history state in app-router using replaceState/pushState.\n   * - Has to be serializable as it is written into the history state.\n   * - Holds which segments and parallel routes are shown on the screen.\n   */\n  tree: FlightRouterState\n  /**\n   * The cache holds React nodes for every segment that is shown on screen as well as previously shown segments.\n   * It also holds in-progress data requests.\n   * Prefetched data is stored separately in `prefetchCache`, that is applied during ACTION_NAVIGATE.\n   */\n  cache: CacheNode\n  /**\n   * Cache that holds prefetched Flight responses keyed by url.\n   */\n  prefetchCache: Map<string, PrefetchCacheEntry>\n  /**\n   * Decides if the update should create a new history entry and if the navigation has to trigger a browser navigation.\n   */\n  pushRef: PushRef\n  /**\n   * Decides if the update should apply scroll and focus management.\n   */\n  focusAndScrollRef: FocusAndScrollRef\n  /**\n   * The canonical url that is pushed/replaced.\n   * - This is the url you see in the browser.\n   */\n  canonicalUrl: string\n  /**\n   * The underlying \"url\" representing the UI state, which is used for intercepting routes.\n   */\n  nextUrl: string | null\n}\n\nexport type ReadonlyReducerState = Readonly<AppRouterState>\nexport type ReducerState = Promise<AppRouterState> | AppRouterState\nexport type ReducerActions = Readonly<\n  | RefreshAction\n  | NavigateAction\n  | RestoreAction\n  | ServerPatchAction\n  | PrefetchAction\n  | HmrRefreshAction\n  | ServerActionAction\n>\n"],"names":["setCacheBustingSearchParam","setCacheBustingSearchParamWithHash","url","headers","computeCacheBustingSearchParam","uniqueCacheKey","NEXT_ROUTER_PREFETCH_HEADER","NEXT_ROUTER_SEGMENT_PREFETCH_HEADER","NEXT_ROUTER_STATE_TREE_HEADER","NEXT_URL","hash","existingSearch","search","pairs","rawQuery","startsWith","slice","split","filter","pair","NEXT_RSC_UNION_QUERY","length","push","join","addRefreshMarkerToActiveParallelSegments","tree","path","segment","parallelRoutes","refetchMarker","key","includes","PAGE_SEGMENT_KEY","refreshInactiveParallelSegments","options","fetchedSegments","Set","refreshInactiveParallelSegmentsImpl","includeNextUrl","fetchPromises","fetchPromise","parallelFetchPromise","navigatedAt","state","updatedTree","updatedCache","rootTree","canonicalUrl","refetchPath","has","add","fetchServerResponse","URL","location","origin","flightRouterState","nextUrl","then","flightData","flightDataPath","applyFlightData","Promise","all","generateSegmentsFromPatch","handleExternalUrl","navigateReducer","action","isExternalUrl","navigateType","shouldScroll","allowAliasing","mutable","href","createHrefFromUrl","pendingPush","prunePrefetchCache","prefetchCache","preserveCustomHistoryState","toString","document","getElementById","prefetchValues","getOrCreatePrefetchCacheEntry","treeAtTimeOfPrefetch","data","prefetchQueue","bump","canonicalUrlOverride","postponed","Date","now","isFirstRead","lastUsedTime","aliased","urlWithCanonicalPathname","pathname","result","handleAliasedPrefetchEntry","updatedCanonicalUrl","onlyHashChange","hashFragment","scrollableSegments","handleMutable","currentTree","currentCache","cache","normalizedFlightData","pathToSegment","seedData","head","isHeadPartial","isRootRender","treePatch","flightSegmentPathWithLeadingEmpty","flightSegmentPath","newTree","applyRouterStatePatchToTree","task","startPPRNavigation","route","patchedRouterState","newCache","node","dynamicRequestTree","dynamicRequest","listenForDynamicRequest","isNavigatingToNewRootLayout","createEmptyCacheNode","applied","status","PrefetchCacheEntryStatus","stale","triggerLazyFetchForLeafSegments","appliedPatch","rsc","prefetchRsc","loading","Map","segmentPathsToFill","map","segmentPaths","clearCacheNodeDataForSegmentPath","shouldHardNavigate","invalidateCacheBelowFlightSegmentPath","subSegment","scrollableSegmentPath","DEFAULT_SEGMENT_KEY","patchedTree","mpaNavigation","undefined","flightRouterPatch","segments","Object","keys","entries","parallelRouteKey","parallelRoute","childSegment","serverPatchReducer","serverResponse","pushRef","segmentPath","canonicalUrlOverrideHref","restoreReducer","extractPathFromFlightRouterState","treeToRestore","oldCache","focusAndScrollRef","refreshReducer","hasInterceptionRouteInCurrentTree","lazyData","cacheNodeSeedData","handleSegmentMismatch","fillLazyItemsTillLeafWithHead","prefetchReducer","PromiseQueue","prefetchReducerImpl","process","identityReducerWhenSegmentCacheIsEnabled","kind","Array","isArray","isInterceptionRouteAppPath","currentSegment","matchSegment","getNextFlightSegmentPath","serverActionReducer","createFromFetch","createFromFetchBrowser","NO_REVALIDATED_PARTS","paths","tag","cookie","resolve","reject","fetchServerAction","info","usedArgs","body","res","redirectHeader","redirectType","isPrerender","revalidatedParts","revalidatedHeader","contentType","isRscResponse","actionResult","actionFlightData","response","encodeReply","actionId","actionArgs","temporaryReferences","createTemporaryReferenceSet","extractInfoFromServerReferenceId","type","omitUnusedArgs","fetch","method","Accept","RSC_CONTENT_TYPE_HEADER","ACTION_HEADER","prepareFlightRouterStateForRequest","unrecognizedActionHeader","get","NEXT_ACTION_NOT_FOUND_HEADER","UnrecognizedActionError","_redirectType","RedirectType","replace","NEXT_IS_PRERENDER_HEADER","JSON","parse","e","redirectLocation","assignLocation","window","text","message","callServer","findSourceMapURL","a","normalizeFlightData","f","redirectHref","actionRevalidated","Boolean","createSeededPrefetchCacheEntry","couldBeIntercepted","prerendered","staleTime","PrefetchKind","FULL","AUTO","getRedirectError","hasBasePath","removeBasePath","hmrRefreshReducer","hmrRefreshReducerNoop","_action","hmrRefreshReducerImpl","reducer","clientReducer","serverReducer","ACTION_NAVIGATE","ACTION_SERVER_PATCH","ACTION_RESTORE","ACTION_REFRESH","ACTION_HMR_REFRESH","ACTION_PREFETCH","ACTION_SERVER_ACTION"],"sourceRoot":"","ignoreList":[]}