{"version":3,"file":"static/chunks/4007-0aef8aebd14f88a5.js","mappings":"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","sources":["webpack://_N_E/../../../src/client/request/params.browser.ts","webpack://_N_E/../../../src/client/react-client-callbacks/report-global-error.ts","webpack://_N_E/../../../src/client/react-client-callbacks/on-recoverable-error.ts","webpack://_N_E/../../../src/client/request/search-params.browser.ts","webpack://_N_E/../../src/client/remove-base-path.ts","webpack://_N_E/../../../src/client/request/search-params.browser.prod.ts","webpack://_N_E/../../../src/client/react-client-callbacks/error-boundary-callbacks.ts","webpack://_N_E/../../src/client/normalize-trailing-slash.ts","webpack://_N_E/../../../src/client/request/params.browser.prod.ts","webpack://_N_E/../../src/client/route-params.ts"],"sourcesContent":["export const createRenderParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (require('./params.browser.dev') as typeof import('./params.browser.dev'))\n        .createRenderParamsFromClient\n    : (\n        require('./params.browser.prod') as typeof import('./params.browser.prod')\n      ).createRenderParamsFromClient\n","export const reportGlobalError =\n  typeof reportError === 'function'\n    ? // In modern browsers, reportError will dispatch an error event,\n      // emulating an uncaught JavaScript error.\n      reportError\n    : (error: unknown) => {\n        // TODO: Dispatch error event\n        globalThis.console.error(error)\n      }\n","// This module can be shared between both pages router and app router\n\nimport type { HydrationOptions } from 'react-dom/client'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport isError from '../../lib/is-error'\nimport { reportGlobalError } from './report-global-error'\n\nconst recoverableErrors = new WeakSet<Error>()\n\nexport function isRecoverableError(error: Error): boolean {\n  return recoverableErrors.has(error)\n}\n\nexport const onRecoverableError: HydrationOptions['onRecoverableError'] = (\n  error\n) => {\n  // x-ref: https://github.com/facebook/react/pull/28736\n  let cause = isError(error) && 'cause' in error ? error.cause : error\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(cause)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { decorateDevError } =\n      require('../../next-devtools/userspace/app/errors/stitched-error') as typeof import('../../next-devtools/userspace/app/errors/stitched-error')\n    const causeError = decorateDevError(cause)\n    recoverableErrors.add(causeError)\n    cause = causeError\n  }\n\n  reportGlobalError(cause)\n}\n","export const createRenderSearchParamsFromClient =\n  process.env.NODE_ENV === 'development'\n    ? (\n        require('./search-params.browser.dev') as typeof import('./search-params.browser.dev')\n      ).createRenderSearchParamsFromClient\n    : (\n        require('./search-params.browser.prod') as typeof import('./search-params.browser.prod')\n      ).createRenderSearchParamsFromClient\n","import { hasBasePath } from './has-base-path'\n\nconst basePath = (process.env.__NEXT_ROUTER_BASEPATH as string) || ''\n\nexport function removeBasePath(path: string): string {\n  if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {\n    if (!hasBasePath(path)) {\n      return path\n    }\n  }\n\n  // Can't trim the basePath if it has zero length!\n  if (basePath.length === 0) return path\n\n  path = path.slice(basePath.length)\n  if (!path.startsWith('/')) path = `/${path}`\n  return path\n}\n","import type { SearchParams } from '../../server/request/search-params'\n\nimport { wellKnownProperties } from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nfunction makeUntrackedExoticSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingSearchParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nexport function createRenderSearchParamsFromClient(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedSearchParams(underlyingSearchParams)\n  }\n\n  return makeUntrackedExoticSearchParams(underlyingSearchParams)\n}\n","// This file is only used in app router due to the specific error state handling.\n\nimport type { ErrorInfo } from 'react'\nimport { isNextRouterError } from '../components/is-next-router-error'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { reportGlobalError } from './report-global-error'\nimport { ErrorBoundaryHandler } from '../components/error-boundary'\nimport DefaultErrorBoundary from '../components/builtin/global-error'\n\nconst devToolErrorMod: typeof import('../../next-devtools/userspace/app/errors') =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../../next-devtools/userspace/app/errors') as typeof import('../../next-devtools/userspace/app/errors'))\n    : {\n        decorateDevError: (error: unknown) => error as Error,\n        handleClientError: () => {},\n        originConsoleError: console.error.bind(console),\n      }\n\nexport function onCaughtError(\n  thrownValue: unknown,\n  errorInfo: ErrorInfo & { errorBoundary?: React.Component }\n) {\n  const errorBoundaryComponent = errorInfo.errorBoundary?.constructor\n\n  let isImplicitErrorBoundary\n\n  if (process.env.NODE_ENV !== 'production') {\n    const { AppDevOverlayErrorBoundary } =\n      require('../../next-devtools/userspace/app/app-dev-overlay-error-boundary') as typeof import('../../next-devtools/userspace/app/app-dev-overlay-error-boundary')\n\n    isImplicitErrorBoundary =\n      errorBoundaryComponent === AppDevOverlayErrorBoundary\n  }\n\n  isImplicitErrorBoundary =\n    isImplicitErrorBoundary ||\n    (errorBoundaryComponent === ErrorBoundaryHandler &&\n      (errorInfo.errorBoundary! as InstanceType<typeof ErrorBoundaryHandler>)\n        .props.errorComponent === DefaultErrorBoundary)\n\n  // Skip the segment explorer triggered error\n  if (process.env.NODE_ENV !== 'production') {\n    const { SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE } =\n      require('../../next-devtools/userspace/app/segment-explorer-node') as typeof import('../../next-devtools/userspace/app/segment-explorer-node')\n    if (\n      thrownValue instanceof Error &&\n      thrownValue.message === SEGMENT_EXPLORER_SIMULATED_ERROR_MESSAGE\n    ) {\n      return\n    }\n  }\n\n  if (isImplicitErrorBoundary) {\n    // We don't consider errors caught unless they're caught by an explicit error\n    // boundary. The built-in ones are considered implicit.\n    // This mimics how the same app would behave without Next.js.\n    return onUncaughtError(thrownValue)\n  }\n\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const errorBoundaryName =\n      // read react component displayName\n      (errorBoundaryComponent as any)?.displayName ||\n      errorBoundaryComponent?.name ||\n      'Unknown'\n\n    const componentThatErroredFrame = errorInfo?.componentStack?.split('\\n')[1]\n\n    // Match chrome or safari stack trace\n    const matches =\n      // regex to match the function name in the stack trace\n      // example 1: at Page (http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1)\n      // example 2: Page@http://localhost:3000/_next/static/chunks/pages/index.js?ts=1631600000000:2:1\n      componentThatErroredFrame?.match(/\\s+at (\\w+)\\s+|(\\w+)@/) ?? []\n    const componentThatErroredName = matches[1] || matches[2] || 'Unknown'\n\n    // Create error location with errored component and error boundary, to match the behavior of default React onCaughtError handler.\n    const errorBoundaryMessage = `It was handled by the <${errorBoundaryName}> error boundary.`\n    const componentErrorMessage = componentThatErroredName\n      ? `The above error occurred in the <${componentThatErroredName}> component.`\n      : `The above error occurred in one of your components.`\n\n    const errorLocation = `${componentErrorMessage} ${errorBoundaryMessage}`\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // Log and report the error with location but without modifying the error stack\n    devToolErrorMod.originConsoleError('%o\\n\\n%s', thrownValue, errorLocation)\n\n    devToolErrorMod.handleClientError(error)\n  } else {\n    devToolErrorMod.originConsoleError(thrownValue)\n  }\n}\n\nexport function onUncaughtError(thrownValue: unknown) {\n  // Skip certain custom errors which are not expected to be reported on client\n  if (isBailoutToCSRError(thrownValue) || isNextRouterError(thrownValue)) return\n\n  if (process.env.NODE_ENV !== 'production') {\n    const error = devToolErrorMod.decorateDevError(thrownValue)\n\n    // TODO: Add an adendum to the overlay telling people about custom error boundaries.\n    reportGlobalError(error)\n  } else {\n    reportGlobalError(thrownValue)\n  }\n}\n","import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\nimport { parsePath } from '../shared/lib/router/utils/parse-path'\n\n/**\n * Normalizes the trailing slash of a path according to the `trailingSlash` option\n * in `next.config.js`.\n */\nexport const normalizePathTrailingSlash = (path: string) => {\n  if (!path.startsWith('/') || process.env.__NEXT_MANUAL_TRAILING_SLASH) {\n    return path\n  }\n\n  const { pathname, query, hash } = parsePath(path)\n  if (process.env.__NEXT_TRAILING_SLASH) {\n    if (/\\.[^/]+\\/?$/.test(pathname)) {\n      return `${removeTrailingSlash(pathname)}${query}${hash}`\n    } else if (pathname.endsWith('/')) {\n      return `${pathname}${query}${hash}`\n    } else {\n      return `${pathname}/${query}${hash}`\n    }\n  }\n\n  return `${removeTrailingSlash(pathname)}${query}${hash}`\n}\n","import type { Params } from '../../server/request/params'\nimport { wellKnownProperties } from '../../shared/lib/utils/reflect-utils'\n\ninterface CacheLifetime {}\nconst CachedParams = new WeakMap<CacheLifetime, Promise<Params>>()\n\nfunction makeUntrackedExoticParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  Object.keys(underlyingParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      ;(promise as any)[prop] = underlyingParams[prop]\n    }\n  })\n\n  return promise\n}\n\nfunction makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n  const cachedParams = CachedParams.get(underlyingParams)\n  if (cachedParams) {\n    return cachedParams\n  }\n\n  const promise = Promise.resolve(underlyingParams)\n  CachedParams.set(underlyingParams, promise)\n\n  return promise\n}\n\nexport function createRenderParamsFromClient(\n  clientParams: Params\n): Promise<Params> {\n  if (process.env.__NEXT_CACHE_COMPONENTS) {\n    return makeUntrackedParams(clientParams)\n  }\n\n  return makeUntrackedExoticParams(clientParams)\n}\n","import type { DynamicParamTypesShort } from '../server/app-render/types'\nimport {\n  addSearchParamsIfPageSegment,\n  DEFAULT_SEGMENT_KEY,\n  PAGE_SEGMENT_KEY,\n} from '../shared/lib/segment'\nimport { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\nimport {\n  NEXT_REWRITTEN_PATH_HEADER,\n  NEXT_REWRITTEN_QUERY_HEADER,\n  NEXT_RSC_UNION_QUERY,\n} from './components/app-router-headers'\nimport type { NormalizedSearch } from './components/segment-cache'\nimport type { RSCResponse } from './components/router-reducer/fetch-server-response'\n\nexport type RouteParamValue = string | Array<string> | null\n\nexport type RouteParam = {\n  name: string\n  value: RouteParamValue\n  type: DynamicParamTypesShort\n}\n\nexport function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n  // If the server performed a rewrite, the search params used to render the\n  // page will be different from the params in the request URL. In this case,\n  // the response will include a header that gives the rewritten search query.\n  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n  if (rewrittenQuery !== null) {\n    return (\n      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n    ) as NormalizedSearch\n  }\n  // If the header is not present, there was no rewrite, so we use the search\n  // query of the response URL.\n  return urlToUrlWithoutFlightMarker(new URL(response.url))\n    .search as NormalizedSearch\n}\n\nexport function getRenderedPathname(response: RSCResponse): string {\n  // If the server performed a rewrite, the pathname used to render the\n  // page will be different from the pathname in the request URL. In this case,\n  // the response will include a header that gives the rewritten pathname.\n  const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n  return (\n    rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname\n  )\n}\n\nexport function parseDynamicParamFromURLPart(\n  paramType: DynamicParamTypesShort,\n  pathnameParts: Array<string>,\n  partIndex: number\n): RouteParamValue {\n  // This needs to match the behavior in get-dynamic-param.ts.\n  switch (paramType) {\n    // Catchalls\n    case 'c':\n    case 'ci': {\n      // Catchalls receive all the remaining URL parts. If there are no\n      // remaining pathname parts, return an empty array.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : []\n    }\n    // Optional catchalls\n    case 'oc': {\n      // Optional catchalls receive all the remaining URL parts, unless this is\n      // the end of the pathname, in which case they return null.\n      return partIndex < pathnameParts.length\n        ? pathnameParts.slice(partIndex).map((s) => encodeURIComponent(s))\n        : null\n    }\n    // Dynamic\n    case 'd':\n    case 'di': {\n      if (partIndex >= pathnameParts.length) {\n        // The route tree expected there to be more parts in the URL than there\n        // actually are. This could happen if the x-nextjs-rewritten-path header\n        // is incorrectly set, or potentially due to bug in Next.js. TODO:\n        // Should this be a hard error? During a prefetch, we can just abort.\n        // During a client navigation, we could trigger a hard refresh. But if\n        // it happens during initial render, we don't really have any\n        // recovery options.\n        return ''\n      }\n      return encodeURIComponent(pathnameParts[partIndex])\n    }\n    default:\n      paramType satisfies never\n      return ''\n  }\n}\n\nexport function doesStaticSegmentAppearInURL(segment: string): boolean {\n  // This is not a parameterized segment; however, we need to determine\n  // whether or not this segment appears in the URL. For example, this route\n  // groups do not appear in the URL, so they should be skipped. Any other\n  // special cases must be handled here.\n  // TODO: Consider encoding this directly into the router tree instead of\n  // inferring it on the client based on the segment type. Something like\n  // a `doesAppearInURL` flag in FlightRouterState.\n  if (\n    segment === ROOT_SEGMENT_REQUEST_KEY ||\n    // For some reason, the loader tree sometimes includes extra __PAGE__\n    // \"layouts\" when part of a parallel route. But it's not a leaf node.\n    // Otherwise, we wouldn't need this special case because pages are\n    // always leaf nodes.\n    // TODO: Investigate why the loader produces these fake page segments.\n    segment.startsWith(PAGE_SEGMENT_KEY) ||\n    // Route groups.\n    (segment[0] === '(' && segment.endsWith(')')) ||\n    segment === DEFAULT_SEGMENT_KEY ||\n    segment === '/_not-found'\n  ) {\n    return false\n  } else {\n    // All other segment types appear in the URL\n    return true\n  }\n}\n\nexport function getCacheKeyForDynamicParam(\n  paramValue: RouteParamValue,\n  renderedSearch: NormalizedSearch\n): string {\n  // This needs to match the logic in get-dynamic-param.ts, until we're able to\n  // unify the various implementations so that these are always computed on\n  // the client.\n  if (typeof paramValue === 'string') {\n    // TODO: Refactor or remove this helper function to accept a string rather\n    // than the whole segment type. Also we can probably just append the\n    // search string instead of turning it into JSON.\n    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n      paramValue,\n      Object.fromEntries(new URLSearchParams(renderedSearch))\n    ) as string\n    return pageSegmentWithSearchParams\n  } else if (paramValue === null) {\n    return ''\n  } else {\n    return paramValue.join('/')\n  }\n}\n\nexport function urlToUrlWithoutFlightMarker(url: URL): URL {\n  const urlWithoutFlightParameters = new URL(url)\n  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n  if (process.env.NODE_ENV === 'production') {\n    if (\n      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n      urlWithoutFlightParameters.pathname.endsWith('.txt')\n    ) {\n      const { pathname } = urlWithoutFlightParameters\n      const length = pathname.endsWith('/index.txt') ? 10 : 4\n      // Slice off `/index.txt` or `.txt` from the end of the pathname\n      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n    }\n  }\n  return urlWithoutFlightParameters\n}\n\nexport function getParamValueFromCacheKey(\n  paramCacheKey: string,\n  paramType: DynamicParamTypesShort\n) {\n  // Turn the cache key string sent by the server (as part of FlightRouterState)\n  // into a value that can be passed to `useParams` and client components.\n  const isCatchAll = paramType === 'c' || paramType === 'oc'\n  if (isCatchAll) {\n    // Catch-all param keys are a concatenation of the path segments.\n    // See equivalent logic in `getSelectedParams`.\n    // TODO: We should just pass the array directly, rather than concatenate\n    // it to a string and then split it back to an array. It needs to be an\n    // array in some places, like when passing a key React, but we can convert\n    // it at runtime in those places.\n    return paramCacheKey.split('/')\n  }\n  return paramCacheKey\n}\n"],"names":["createRenderParamsFromClient","require","process","reportGlobalError","reportError","error","globalThis","console","isRecoverableError","onRecoverableError","recoverableErrors","WeakSet","has","cause","isError","isBailoutToCSRError","createRenderSearchParamsFromClient","removeBasePath","path","CachedSearchParams","WeakMap","underlyingSearchParams","cachedSearchParams","get","promise","Promise","resolve","set","Object","keys","forEach","prop","wellKnownProperties","onCaughtError","onUncaughtError","devToolErrorMod","decorateDevError","handleClientError","originConsoleError","bind","thrownValue","errorInfo","isImplicitErrorBoundary","errorBoundaryComponent","errorBoundary","constructor","ErrorBoundaryHandler","props","errorComponent","DefaultErrorBoundary","isNextRouterError","normalizePathTrailingSlash","startsWith","parsePath","pathname","query","hash","test","removeTrailingSlash","endsWith","CachedParams","clientParams","cachedParams","underlyingParams","doesStaticSegmentAppearInURL","getCacheKeyForDynamicParam","getParamValueFromCacheKey","getRenderedPathname","getRenderedSearch","parseDynamicParamFromURLPart","urlToUrlWithoutFlightMarker","response","rewrittenQuery","headers","NEXT_REWRITTEN_QUERY_HEADER","URL","url","search","rewrittenPath","NEXT_REWRITTEN_PATH_HEADER","paramType","pathnameParts","partIndex","length","slice","map","s","encodeURIComponent","segment","ROOT_SEGMENT_REQUEST_KEY","PAGE_SEGMENT_KEY","DEFAULT_SEGMENT_KEY","paramValue","renderedSearch","addSearchParamsIfPageSegment","fromEntries","URLSearchParams","join","urlWithoutFlightParameters","searchParams","delete","NEXT_RSC_UNION_QUERY","paramCacheKey","isCatchAll","split"],"sourceRoot":"","ignoreList":[]}