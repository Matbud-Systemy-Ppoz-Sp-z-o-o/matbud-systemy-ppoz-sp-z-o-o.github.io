{"version":3,"file":"static/chunks/radix.4980a82e2b5bb384.js","mappings":"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","sources":["webpack://_N_E/./node_modules/@radix-ui/react-dialog/node_modules/@radix-ui/react-slot/dist/index.mjs","webpack://_N_E/../src/dialog.tsx","webpack://_N_E/./node_modules/@radix-ui/react-visually-hidden/dist/index.mjs","webpack://_N_E/../src/toast.tsx"],"sourcesContent":["// src/slot.tsx\nimport * as React from \"react\";\nimport { composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { Fragment as Fragment2, jsx } from \"react/jsx-runtime\";\n// @__NO_SIDE_EFFECTS__\nfunction createSlot(ownerName) {\n  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);\n  const Slot2 = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n    if (slottable) {\n      const newElement = slottable.props.children;\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement) ? newElement.props.children : null;\n        } else {\n          return child;\n        }\n      });\n      return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });\n    }\n    return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });\n  });\n  Slot2.displayName = `${ownerName}.Slot`;\n  return Slot2;\n}\nvar Slot = /* @__PURE__ */ createSlot(\"Slot\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlotClone(ownerName) {\n  const SlotClone = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props2 = mergeProps(slotProps, children.props);\n      if (children.type !== React.Fragment) {\n        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props2);\n    }\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\nvar SLOTTABLE_IDENTIFIER = Symbol(\"radix.slottable\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlottable(ownerName) {\n  const Slottable2 = ({ children }) => {\n    return /* @__PURE__ */ jsx(Fragment2, { children });\n  };\n  Slottable2.displayName = `${ownerName}.Slottable`;\n  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable2;\n}\nvar Slottable = /* @__PURE__ */ createSlottable(\"Slottable\");\nfunction isSlottable(child) {\n  return React.isValidElement(child) && typeof child.type === \"function\" && \"__radixId\" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;\n}\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = { ...childProps };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n  return { ...slotProps, ...overrideProps };\n}\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nexport {\n  Slot as Root,\n  Slot,\n  Slottable,\n  createSlot,\n  createSlottable\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext, createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { RemoveScroll } from 'react-remove-scroll';\nimport { hideOthers } from 'aria-hidden';\nimport { createSlot } from '@radix-ui/react-slot';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Dialog\n * -----------------------------------------------------------------------------------------------*/\n\nconst DIALOG_NAME = 'Dialog';\n\ntype ScopedProps<P> = P & { __scopeDialog?: Scope };\nconst [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);\n\ntype DialogContextValue = {\n  triggerRef: React.RefObject<HTMLButtonElement | null>;\n  contentRef: React.RefObject<DialogContentElement | null>;\n  contentId: string;\n  titleId: string;\n  descriptionId: string;\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  onOpenToggle(): void;\n  modal: boolean;\n};\n\nconst [DialogProvider, useDialogContext] = createDialogContext<DialogContextValue>(DIALOG_NAME);\n\ninterface DialogProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  modal?: boolean;\n}\n\nconst Dialog: React.FC<DialogProps> = (props: ScopedProps<DialogProps>) => {\n  const {\n    __scopeDialog,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    modal = true,\n  } = props;\n  const triggerRef = React.useRef<HTMLButtonElement>(null);\n  const contentRef = React.useRef<DialogContentElement>(null);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: DIALOG_NAME,\n  });\n\n  return (\n    <DialogProvider\n      scope={__scopeDialog}\n      triggerRef={triggerRef}\n      contentRef={contentRef}\n      contentId={useId()}\n      titleId={useId()}\n      descriptionId={useId()}\n      open={open}\n      onOpenChange={setOpen}\n      onOpenToggle={React.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen])}\n      modal={modal}\n    >\n      {children}\n    </DialogProvider>\n  );\n};\n\nDialog.displayName = DIALOG_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'DialogTrigger';\n\ntype DialogTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface DialogTriggerProps extends PrimitiveButtonProps {}\n\nconst DialogTrigger = React.forwardRef<DialogTriggerElement, DialogTriggerProps>(\n  (props: ScopedProps<DialogTriggerProps>, forwardedRef) => {\n    const { __scopeDialog, ...triggerProps } = props;\n    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);\n    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);\n    return (\n      <Primitive.button\n        type=\"button\"\n        aria-haspopup=\"dialog\"\n        aria-expanded={context.open}\n        aria-controls={context.contentId}\n        data-state={getState(context.open)}\n        {...triggerProps}\n        ref={composedTriggerRef}\n        onClick={composeEventHandlers(props.onClick, context.onOpenToggle)}\n      />\n    );\n  }\n);\n\nDialogTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'DialogPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createDialogContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface DialogPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogPortal: React.FC<DialogPortalProps> = (props: ScopedProps<DialogPortalProps>) => {\n  const { __scopeDialog, forceMount, children, container } = props;\n  const context = useDialogContext(PORTAL_NAME, __scopeDialog);\n  return (\n    <PortalProvider scope={__scopeDialog} forceMount={forceMount}>\n      {React.Children.map(children, (child) => (\n        <Presence present={forceMount || context.open}>\n          <PortalPrimitive asChild container={container}>\n            {child}\n          </PortalPrimitive>\n        </Presence>\n      ))}\n    </PortalProvider>\n  );\n};\n\nDialogPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogOverlay\n * -----------------------------------------------------------------------------------------------*/\n\nconst OVERLAY_NAME = 'DialogOverlay';\n\ntype DialogOverlayElement = DialogOverlayImplElement;\ninterface DialogOverlayProps extends DialogOverlayImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogOverlay = React.forwardRef<DialogOverlayElement, DialogOverlayProps>(\n  (props: ScopedProps<DialogOverlayProps>, forwardedRef) => {\n    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);\n    const { forceMount = portalContext.forceMount, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);\n    return context.modal ? (\n      <Presence present={forceMount || context.open}>\n        <DialogOverlayImpl {...overlayProps} ref={forwardedRef} />\n      </Presence>\n    ) : null;\n  }\n);\n\nDialogOverlay.displayName = OVERLAY_NAME;\n\ntype DialogOverlayImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DialogOverlayImplProps extends PrimitiveDivProps {}\n\nconst Slot = createSlot('DialogOverlay.RemoveScroll');\n\nconst DialogOverlayImpl = React.forwardRef<DialogOverlayImplElement, DialogOverlayImplProps>(\n  (props: ScopedProps<DialogOverlayImplProps>, forwardedRef) => {\n    const { __scopeDialog, ...overlayProps } = props;\n    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);\n    return (\n      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`\n      // ie. when `Overlay` and `Content` are siblings\n      <RemoveScroll as={Slot} allowPinchZoom shards={[context.contentRef]}>\n        <Primitive.div\n          data-state={getState(context.open)}\n          {...overlayProps}\n          ref={forwardedRef}\n          // We re-enable pointer-events prevented by `Dialog.Content` to allow scrolling the overlay.\n          style={{ pointerEvents: 'auto', ...overlayProps.style }}\n        />\n      </RemoveScroll>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * DialogContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'DialogContent';\n\ntype DialogContentElement = DialogContentTypeElement;\ninterface DialogContentProps extends DialogContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst DialogContent = React.forwardRef<DialogContentElement, DialogContentProps>(\n  (props: ScopedProps<DialogContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    return (\n      <Presence present={forceMount || context.open}>\n        {context.modal ? (\n          <DialogContentModal {...contentProps} ref={forwardedRef} />\n        ) : (\n          <DialogContentNonModal {...contentProps} ref={forwardedRef} />\n        )}\n      </Presence>\n    );\n  }\n);\n\nDialogContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DialogContentTypeElement = DialogContentImplElement;\ninterface DialogContentTypeProps\n  extends Omit<DialogContentImplProps, 'trapFocus' | 'disableOutsidePointerEvents'> {}\n\nconst DialogContentModal = React.forwardRef<DialogContentTypeElement, DialogContentTypeProps>(\n  (props: ScopedProps<DialogContentTypeProps>, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);\n\n    // aria-hide everything except the content (better supported equivalent to setting aria-modal)\n    React.useEffect(() => {\n      const content = contentRef.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <DialogContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure focus isn't trapped once `DialogContent` has been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        disableOutsidePointerEvents\n        onCloseAutoFocus={composeEventHandlers(props.onCloseAutoFocus, (event) => {\n          event.preventDefault();\n          context.triggerRef.current?.focus();\n        })}\n        onPointerDownOutside={composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const originalEvent = event.detail.originalEvent;\n          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;\n          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;\n\n          // If the event is a right-click, we shouldn't close because\n          // it is effectively as if we right-clicked the `Overlay`.\n          if (isRightClick) event.preventDefault();\n        })}\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) =>\n          event.preventDefault()\n        )}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst DialogContentNonModal = React.forwardRef<DialogContentTypeElement, DialogContentTypeProps>(\n  (props: ScopedProps<DialogContentTypeProps>, forwardedRef) => {\n    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);\n    const hasInteractedOutsideRef = React.useRef(false);\n    const hasPointerDownOutsideRef = React.useRef(false);\n\n    return (\n      <DialogContentImpl\n        {...props}\n        ref={forwardedRef}\n        trapFocus={false}\n        disableOutsidePointerEvents={false}\n        onCloseAutoFocus={(event) => {\n          props.onCloseAutoFocus?.(event);\n\n          if (!event.defaultPrevented) {\n            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();\n            // Always prevent auto focus because we either focus manually or want user agent focus\n            event.preventDefault();\n          }\n\n          hasInteractedOutsideRef.current = false;\n          hasPointerDownOutsideRef.current = false;\n        }}\n        onInteractOutside={(event) => {\n          props.onInteractOutside?.(event);\n\n          if (!event.defaultPrevented) {\n            hasInteractedOutsideRef.current = true;\n            if (event.detail.originalEvent.type === 'pointerdown') {\n              hasPointerDownOutsideRef.current = true;\n            }\n          }\n\n          // Prevent dismissing when clicking the trigger.\n          // As the trigger is already setup to close, without doing so would\n          // cause it to close and immediately open.\n          const target = event.target as HTMLElement;\n          const targetIsTrigger = context.triggerRef.current?.contains(target);\n          if (targetIsTrigger) event.preventDefault();\n\n          // On Safari if the trigger is inside a container with tabIndex={0}, when clicked\n          // we will get the pointer down outside event on the trigger, but then a subsequent\n          // focus outside event on the container, we ignore any focus outside event when we've\n          // already had a pointer down outside event.\n          if (event.detail.originalEvent.type === 'focusin' && hasPointerDownOutsideRef.current) {\n            event.preventDefault();\n          }\n        }}\n      />\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype DialogContentImplElement = React.ComponentRef<typeof DismissableLayer>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ninterface DialogContentImplProps extends Omit<DismissableLayerProps, 'onDismiss'> {\n  /**\n   * When `true`, focus cannot escape the `Content` via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n\n  /**\n   * Event handler called when auto-focusing on open.\n   * Can be prevented.\n   */\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n}\n\nconst DialogContentImpl = React.forwardRef<DialogContentImplElement, DialogContentImplProps>(\n  (props: ScopedProps<DialogContentImplProps>, forwardedRef) => {\n    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;\n    const context = useDialogContext(CONTENT_NAME, __scopeDialog);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef);\n\n    // Make sure the whole tree has focus guards as our `Dialog` will be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    return (\n      <>\n        <FocusScope\n          asChild\n          loop\n          trapped={trapFocus}\n          onMountAutoFocus={onOpenAutoFocus}\n          onUnmountAutoFocus={onCloseAutoFocus}\n        >\n          <DismissableLayer\n            role=\"dialog\"\n            id={context.contentId}\n            aria-describedby={context.descriptionId}\n            aria-labelledby={context.titleId}\n            data-state={getState(context.open)}\n            {...contentProps}\n            ref={composedRefs}\n            onDismiss={() => context.onOpenChange(false)}\n          />\n        </FocusScope>\n        {process.env.NODE_ENV !== 'production' && (\n          <>\n            <TitleWarning titleId={context.titleId} />\n            <DescriptionWarning contentRef={contentRef} descriptionId={context.descriptionId} />\n          </>\n        )}\n      </>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * DialogTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'DialogTitle';\n\ntype DialogTitleElement = React.ComponentRef<typeof Primitive.h2>;\ntype PrimitiveHeading2Props = React.ComponentPropsWithoutRef<typeof Primitive.h2>;\ninterface DialogTitleProps extends PrimitiveHeading2Props {}\n\nconst DialogTitle = React.forwardRef<DialogTitleElement, DialogTitleProps>(\n  (props: ScopedProps<DialogTitleProps>, forwardedRef) => {\n    const { __scopeDialog, ...titleProps } = props;\n    const context = useDialogContext(TITLE_NAME, __scopeDialog);\n    return <Primitive.h2 id={context.titleId} {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nDialogTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'DialogDescription';\n\ntype DialogDescriptionElement = React.ComponentRef<typeof Primitive.p>;\ntype PrimitiveParagraphProps = React.ComponentPropsWithoutRef<typeof Primitive.p>;\ninterface DialogDescriptionProps extends PrimitiveParagraphProps {}\n\nconst DialogDescription = React.forwardRef<DialogDescriptionElement, DialogDescriptionProps>(\n  (props: ScopedProps<DialogDescriptionProps>, forwardedRef) => {\n    const { __scopeDialog, ...descriptionProps } = props;\n    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);\n    return <Primitive.p id={context.descriptionId} {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nDialogDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DialogClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'DialogClose';\n\ntype DialogCloseElement = React.ComponentRef<typeof Primitive.button>;\ninterface DialogCloseProps extends PrimitiveButtonProps {}\n\nconst DialogClose = React.forwardRef<DialogCloseElement, DialogCloseProps>(\n  (props: ScopedProps<DialogCloseProps>, forwardedRef) => {\n    const { __scopeDialog, ...closeProps } = props;\n    const context = useDialogContext(CLOSE_NAME, __scopeDialog);\n    return (\n      <Primitive.button\n        type=\"button\"\n        {...closeProps}\n        ref={forwardedRef}\n        onClick={composeEventHandlers(props.onClick, () => context.onOpenChange(false))}\n      />\n    );\n  }\n);\n\nDialogClose.displayName = CLOSE_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nconst TITLE_WARNING_NAME = 'DialogTitleWarning';\n\nconst [WarningProvider, useWarningContext] = createContext(TITLE_WARNING_NAME, {\n  contentName: CONTENT_NAME,\n  titleName: TITLE_NAME,\n  docsSlug: 'dialog',\n});\n\ntype TitleWarningProps = { titleId?: string };\n\nconst TitleWarning: React.FC<TitleWarningProps> = ({ titleId }) => {\n  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);\n\n  const MESSAGE = `\\`${titleWarningContext.contentName}\\` requires a \\`${titleWarningContext.titleName}\\` for the component to be accessible for screen reader users.\n\nIf you want to hide the \\`${titleWarningContext.titleName}\\`, you can wrap it with our VisuallyHidden component.\n\nFor more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;\n\n  React.useEffect(() => {\n    if (titleId) {\n      const hasTitle = document.getElementById(titleId);\n      if (!hasTitle) console.error(MESSAGE);\n    }\n  }, [MESSAGE, titleId]);\n\n  return null;\n};\n\nconst DESCRIPTION_WARNING_NAME = 'DialogDescriptionWarning';\n\ntype DescriptionWarningProps = {\n  contentRef: React.RefObject<DialogContentElement | null>;\n  descriptionId?: string;\n};\n\nconst DescriptionWarning: React.FC<DescriptionWarningProps> = ({ contentRef, descriptionId }) => {\n  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);\n  const MESSAGE = `Warning: Missing \\`Description\\` or \\`aria-describedby={undefined}\\` for {${descriptionWarningContext.contentName}}.`;\n\n  React.useEffect(() => {\n    const describedById = contentRef.current?.getAttribute('aria-describedby');\n    // if we have an id and the user hasn't set aria-describedby={undefined}\n    if (descriptionId && describedById) {\n      const hasDescription = document.getElementById(descriptionId);\n      if (!hasDescription) console.warn(MESSAGE);\n    }\n  }, [MESSAGE, contentRef, descriptionId]);\n\n  return null;\n};\n\nconst Root = Dialog;\nconst Trigger = DialogTrigger;\nconst Portal = DialogPortal;\nconst Overlay = DialogOverlay;\nconst Content = DialogContent;\nconst Title = DialogTitle;\nconst Description = DialogDescription;\nconst Close = DialogClose;\n\nexport {\n  createDialogScope,\n  //\n  Dialog,\n  DialogTrigger,\n  DialogPortal,\n  DialogOverlay,\n  DialogContent,\n  DialogTitle,\n  DialogDescription,\n  DialogClose,\n  //\n  Root,\n  Trigger,\n  Portal,\n  Overlay,\n  Content,\n  Title,\n  Description,\n  Close,\n  //\n  WarningProvider,\n};\nexport type {\n  DialogProps,\n  DialogTriggerProps,\n  DialogPortalProps,\n  DialogOverlayProps,\n  DialogContentProps,\n  DialogTitleProps,\n  DialogDescriptionProps,\n  DialogCloseProps,\n};\n","// src/visually-hidden.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar VISUALLY_HIDDEN_STYLES = Object.freeze({\n  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss\n  position: \"absolute\",\n  border: 0,\n  width: 1,\n  height: 1,\n  padding: 0,\n  margin: -1,\n  overflow: \"hidden\",\n  clip: \"rect(0, 0, 0, 0)\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n});\nvar NAME = \"VisuallyHidden\";\nvar VisuallyHidden = React.forwardRef(\n  (props, forwardedRef) => {\n    return /* @__PURE__ */ jsx(\n      Primitive.span,\n      {\n        ...props,\n        ref: forwardedRef,\n        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }\n      }\n    );\n  }\n);\nVisuallyHidden.displayName = NAME;\nvar Root = VisuallyHidden;\nexport {\n  Root,\n  VISUALLY_HIDDEN_STYLES,\n  VisuallyHidden\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ComponentRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `` and `t !== `\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ComponentRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? true,\n      onChange: onOpenChange,\n      caller: TOAST_NAME,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ComponentRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"],"names":["node","duration","event","Root"],"sourceRoot":"","ignoreList":[0,2]}